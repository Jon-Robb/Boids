<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>vect2d API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vect2d</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Optional
from math import (sqrt, tau, sin, cos, acos, atan2, degrees, radians,
                    isclose, trunc, ceil, floor)
from random import uniform



class Vect2D:
    &#34;&#34;&#34;La classe Vect2D encapsule les notions d&#39;un vecteur mathématique.
    
    Le vecteur est exprimé selon :
    
    - un espace à deux dimensions
    - un système de coordonnées cartésiennes
    - deux nombres réels (float) :
        - x, les abscisses
        - y, les ordonnées
    
    Plusieurs fonctionnalités sont disponibles :
    
    - propriétés et caractéristiques
    - représentation cartésienne et polaire
    - surcharge des opérateurs
    - vecteur unitaire
    - comparaison entre 2 vecteurs : angle, distance, perpendicularité, ...
    - produits, projections et réjections
        - scalaire
        - vectoriel
    - plusieurs fonctions utilitaires :
        - assignations diverses et réinitialisation
        - arrondissements
        - valeur absolue
        - distances
    - génération aléatoire
     
    Il existe plusieurs façons de **créer** un `Vect2D` :

    - `Vect2D()`
    - `Vect2D.from_vect2d`
    - `Vect2D.from_polar`
    - `Vect2D.from_polar_degrees`
    - `Vect2D.from_random_normalized`
    - `Vect2D.from_random_cartesian`
    - `Vect2D.from_random_polar`
    - `Vect2D.from_random_polar_degrees`
    - `Vect2D.from_data`
     
    Les **propriétés** (accesseurs et mutateurs) sont :
    
    - `Vect2D.is_defined` [lecture] : retourne vrai si le vecteur est défini
    - `Vect2D.is_normalized` [lecture] : retourne vrai si le vecteur est de longueur 1
    - `Vect2D.x` [lecture/écriture] : l&#39;abscisse de la coordonnée cartésienne
    - `Vect2D.y` [lecture/écriture] : l&#39;ordonnée de la coordonnée cartésienne
    - `Vect2D.length` [lecture/écriture] : la longueur de la coordonnée polaire
    - `Vect2D.length_squared` [lecture/écriture] : la longueur au carré de la coordonnée polaire
    - `Vect2D.orientation` [lecture/écriture] : l&#39;orientation de la coordonnée polaire en radians
    - `Vect2D.orientation_degrees` [lecture/écriture] : l&#39;orientation de la coordonnée polaire en degrées
    - `Vect2D.normalized` [lecture] : retourne vrai si le vecteur est unitaire
    - `Vect2D.right_perpendicular` [lecture] : retourne le vecteur perpendiculaire de droite
    - `Vect2D.left_perpendicular` [lecture] : retourne le vecteur perpendiculaire de gauche
    - `Vect2D.flipped` [lecture] : retourne le vecteur permuté
    - `Vect2D.manhattan_length` [lecture] : retourne la distance de Mannhatan
    - `Vect2D.chebyshev_length` [lecture] : retourne la distance de Chebyshev
    - `Vect2D.as_tuple` [lecture] : retourne un tuple de deux réels 
    - `Vect2D.as_list` [lecture] : retourne une liste de deux réels 
    - `Vect2D.as_dict` [lecture] : retourne un dictionnaire de deux réels avec &#39;x&#39; et &#39;y&#39; comme clés 
     
    Pour le système de coordonnées **cartésiennes** :
    
    - `Vect2D`
    - `Vect2D.x`
    - `Vect2D.y`
    - `Vect2D.clamp_x`
    - `Vect2D.clamp_y`
     
    Pour le système de coordonnées **polaires** :
    
    - `Vect2D.from_polar`
    - `Vect2D.set_polar`
    - `Vect2D.length_squared`
    - `Vect2D.length`
    - `Vect2D.orientation`
    - `Vect2D.limit_length_squared`
    - `Vect2D.limit_length`
     
    Pour la **normalisation** (unitaire) :
    
    - `Vect2D.is_normalized`
    - `Vect2D.normalize`
    - `Vect2D.normalized`
     
    Pour la **génération aléatoire** :

    - `Vect2D.randomize_normalized`
    - `Vect2D.randomize_cartesian`
    - `Vect2D.randomize_polar`
    - `Vect2D.from_random_normalized`
    - `Vect2D.from_random_cartesian`
    - `Vect2D.from_random_polar`
    - `Vect2D.from_random_polar_degrees`
    
    **Comparaison** de deux vecteurs :
    
    - `Vect2D.distance_squared_from`
    - `Vect2D.distance_from`
    - `Vect2D.is_perpendicular_to`
    - `Vect2D.is_parallel_to`
    - `Vect2D.angle_between`
    - `Vect2D.angle_disparity`
    - `Vect2D.is_forming_accute_angle_with`
    - `Vect2D.is_forming_obtuse_angle_with`
     
    **Produits** et **projection** entre 2 vecteurs :
    
    - `Vect2D.dot`
    - `Vect2D.cross`
    - `Vect2D.scalar_projection`
    - `Vect2D.vector_projection`
    - `Vect2D.scalar_rejection`
    - `Vect2D.vector_rejection`
    - `Vect2D.projection_analysis`
     
    **Surcharge** des **opérateurs** et **fonctions** standards de `Python` (`v` pour vecteur et `s` pour scalaire) :
    
    - Comparaison entre 2 vecteurs : 
        - `v1 == v2`
        - `v1 != v2`
        - ne modifie pas les vecteurs
        - retourne un `bool`
    - Inverse d&#39;un vecteur :
        - `-v`
        - ne modifie pas le vecteur
        - retourne une nouvelle instance de `Vect2D`
    - Addition ou soustraction de 2 vecteurs :
        - `v1 + v2`
        - `v1 - v2`
        - ne modifie pas les vecteurs
        - retourne une nouvelle instance de `Vect2D`
    - Addition ou soustraction avec assignation de 2 vecteurs :
        - `v1 += v2`
        - `v1 -= v2`
        - modifie l&#39;instance de gauche sans modifier l&#39;instance de droite
        - retourne l&#39;instance de gauche
    - Multiplicationt ou division entre 1 vecteur et 1 scalaire :
        - `v * s`
        - `s * v`
        - `v / s`
        - `s / v`
        - ne modifie pas le vecteur ou le scalaire
        - retourne une nouvelle instance de `Vect2D`
    - Multiplicationt ou division avec assignation entre 1 vecteur et 1 scalaire :
        - `v *= s`
        - `v /= s`
        - modifie l&#39;instance de gauche (le vecteur) sans modifier l&#39;instance de droite (le scalaire)
        - retourne l&#39;instance de gauche (le vecteur)
    - Fonctions d&#39;arrondissement
        - toutes ces fonction :
            - ne modifie pas l&#39;instance passée
            - retourne une nouvelle instance de `Vect2D`
            - les valeur `x` et `y` restent des `float` même si elles sont arrondies
        - `round(v)`
            - affectue l&#39;arrondissement de `x` et de `y` vers l&#39;entier le plus près
        - `trunc(v)`
            - affectue une arrondissement de `x` et de `y` vers zéro
        - `floor(v)`
            - affectue une arrondissement de `x` et de `y` vers l&#39;infini négatif
        - `ceil(v)`
            - affectue une arrondissement de `x` et de `y` vers l&#39;infini positif
    - Autres fonctions utilitaires
        - `abs(v)`
            - ne modifie pas l&#39;instance passée
            - retourne une nouvelle instance de `Vect2D`
            - valeure absolue de `x` et de `y`
        - `complex(v)`
            - ne modifie pas l&#39;instance passée
            - retourne un nombre complexe représentant le vecteur
            
    **Conversion** vers un type externe et utilitaires :
    
    - Conversion : 
        - `bool(v)` :
            - retourne un booléen vrai si le vecteur est défini
        - `repr(v)` :
            - retourne une chaîne de caractères technique
        - `str(v)` :
            - retourne une chaîne de caractères descriptive
            - les fonctions suivantes permettent de paramétriser la conversion
                - `Vect2D.set_string_format`
                - `Vect2D.set_value_format`
        - `Vect2D.as_tuple` :
            - retourne un tuple de deux réels 
        - `Vect2D.as_list` :
            - retourne une liste de deux réels 
        - `Vect2D.as_dict` :
            - retourne un dictionnaire de deux réels 

    Le vecteur est aussi un **itérateur** : 

    - l&#39;itérateur pointe vers l&#39;instance originale et reste une _vue_ de ce 
      vecteur
            
    Exemples de l&#39;itérateur :
    
        &gt;&gt;&gt; v1 = Vect2D(1.0, -2.5)
        &gt;&gt;&gt; for coord in v1:
        ...     print(coord)
        1.0
        -2.5
        &gt;&gt;&gt; i = iter(v1)
        &gt;&gt;&gt; print(next(i))
        1.0
        &gt;&gt;&gt; v1.y = 100.0
        &gt;&gt;&gt; print(next(i))
        100.0
    &#34;&#34;&#34;
    
    
    __slots__ = (&#39;x&#39;, &#39;y&#39;)

    
    def __clamp(min_value : int | float, value : int | float, max_value : int | float) -&gt; int | float:
        return max(min_value, min(value, max_value))
    
    
    #-------------------------------------------    
    #     ____                _   _             
    #    / ___|_ __ ___  __ _| |_(_) ___  _ __  
    #   | |   | &#39;__/ _ \/ _` | __| |/ _ \| &#39;_ \ 
    #   | |___| | |  __/ (_| | |_| | (_) | | | |
    #    \____|_|  \___|\__,_|\__|_|\___/|_| |_|
    #                                           
    #-------------------------------------------    
    def __init__(self, x : int | float = 0., y : int | float = 0.) -&gt; None:
        &#34;&#34;&#34;Création d&#39;un objet `Vect2D` utilisant le système de coordonnées cartésiennes.
        
        Args:
            x (int | float): La valeur des abscisse. Defaults = 0.0
            y (int | float): La valeur des ordonnées. Defaults = 0.0

        Exemples:
            &gt;&gt;&gt; vect = Vect2D()
            &gt;&gt;&gt; print(vect)
            (0.00E+00, 0.00E+00)
            &gt;&gt;&gt; vect = Vect2D(-1.0, 1.0)
            &gt;&gt;&gt; print(vect)
            (-1.00E+00, 1.00E+00)
        &#34;&#34;&#34;
        self.x : float = float(x)
        &#34;&#34;&#34;`Read &amp; Write`
        
        La valeur des abscisses selon le système de coordonnées cartésiennes.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.x = 5.0
            &gt;&gt;&gt; print(v1)
            (5.00E+00, 0.00E+00)
        &#34;&#34;&#34;
        self.y : float = float(y)
        &#34;&#34;&#34;`Read &amp; Write`
        
        La valeur des ordonnées selon le système de coordonnées cartésiennes.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.y = -5.0
            &gt;&gt;&gt; print(v1)
            (0.00E+00, -5.00E+00)
        &#34;&#34;&#34;

    @classmethod
    def from_vect2d(cls, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Création un nouvel objet `Vect2D` identique à un autre.
        
        Args:
            other (Vect2D): Le vecteur à cloner.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(-1.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D.from_vect2d(v1)
            &gt;&gt;&gt; print(v2)
            (-1.00E+00, 1.00E+00)
        &#34;&#34;&#34;
        return cls(other.x, other.y)
    
    
    
    #-----------------------------------------------------------------------------------
    #    ____  _        _                                                 _             
    #   / ___|| |_ _ __(_)_ __   __ _    ___ ___  _ ____   _____ _ __ ___(_) ___  _ __  
    #   \___ \| __| &#39;__| | &#39;_ \ / _` |  / __/ _ \| &#39;_ \ \ / / _ \ &#39;__/ __| |/ _ \| &#39;_ \ 
    #    ___) | |_| |  | | | | | (_| | | (_| (_) | | | \ V /  __/ |  \__ \ | (_) | | | |
    #   |____/ \__|_|  |_|_| |_|\__, |  \___\___/|_| |_|\_/ \___|_|  |___/_|\___/|_| |_|
    #                           |___/                                                   
    #-----------------------------------------------------------------------------------
    
    __string_prefix = &#39;(&#39;
    __string_separator = &#39;, &#39;
    __string_suffix = &#39;)&#39;
    __string_use_scientific_notation = True
    __string_trailing_zeros_length = 2
    __string_value_format = &#39;.2E&#39;
    
    @staticmethod
    def set_string_format(prefix : str = None, separator : str = None, suffix : str = None) -&gt; None:
        &#34;&#34;&#34;Détermine le format du texte lors de la conversion vers une chaîne 
        de caractères : préfixe, séparateur et suffixe.
        
        Args:
            prefix (str): Le text précédant la coordonnées x. Si None, le préfixe reste inchangé. Defaults = None
            separator (str): Le texte entre les coordonnées x et y. Si None, le séparator est laissé inchangé. Defaults = None
            suffix (str): le texte après la coordonnées y. Si None, le suffixe est laissé inchangé. Defaults = None

        Exemples:
            &gt;&gt;&gt; vect = Vect2D(20000.0, 3.141592654)
            &gt;&gt;&gt; print(vect)
            (2.00E+04, 3.14E+00)
            &gt;&gt;&gt; Vect2D.set_string_format(&#39;[[[ &#39;, &#39; : &#39;, &#39; ]]]&#39;)
            &gt;&gt;&gt; print(vect)
            [[[ 2.00E+04 : 3.14E+00 ]]]
            &gt;&gt;&gt; Vect2D.set_string_format(&#39;(&#39;, &#39;, &#39;, &#39;)&#39;)
        &#34;&#34;&#34;
        if prefix: Vect2D.__string_prefix = prefix
        if separator: Vect2D.__string_separator = separator
        if suffix: Vect2D.__string_suffix = suffix

        
    @staticmethod
    def set_value_format(use_scientific_notation : Optional[bool] = None, trailing_zeros_length : Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;Détermine le format des réels lors de la conversoin vers une chaîne 
        de caractères : la représentation des nombres réels x et y.
        
        Args:
            use_scientific_notation (bool): Si True, utilise la notation scientifique. Si False, la notation fixe. Si None, la notation reste inchangée. Defaults = None
            trailing_zeros_length (int): Détermine le nombre de 0 après la virgule. Si None, le &#39;padding&#39; reste inchangé. Defaults = None

        Exemples:
            &gt;&gt;&gt; vect = Vect2D(20000.0, 3.141592654)
            &gt;&gt;&gt; print(vect)
            (2.00E+04, 3.14E+00)
            &gt;&gt;&gt; Vect2D.set_value_format(False, 3)
            &gt;&gt;&gt; print(vect)
            (20000.000, 3.142)
            &gt;&gt;&gt; Vect2D.set_value_format(True, 2)
        &#34;&#34;&#34;
        use_scientific_notation = Vect2D.__string_use_scientific_notation if use_scientific_notation is None else use_scientific_notation
        trailing_zeros_length = Vect2D.__string_trailing_zeros_length if trailing_zeros_length is None else trailing_zeros_length
        Vect2D.__string_value_format = f&#39;.{trailing_zeros_length}{&#34;E&#34; if use_scientific_notation else &#34;f&#34;}&#39;


    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Retourne une chaîne de caractères contenant une représentation 
        technique de du vecteur.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, -2.0)
            &gt;&gt;&gt; print(repr(v1))
            vect2d.Vect2D(x=2.0, y=-2.0)
        &#34;&#34;&#34;
        return f&#39;vect2d.Vect2D(x={self.x}, y={self.y})&#39;


    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Retourne une chaîne de caractères représentant le vecteur.
        
        Cette représentation est paramétrée par les fonctions :
         - set_string_format
         - set_value_format

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, -2.0)
            &gt;&gt;&gt; print(v1)
            (2.00E+00, -2.00E+00)
        &#34;&#34;&#34;
        return f&#39;{Vect2D.__string_prefix}{self.x:{Vect2D.__string_value_format}}{Vect2D.__string_separator}{self.y:{Vect2D.__string_value_format}}{Vect2D.__string_suffix}&#39;

    class __Vect2D_Iter:
        def __init__(self, vect2d : &#39;Vect2D&#39;):
            self.__vect2d = vect2d
            self.__i = 0
            
        def __next__(self):
            if self.__i == 0:
                self.__i += 1
                return self.__vect2d.x
            if self.__i == 1:
                self.__i += 1
                return self.__vect2d.y
            else:
                raise StopIteration
            

    def __iter__(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(2.0, -1.5)
        &gt;&gt;&gt; tu = tuple(v1)
        &gt;&gt;&gt; li = list(v1)
        &gt;&gt;&gt; print(tu)
        (2.0, -1.5)
        &gt;&gt;&gt; print(li)
        [2.0, -1.5]
        &#34;&#34;&#34;
        return Vect2D.__Vect2D_Iter(self)
    

    #--------------------------------------
    #     ____                           _ 
    #    / ___| ___ _ __   ___ _ __ __ _| |
    #   | |  _ / _ \ &#39;_ \ / _ \ &#39;__/ _` | |
    #   | |_| |  __/ | | |  __/ | | (_| | |
    #    \____|\___|_| |_|\___|_|  \__,_|_|
    #                                      
    #--------------------------------------


    def __bool__(self) -&gt; bool:
        &#34;&#34;&#34;Conversion du vecteur vers un booléen en effectuant une validation
        du vecteur. Le vecteur est valide s&#39;il est défini.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; print(&#39;ok&#39; if v1 else &#39;failed&#39;)
            ok
            &gt;&gt;&gt; v1.reset()
            &gt;&gt;&gt; print(&#39;ok&#39; if v1 else &#39;failed&#39;)
            failed
        &#34;&#34;&#34;        
        return self.is_defined
    
    @property
    def is_defined(self) -&gt; bool:     
        &#34;&#34;&#34;`Read only`
        
        Retourne `True` si le vecteur est défini, `False` autrement. Un vecteur 
        indéfini est un vecteur de longueur 0.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; v1.is_defined
            True
            &gt;&gt;&gt; v1.reset()
            &gt;&gt;&gt; v1.is_defined
            False
        &#34;&#34;&#34;
        return not(isclose(self.x, 0.) and isclose(self.y, 0.))

    



    #---------------------------------------------------------------
    #       _            _                                  _       
    #      / \   ___ ___(_) __ _ _ __  _ __ ___   ___ _ __ | |_ ___ 
    #     / _ \ / __/ __| |/ _` | &#39;_ \| &#39;_ ` _ \ / _ \ &#39;_ \| __/ __|
    #    / ___ \\__ \__ \ | (_| | | | | | | | | |  __/ | | | |_\__ \
    #   /_/   \_\___/___/_|\__, |_| |_|_| |_| |_|\___|_| |_|\__|___/
    #                      |___/                                    
    #---------------------------------------------------------------

    def copy(self) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Retourne une copie (deepcopy) du vecteur. 
                
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.14, 2.81)
            &gt;&gt;&gt; v2 = v1.copy()
            &gt;&gt;&gt; print(v2)
            (3.14E+00, 2.81E+00)
        &#34;&#34;&#34;        
        return Vect2D(self.x, self.y)
    
    def copy_from(self, other : &#39;Vect2D&#39;) -&gt; None:
        &#34;&#34;&#34;Copie les coordonnées x et y d&#39;un vecteur source vers celui-ci.
        
        Args:
            other (Vect2D): Le vecteur source.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v2 = Vect2D(-2.0, 1.5)
            &gt;&gt;&gt; v1.copy_from(v2)
            &gt;&gt;&gt; print(v1)
            (-2.00E+00, 1.50E+00)
        &#34;&#34;&#34;
        self.x, self.y = other.x, other.y
    
    def copy_to(self, other : &#39;Vect2D&#39;) -&gt; None:
        &#34;&#34;&#34;Copie les coordonnées courantes x et y vers un autre vecteur.
        
        Args:
            other (Vect2D): Le vecteur cible.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v2 = Vect2D(2.0, -1.5)
            &gt;&gt;&gt; v2.copy_to(v1)
            &gt;&gt;&gt; print(v1)
            (2.00E+00, -1.50E+00)
        &#34;&#34;&#34;
        other.x, other.y = self.x, self.y

    def set(self, x : int | float, y : int | float) -&gt; None:      
        &#34;&#34;&#34;Détermine les valeurs x et y.
        
        Args:
            x (float | int): La coordonnées en x.
            y (float | int): La coordonnées en y.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.set(-2.0, -1.5)
            &gt;&gt;&gt; print(v1)
            (-2.00E+00, -1.50E+00)
        &#34;&#34;&#34;
        self.x, self.y = float(x), float(y)

    def reset(self) -&gt; None:
        &#34;&#34;&#34;Réinitialise le vecteur (0.0, 0.0). Le vecteur est indéfini.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 1.5)
            &gt;&gt;&gt; print(v1)
            (2.00E+00, 1.50E+00)
            &gt;&gt;&gt; v1.reset()
            &gt;&gt;&gt; print(v1)
            (0.00E+00, 0.00E+00)
        &#34;&#34;&#34;        
        self.x, self.y = 0., 0.



    #------------------------------------------------------------------------------------------------------    
    #     ____           _            _                                       _ _             _            
    #    / ___|__ _ _ __| |_ ___  ___(_) __ _ _ __     ___ ___   ___  _ __ __| (_)_ __   __ _| |_ ___  ___ 
    #   | |   / _` | &#39;__| __/ _ \/ __| |/ _` | &#39;_ \   / __/ _ \ / _ \| &#39;__/ _` | | &#39;_ \ / _` | __/ _ \/ __|
    #   | |__| (_| | |  | ||  __/\__ \ | (_| | | | | | (_| (_) | (_) | | | (_| | | | | | (_| | ||  __/\__ \
    #    \____\__,_|_|   \__\___||___/_|\__,_|_| |_|  \___\___/ \___/|_|  \__,_|_|_| |_|\__,_|\__\___||___/
    #                                                                                                      
    #------------------------------------------------------------------------------------------------------    
    def clamp_x(self, x_min : float, x_max : float) -&gt; None:
        &#34;&#34;&#34;Borne l&#39;abscisse entre deux limites.
        
        Args:
            x_min (float): La borne inférieure.
            x_max (float): La borne supérieure.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; v1.clamp_x(2.5, 5.0)
            &gt;&gt;&gt; print(v1)
            (2.50E+00, 0.00E+00)
        &#34;&#34;&#34;             
        self.x = Vect2D.__clamp(x_min, self.x, x_max)

    def clamp_y(self, y_min : float, y_max : float) -&gt; None:
        &#34;&#34;&#34;Borne l&#39;ordonnée entre deux limites.
        
        Args:
            y_min (float): La borne inférieure.
            y_max (float): La borne supérieure.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; v1.clamp_y(5.0, 10.0)
            &gt;&gt;&gt; print(v1)
            (2.00E+00, 5.00E+00)
        &#34;&#34;&#34;             
        self.y = Vect2D.__clamp(y_min, self.y, y_max)
    
    @property
    def manhattan_length(self) -&gt; float:
        &#34;&#34;&#34;`Read only`
        
        Retourne la distance de Manhattan.
        
        Cette distance correspond à la distance orthogonale totale à parcourir 
        considérant chacun des axes : | x | + | y |.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
            &gt;&gt;&gt; v1.manhattan_length
            7.0
        &#34;&#34;&#34;     
        return abs(self.x) + abs(self.y)
    
    @property
    def chebyshev_length(self) -&gt; float:
        &#34;&#34;&#34;`Read only`
        
        Retourne la distance de Chebyshev.
        
        Cette distance correspond à la distance la plus grande entre les 
        abscisses et les ordonnées.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
            &gt;&gt;&gt; v1.chebyshev_length
            5.0
        &#34;&#34;&#34;     
        return max(abs(self.x), abs(self.y))
    
    
    def minkowski_length(self, order : float = 2.) -&gt; float:
        &#34;&#34;&#34;Retourne la distance de Minkowski.
        
        Args:
            order (float): Le coefficient de puissance utilisé. Defaults = 2.0

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
            &gt;&gt;&gt; v1.minkowski_length(1)
            3.0
        &#34;&#34;&#34;               
        return (abs(self.x) ** order + abs(self.y) ** order) ** (1. / order)

    @property
    def right_perpendicular(self) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;`Read only`
        
        Retourne une nouvelle instance de &#39;Vect2D&#39; représentant une rotation 
        de 90° vers la droite.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
            &gt;&gt;&gt; print(v1.right_perpendicular)
            (1.00E+00, -2.00E+00)
        &#34;&#34;&#34;             
        return Vect2D(self.y, -self.x)
    
    @property # getter only
    def left_perpendicular(self) -&gt; &#39;Vect2D&#39;: # name ?
        &#34;&#34;&#34;`Read only`
        
        Retourne une nouvelle instance de &#39;Vect2D&#39; représentant une rotation 
        de 90° vers la gauche.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
            &gt;&gt;&gt; print(v1.left_perpendicular)
            (-1.00E+00, 2.00E+00)
        &#34;&#34;&#34;             
        return Vect2D(-self.y, self.x)    
    
    @property
    def flipped(self) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;`Read only`
        
        Retourne une nouvelle instance de &#39;Vect2D&#39; ayant les coordonnées 
        permutées.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
            &gt;&gt;&gt; print(v1.flipped)
            (5.00E+00, 2.00E+00)
        &#34;&#34;&#34;           
        return Vect2D(self.y, self.x)
        
    def flip(self) -&gt; None:
        &#34;&#34;&#34;Permute les valeurs x et y.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
            &gt;&gt;&gt; v1.flip()
            &gt;&gt;&gt; print(v1)
            (5.00E+00, 2.00E+00)
        &#34;&#34;&#34;
        self.x, self.y = self.y, self.x
        
        
        


        
    
    
    #-----------------------------------------------------------------------------------
    #    ____       _                                      _ _             _            
    #   |  _ \ ___ | | __ _ _ __    ___ ___   ___  _ __ __| (_)_ __   __ _| |_ ___  ___ 
    #   | |_) / _ \| |/ _` | &#39;__|  / __/ _ \ / _ \| &#39;__/ _` | | &#39;_ \ / _` | __/ _ \/ __|
    #   |  __/ (_) | | (_| | |    | (_| (_) | (_) | | | (_| | | | | | (_| | ||  __/\__ \
    #   |_|   \___/|_|\__,_|_|     \___\___/ \___/|_|  \__,_|_|_| |_|\__,_|\__\___||___/
    #                                                                                   
    #-----------------------------------------------------------------------------------

    @classmethod
    def from_polar(cls, length : float, orientation : float) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Retourne un vecteur issu de la représentation polaire passée en 
        argument. 
        
        La représentation finale du vecteur est toujours selon un 
        système de coordonnées cartésiennes.
        
        L&#39;orientation est en radians.
        
        Args:
            length (float): La longueur de la coordonnée polaire. 
            orientation (float): L&#39;orientation&#39; de la coordonnée polaire. 

        Exemples:
            &gt;&gt;&gt; from math import pi
            &gt;&gt;&gt; v1 = round(Vect2D.from_polar(5.0, pi/2.))
            &gt;&gt;&gt; print(v1)
            (0.00E+00, 5.00E+00)
        &#34;&#34;&#34;
        return cls(cos(orientation) * length, sin(orientation) * length)


    @classmethod
    def from_polar_degrees(cls, length : float, orientation : float) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Retourne un vecteur issu de la représentation polaire passée en 
        argument. 
        
        La représentation finale du vecteur est toujours selon un 
        système de coordonnées cartésiennes.
        
        L&#39;orientation est en degrées.
        
        Args:
            length (float): La longueur de la coordonnée polaire. 
            orientation (float): L&#39;orientation&#39; de la coordonnée polaire. 

        Exemples:
            &gt;&gt;&gt; v1 = round(Vect2D.from_polar_degrees(5.0, 90.))
            &gt;&gt;&gt; print(v1)
            (0.00E+00, 5.00E+00)
        &#34;&#34;&#34;
        return cls.from_polar(length, radians(orientation))
    
    def set_polar(self, length : float, orientation : float) -&gt; None:
        &#34;&#34;&#34;Détermine le vecteur courant par la représentation polaire passée en 
        argument. 
        
        La représentation finale du vecteur est toujours selon un 
        système de coordonnées cartésiennes.
        
        L&#39;orientation est en radians.
        
        Args:
            length (float): La longueur de la coordonnée polaire. 
            orientation (float): L&#39;orientation&#39; de la coordonnée polaire. 

        Exemples:
            &gt;&gt;&gt; from math import pi
            &gt;&gt;&gt; Vect2D.set_value_format(False, 1)
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.set_polar(5.0, pi/2.)
            &gt;&gt;&gt; print(v1)
            (0.0, 5.0)
            &gt;&gt;&gt; Vect2D.set_value_format(True, 2)
        &#34;&#34;&#34;        
        self.x = length * cos(orientation)
        self.y = length * sin(orientation)

    @property
    def length_squared(self) -&gt; float:
        &#34;&#34;&#34;`Read &amp; Write`
        
        La longueur du vecteur au carré.
        
        Correspond à la distance au carré du système de coordonnées polaires. 
        La métrique retournée correspond à la distance euclidienne.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(1.0, 2.0)
            &gt;&gt;&gt; v1.length_squared
            5.0
        &#34;&#34;&#34;
        return self.x ** 2. + self.y ** 2.
    
    @length_squared.setter
    def length_squared(self, value : float) -&gt; None:
        self.set_polar(sqrt(value), self.orientation)

    @property
    def length(self) -&gt; float:
        &#34;&#34;&#34;`Read &amp; Write`
        
        La longueur du vecteur.
        
        Correspond à la distance du système de coordonnées polaires. 
        La métrique retournée correspond à la distance euclidienne.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
            &gt;&gt;&gt; v1.length
            1.4142135623730951
        &#34;&#34;&#34;
        return sqrt(self.length_squared)
    
    @length.setter
    def length(self, value : float) -&gt; None:
        self.set_polar(value, self.orientation)
    
    @property
    def orientation(self) -&gt; float:
        &#34;&#34;&#34;`Read &amp; Write`
        
        L&#39;orientation du vecteur.
        
        Correspond à l&#39;orientation du système de coordonnées polaires. 
        La métrique retournée est l&#39;angle en radians.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
            &gt;&gt;&gt; v1.orientation
            0.7853981633974483
        &#34;&#34;&#34;        
        return atan2(self.y, self.x)
    
    @orientation.setter
    def orientation(self, value : float) -&gt; None:
        self.set_polar(self.length, value)
        
    @property
    def orientation_degrees(self) -&gt; float:
        &#34;&#34;&#34;`Read &amp; Write`
        
        L&#39;orientation du vecteur.
        
        Correspond à l&#39;orientation du système de coordonnées polaires. 
        La métrique retournée est l&#39;angle en degrées.
                
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
            &gt;&gt;&gt; v1.orientation_degrees
            45.0
        &#34;&#34;&#34;
        return degrees(atan2(self.y, self.x))
    
    @orientation_degrees.setter
    def orientation_degrees(self, value : float) -&gt; None:
        self.set_polar(self.length, radians(value))

    def limit_length_squared(self, max_length_squared : float) -&gt; None:
        &#34;&#34;&#34;Limite la longueur au carré du vecteur. 
        
        Si la longueur au carré est plus petite que la limite, le vecteur 
        reste inchangé. Si la longueur au carré est plus grande, le vecteur 
        est limité à la longueur au carré maximum indiquée. 
        
        Args:
            max_length_squared (float): La longueur au carré maximum que le 
            vecteur peut avoir. Cette longueur doit être strictement positive.
            (max_length_squared &gt; 0.0)

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; v1.limit_length_squared(9.0)
            &gt;&gt;&gt; print(v1)
            (3.00E+00, 0.00E+00)
            &gt;&gt;&gt; v1.limit_length_squared(25.0)
            &gt;&gt;&gt; print(v1)
            (3.00E+00, 0.00E+00)
        &#34;&#34;&#34;
        if self.length_squared &gt; max_length_squared:
            self.length_squared = max_length_squared

    def limit_length(self, max_length : float) -&gt; None:
        &#34;&#34;&#34;Limite la longueur du vecteur. 
        
        Si la longueur est plus petite que la limite, le vecteur reste 
        inchangé. Si la longueur est plus grande, le vecteur est limité 
        à la longueur maximum indiquée. 
        
        Args:
            max_length (float): La longueur maximum que le vecteur peut 
            avoir. Cette longueur doit être strictement positive.
            (max_length_squared &gt; 0.0)

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(0.0, 5.0)
            &gt;&gt;&gt; v1.limit_length(3.0)
            &gt;&gt;&gt; print(round(v1))
            (0.00E+00, 3.00E+00)
            &gt;&gt;&gt; v1.limit_length(5.0)
            &gt;&gt;&gt; print(round(v1))
            (0.00E+00, 3.00E+00)
        &#34;&#34;&#34;
        if self.length_squared &gt; max_length * max_length:
            self.length = max_length

    def clamp_length_squared(self, min_length_squared : float, max_length_squared : float) -&gt; None:
        &#34;&#34;&#34;Borne la longueur au carré du vecteur. 
        
        La longueur au carré est bornée aux limites inférieures et supérieures.
        
        0 &lt; min_length_squared &lt; max_length_squared
        
        Args:
            min_length_squared (float): La longueur au carré minimum que le 
                vecteur peut avoir. Cette longueur doit être strictement 
                positive et inférieure à la longueur au carré maximum. 
            max_length_squared (float): La longueur au carré maximum que le 
                vecteur peut avoir. Cette longueur doit être strictement 
                positive et supérieure à la longueur au carré minimum. 

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; v1.clamp_length_squared(9.0, 16.0)
            &gt;&gt;&gt; print(v1)
            (4.00E+00, 0.00E+00)
            &gt;&gt;&gt; v1.clamp_length_squared(9.0, 25.0)
            &gt;&gt;&gt; print(v1)
            (4.00E+00, 0.00E+00)
        &#34;&#34;&#34;
        length_squared = self.length_squared
        if length_squared &lt; min_length_squared:
            self.length_squared = min_length_squared
        elif length_squared &gt; max_length_squared:
            self.length_squared = max_length_squared

    def clamp_length(self, min_length : float, max_length : float) -&gt; None:
        &#34;&#34;&#34;Borne la longueur du vecteur. 
        
        La longueur est bornée aux limites inférieures et supérieures.
        
        0 &lt; min_length &lt; max_length

        Args:
            min_length (float): La longueur minimum que le vecteur peut 
                avoir. Cette longueur doit être strictement positive et 
                inférieure à la longueur maximum. 
            max_length (float): La longueur maximum que le vecteur peut 
                avoir. Cette longueur doit être strictement positive et 
                supérieure à la longueur minimum. 

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; v1.clamp_length(3.0, 4.0)
            &gt;&gt;&gt; print(v1)
            (4.00E+00, 0.00E+00)
            &gt;&gt;&gt; v1.clamp_length(3.0, 5.0)
            &gt;&gt;&gt; print(v1)
            (4.00E+00, 0.00E+00)
        &#34;&#34;&#34;
        length_sqared = self.length_squared
        if length_sqared &lt; min_length * min_length:
            self.length = min_length
        elif length_sqared &gt; max_length * max_length:
            self.length = max_length

    # to do
    # def clamp_orientation(self, orientation_from : float, orientation_to : float) -&gt; None:
    #     # orientation = self.orientation
    #     ...


    
    #--------------------------------------------------------------------
    #    _   _                            _ _          _   _             
    #   | \ | | ___  _ __ _ __ ___   __ _| (_)______ _| |_(_) ___  _ __  
    #   |  \| |/ _ \| &#39;__| &#39;_ ` _ \ / _` | | |_  / _` | __| |/ _ \| &#39;_ \ 
    #   | |\  | (_) | |  | | | | | | (_| | | |/ / (_| | |_| | (_) | | | |
    #   |_| \_|\___/|_|  |_| |_| |_|\__,_|_|_/___\__,_|\__|_|\___/|_| |_|
    #                                                                    
    #--------------------------------------------------------------------

    @property
    def is_normalized(self) -&gt; bool:
        &#34;&#34;&#34;`Read only`
        
        Est-ce que le vecteur est normalisé.
        
        Un vecteur normalisé est un vecteur unitaire (de longueur 1.0).
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v2 = Vect2D(1.0, 0.0)
            &gt;&gt;&gt; v1.is_normalized
            False
            &gt;&gt;&gt; v2.is_normalized
            True
        &#34;&#34;&#34;
        return isclose(self.length_squared, 1.0)    

    @property
    def normalized(self) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;`Read only`
        
        Retourne une nouvelle instance de &#39;Vect2D&#39; correspondant au vecteur  
        unitaire du vecteur courant.
        
        Le vecteur doit être défini.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; v2 = v1.normalized
            &gt;&gt;&gt; print(v2)
            (1.00E+00, 0.00E+00)
        &#34;&#34;&#34;        
        vect = Vect2D(self.x, self.y)
        vect.normalize()
        return vect
    
    def normalize(self) -&gt; None:
        &#34;&#34;&#34;Modifie le vecteur courant pour qu&#39;il soit unitaire.
        Cette transformation garde l&#39;angle du vecteur.
        
        Le vecteur doit être défini.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; v1.normalize()
            &gt;&gt;&gt; print(v1)
            (1.00E+00, 0.00E+00)
        &#34;&#34;&#34;
        if self.is_defined:
            norm = self.length
            self.x /= norm
            self.y /= norm
        else:
            raise RuntimeError(&#39;cannot normalize a non defined vector&#39;)





    
#------------------------------------------------------------------------    
#    ____                 _                 _          _   _             
#   |  _ \ __ _ _ __   __| | ___  _ __ ___ (_)______ _| |_(_) ___  _ __  
#   | |_) / _` | &#39;_ \ / _` |/ _ \| &#39;_ ` _ \| |_  / _` | __| |/ _ \| &#39;_ \ 
#   |  _ &lt; (_| | | | | (_| | (_) | | | | | | |/ / (_| | |_| | (_) | | | |
#   |_| \_\__,_|_| |_|\__,_|\___/|_| |_| |_|_/___\__,_|\__|_|\___/|_| |_|
#                                                                        
#------------------------------------------------------------------------    



    def randomize_normalized(self) -&gt; None:
        &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur unitaire aléatoire.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.randomize_normalized()
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (1.00E+00, 0.00E+00)
        &#34;&#34;&#34;        
        self.set_polar(1.0, uniform(0., tau))

    def randomize_cartesian(self, x_min : float, x_max : float, y_min : float, y_max : float) -&gt; None:
        &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur aléatoire 
        paramétré dans le système de coordonnées cartésiennes.
        
        Args:
            x_min (float): La borne inférieure sur l&#39;axe des abscisses.
            x_max (float): La borne supérieure sur l&#39;axe des abscisses.
            y_min (float): La borne inférieure sur l&#39;axe des ordonnées.
            y_max (float): La borne supérieure sur l&#39;axe des ordonnées.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.randomize_cartesian(0., 100., 0, 100.)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 77.00E+00)
        &#34;&#34;&#34;                
        self.x = uniform(x_min, x_max)
        self.y = uniform(y_min, y_max)

    # def randomize_polar(self, minLength, maxLength, minOrientation=0., maxOrientation=tau) -&gt; None:
    #     self.set_polar(uniform(minLength, maxLength), uniform(minOrientation, maxOrientation))
    def randomize_polar(self, length_min : float, length_max : float, orientation_half_span  : float = tau, orientation_reference : float = 0.) -&gt; None:
        &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur aléatoire 
        paramétré dans le système de coordonnées polaires.
        
        L&#39;orientation est définie en radians.
                
        Args:
            length_min (float): La longueur inférieure (sur l&#39;axe des distances).
            length_max (float): La longueur spérieure (sur l&#39;axe des distances).
            orientation_half_span (float): L&#39;étendu de l&#39;orientation en radians (sur l&#39;axe de rotation). Defaults = tau
            orientation_reference (float): L&#39;angle de référence en radians (sur l&#39;axe de rotation). Defaults = 0.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 3.14)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 28.00E+00)
        &#34;&#34;&#34;                        
        self.set_polar(uniform(length_min, length_max), uniform(-orientation_half_span, orientation_half_span) + orientation_reference)
    
    def randomize_polar_degrees(self, length_min : float, length_max : float, orientation_half_span  : float = 360., orientation_reference : float = 0.) -&gt; None:
        &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur aléatoire 
        paramétré dans le système de coordonnées polaires.
        
        L&#39;orientation est définie en degrées.
        
        Args:
            length_min (float): La longueur inférieure (sur l&#39;axe des distances).
            length_max (float): La longueur spérieure (sur l&#39;axe des distances).
            orientation_half_span (float): L&#39;étendu de l&#39;orientation en degrées (sur l&#39;axe de rotation). Defaults = 360.
            orientation_reference (float): L&#39;angle de référence en degrées (sur l&#39;axe de rotation). Defaults = 0.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 90.)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 28.00E+00)
        &#34;&#34;&#34;                        
        self.randomize_polar(length_min, length_max, radians(orientation_half_span), radians(orientation_reference))
    
    @classmethod
    def from_random_normalized(cls) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; correspondant à vecteur unitaire aléatoire.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D.from_random_normalized()
            &gt;&gt;&gt; print() # doctest: +SKIP
            (1.00E+00, 0.00E+00)
        &#34;&#34;&#34;           
        vect2d = cls()
        vect2d.randomize_normalized()
        return vect2d
    
    @classmethod
    def from_random_cartesian(cls, x_min : float, x_max : float, y_min : float, y_max : float) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; aléatoirement paramétré 
        dans le système de coordonnées cartésiennes.
        
        Args:
            x_min (float): La borne inférieure sur l&#39;axe des abscisses.
            x_max (float): La borne supérieure sur l&#39;axe des abscisses.
            y_min (float): La borne inférieure sur l&#39;axe des ordonnées.
            y_max (float): La borne supérieure sur l&#39;axe des ordonnées.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D.from_random_cartesian(0., 100., 0, 100.)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 77.00E+00)
        &#34;&#34;&#34;    
        vect2d = cls()
        vect2d.randomize_cartesian(x_min, x_max, y_min, y_max)
        return vect2d
    
    @classmethod
    def from_random_polar(cls, length_min : float, length_max : float, orientation_half_span : float = tau, orientation_reference : float = 0.) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; aléatoirement paramétré
        dans le système de coordonnées polaires.
        
        L&#39;orientation est définie en radians.
                
        Args:
            length_min (float): La longueur inférieure (sur l&#39;axe des distances).
            length_max (float): La longueur spérieure (sur l&#39;axe des distances).
            orientation_half_span (float): L&#39;étendu de l&#39;orientation en radians (sur l&#39;axe de rotation). Defaults = tau
            orientation_reference (float): L&#39;angle de référence en radians (sur l&#39;axe de rotation). Defaults = 0.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D.from_random_polar(0., 100., 0., 3.14)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 28.00E+00)
        &#34;&#34;&#34;      
        vect2d = cls()
        vect2d.randomize_polar(length_min, length_max, orientation_half_span, orientation_reference)
        return vect2d
    
    @classmethod
    def from_random_polar_degrees(cls, length_min : float, length_max : float, orientation_half_span : float = 360., orientation_reference : float = 0.) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; aléatoirement paramétré
        dans le système de coordonnées polaires.
        
        L&#39;orientation est définie en degrées.
                
        Args:
            length_min (float): La longueur inférieure (sur l&#39;axe des distances).
            length_max (float): La longueur spérieure (sur l&#39;axe des distances).
            orientation_half_span (float): L&#39;étendu de l&#39;orientation en degrées (sur l&#39;axe de rotation). Defaults = 360.
            orientation_reference (float): L&#39;angle de référence en degrées (sur l&#39;axe de rotation). Defaults = 0.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 90.)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 28.00E+00)
        &#34;&#34;&#34;
        return cls.from_random_polar_degrees(length_min, length_max, radians(orientation_half_span), radians(orientation_reference))
    
        

    

    #------------------------------------------------------------------------------------------------------------
    #   __        __         _    _                        _ _   _       ____   __     __        _   ____  ____  
    #   \ \      / /__  _ __| | _(_)_ __   __ _  __      _(_) |_| |__   |___ \  \ \   / /__  ___| |_|___ \|  _ \ 
    #    \ \ /\ / / _ \| &#39;__| |/ / | &#39;_ \ / _` | \ \ /\ / / | __| &#39;_ \    __) |  \ \ / / _ \/ __| __| __) | | | |
    #     \ V  V / (_) | |  |   &lt;| | | | | (_| |  \ V  V /| | |_| | | |  / __/    \ V /  __/ (__| |_ / __/| |_| |
    #      \_/\_/ \___/|_|  |_|\_\_|_| |_|\__, |   \_/\_/ |_|\__|_| |_| |_____|    \_/ \___|\___|\__|_____|____/ 
    #                                     |___/                                                                  
    #------------------------------------------------------------------------------------------------------------
    
    def distance_squared_from(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne la distance euclidienne au carré entre ce vecteur et 
        celui passé en argument.
        
        Args:
            other (Vect2D): L&#39;autre vecteur dont la distance est à évaluer.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
            &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
            &gt;&gt;&gt; v1.distance_squared_from(v2)
            25.0
        &#34;&#34;&#34;        
        return (self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y)
    
    def distance_from(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne la distance euclidienne entre ce vecteur et celui 
        passé en argument.
        
        Args:
            other (Vect2D): L&#39;autre vecteur dont la distance est à évaluer.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
            &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
            &gt;&gt;&gt; v1.distance_from(v2)
            5.0
        &#34;&#34;&#34;        
        return sqrt(self.distance_squared_from(other))
    
    def is_perpendicular_to(self, other : &#39;Vect2D&#39;) -&gt; bool:
        &#34;&#34;&#34;Retourne &#39;True&#39; si ce vecteur est perpendiculaire à celui 
        passé en argument. Sinon retourne &#39;False&#39;.
        
        Args:
            other (Vect2D): L&#39;autre vecteur à comparer.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
            &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
            &gt;&gt;&gt; v1.is_perpendicular_to(v2)
            False
            &gt;&gt;&gt; v1.is_perpendicular_to(v1.right_perpendicular)
            True
        &#34;&#34;&#34;         
        return isclose(self.dot(other), 0.0)
    
    def is_parallel_to(self, other : &#39;Vect2D&#39;) -&gt; bool:
        &#34;&#34;&#34;Retourne &#39;True&#39; si ce vecteur est perpendiculaire à celui 
        passé en argument. Sinon retourne &#39;False&#39;.
        
        Args:
            other (Vect2D): L&#39;autre vecteur à comparer.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
            &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
            &gt;&gt;&gt; v1.is_parallel_to(v2)
            False
            &gt;&gt;&gt; v1.is_parallel_to(v1.right_perpendicular.right_perpendicular)
            True
        &#34;&#34;&#34;
        return isclose(self.cross(other), 0.0)
        #return self.is_perpendicular_to(other.right_perpendicular)
    
    def is_forming_accute_angle_with(self, other : &#39;Vect2D&#39;) -&gt; bool: # the ~ same direction : acute angle 0 &lt;= theta &lt;= 90
        &#34;&#34;&#34;Retourne &#39;True&#39; si ce vecteur et celui passé en argument forment 
        un angle aigu. Sinon retourne &#39;False&#39;.
        
        Args:
            other (Vect2D): L&#39;autre vecteur à comparer.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D.from_polar_degrees(10.0, 45.0)
            &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(10.0, 75.0)
            &gt;&gt;&gt; v3 = Vect2D.from_polar_degrees(10.0, 185.0)
            &gt;&gt;&gt; v1.is_forming_accute_angle_with(v2)
            True
            &gt;&gt;&gt; v1.is_forming_accute_angle_with(v3)
            False
        &#34;&#34;&#34;
        return self.dot(other) &gt; 0.0
    
    def is_forming_obtuse_angle_with(self, other : &#39;Vect2D&#39;) -&gt; bool: # the ~ opposite direction : obtuse angle 90 &lt;= theta &lt;= 180
        return self.dot(other) &lt; 0.0

    
    
    #-----------------------------------------
    #    ____                _            _   
    #   |  _ \ _ __ ___   __| |_   _  ___| |_ 
    #   | |_) | &#39;__/ _ \ / _` | | | |/ __| __|
    #   |  __/| | | (_) | (_| | |_| | (__| |_ 
    #   |_|   |_|  \___/ \__,_|\__,_|\___|\__|
    #                                         
    #-----------------------------------------
    def dot(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne le produit scalaire de ce vecteur avec celui passé en 
        argument.
        
        Args:
            other (Vect2D): L&#39;autre vecteur.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, -5.0)
            &gt;&gt;&gt; v2 = Vect2D(-3.0, 2.0)
            &gt;&gt;&gt; v1.dot(v2)
            -16.0
        &#34;&#34;&#34;
        return self.x * other.x + self.y * other.y
    
    def cross(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne le produit vectoriel de ce vecteur avec celui passé en 
        argument.
        
        Args:
            other (Vect2D): L&#39;autre vecteur.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, -5.0)
            &gt;&gt;&gt; v2 = Vect2D(-3.0, 2.0)
            &gt;&gt;&gt; v1.cross(v2)
            -11.0
        &#34;&#34;&#34;        
        return self.x * other.y - self.y * other.x
    
    
    
    # def translate(self, ...)
    # def rotate(self, ...)
    # def scale(self, ...)
    # def transform(self, ...)
    
    
    #----------------------------------------------------------------------------------------------------
    #    ____            _           _   _                  __  ____       _           _   _             
    #   |  _ \ _ __ ___ (_) ___  ___| |_(_) ___  _ __      / / |  _ \ ___ (_) ___  ___| |_(_) ___  _ __  
    #   | |_) | &#39;__/ _ \| |/ _ \/ __| __| |/ _ \| &#39;_ \    / /  | |_) / _ \| |/ _ \/ __| __| |/ _ \| &#39;_ \ 
    #   |  __/| | | (_) | |  __/ (__| |_| | (_) | | | |  / /   |  _ &lt;  __/| |  __/ (__| |_| | (_) | | | |
    #   |_|   |_|  \___// |\___|\___|\__|_|\___/|_| |_| /_/    |_| \_\___|/ |\___|\___|\__|_|\___/|_| |_|
    #                 |__/                                              |__/                                 
    #----------------------------------------------------------------------------------------------------
    def angle_between(self, other : &#39;Vect2D&#39;) -&gt; float: # in radians
        &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument.
        
        L&#39;angle est en radians.
        
        Args:
            other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
        
        Exemples:
            &gt;&gt;&gt; from math import isclose, pi, degrees
            &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
            &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
            &gt;&gt;&gt; isclose(v1.angle_between(v2), pi / 8.0)
            True
            &gt;&gt;&gt; round(degrees(v1.angle_between(v2)), 1)
            22.5
        &#34;&#34;&#34;
        return acos(self.dot(other) / sqrt(self.length_squared * other.length_squared))

    def angle_between_degrees(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument.
        
        L&#39;angle est en degrées.
        
        Args:
            other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
        
        Exemples:
            &gt;&gt;&gt; from math import isclose, pi, degrees
            &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
            &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
            &gt;&gt;&gt; isclose(v1.angle_between_degrees(v2), 22.5)
            True
            &gt;&gt;&gt; round(v1.angle_between_degrees(v2),1)
            22.5
        &#34;&#34;&#34;
        return degrees(self.angle_between(other))
    
    def angle_disparity(self, other : &#39;Vect2D&#39;) -&gt; float: # angle in radians with direction
        &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument. 
        La direction de l&#39;angle est donné contrairement à la fonction 
        angle_between :
         - si l&#39;angle est négatif, l&#39;autre vecteur se trouve dans le sens 
           inverse de rotation
         - si l&#39;angle est positif, l&#39;autre vecteur se trouve dans le sens 
           de rotation
        
        L&#39;angle est en radians.
        
        Args:
            other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
        
        Exemples:
            &gt;&gt;&gt; from math import isclose, pi, degrees
            &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
            &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
            &gt;&gt;&gt; isclose(v1.angle_disparity(v2), pi / 8.0)
            True
            &gt;&gt;&gt; round(degrees(v1.angle_disparity(v2)), 1)
            22.5
            &gt;&gt;&gt; round(degrees(v2.angle_disparity(v1)), 1)
            -22.5
        &#34;&#34;&#34;
        return atan2(self.cross(other), self.x * other.x + self.y * other.y)
    
    def angle_disparity_degrees(self, other : &#39;Vect2D&#39;) -&gt; float: # angle in radians with direction
        &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument. 
        La direction de l&#39;angle est donné contrairement à la fonction 
        angle_between :
         - si l&#39;angle est négatif, l&#39;autre vecteur se trouve dans le sens 
           inverse de la rotation
         - si l&#39;angle est positif, l&#39;autre vecteur se trouve dans le sens 
           de la rotation
        
        L&#39;angle est en degrées.
        
        Args:
            other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
        
        Exemples:
            &gt;&gt;&gt; from math import isclose
            &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
            &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
            &gt;&gt;&gt; isclose(v1.angle_disparity_degrees(v2), 22.5)
            True
            &gt;&gt;&gt; round(v1.angle_disparity_degrees(v2), 1)
            22.5
            &gt;&gt;&gt; round(v2.angle_disparity_degrees(v1), 1)
            -22.5
        &#34;&#34;&#34;
        return degrees(self.angle_disparity(other))
    
    
    
    def scalar_projection(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne la projection scalaire de ce vecteur sur le vecteur passé 
        en argument.
        
        Args:
            other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
            courant.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; v1.scalar_projection(v2)
            3.0
        &#34;&#34;&#34;
        return self.dot(other) / other.length

    def vector_projection(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Retourne la projection vectorielle de ce vecteur sur le vecteur passé 
        en argument.
        
        Args:
            other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
            courant.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; print(v1.vector_projection(v2))
            (3.00E+00, 0.00E+00)
        &#34;&#34;&#34;        
        return self.dot(other) / other.dot(other) * other
    
    def scalar_rejection(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne la réjection scalaire de ce vecteur sur le vecteur passé 
        en argument.
        
        Args:
            other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
            courant.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; v1.scalar_rejection(v2)
            1.0
        &#34;&#34;&#34;
        return (self.y * other.x - self.x * other.y) / other.length
    
    def vector_rejection(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Retourne la réjection vectorielle de ce vecteur sur le vecteur passé 
        en argument.
        
        Args:
            other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
            courant.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; print(v1.vector_rejection(v2))
            (0.00E+00, 1.00E+00)
        &#34;&#34;&#34;     
        return self - self.vector_projection(other)
    
    def projection_analysis(self, other : &#39;Vect2D&#39;) -&gt; tuple[float, &#39;Vect2D&#39;, float, &#39;Vect2D&#39;]:
        &#34;&#34;&#34;Retourne l&#39;analyse complète de la projection de ce vecteur sur le vecteur passé 
        en argument.
        
        Args:
            other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
            courant.

        Returns:
            un tuple contenant :
             - la projection scalaire
             - la projection vectorielle
             - la réjection scalaire
             - la réjection vectorielle
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; analysis = v1.projection_analysis(v2)
            &gt;&gt;&gt; print(f&#39;Projection : {analysis[0]} | {analysis[1]}&#39;)
            Projection : 3.0 | (3.00E+00, 0.00E+00)
            &gt;&gt;&gt; print(f&#39;Réjection : {analysis[2]} | {analysis[3]}&#39;)
            Réjection : 1.0 | (0.00E+00, 1.00E+00)
        &#34;&#34;&#34;             
        scalar_proj = self.scalar_projection(other)
        vector_proj = scalar_proj * other.normalized
        scalar_rej = self.scalar_rejection(other)
        vector_rej = self - vector_proj
        
        return (scalar_proj, vector_proj, scalar_rej, vector_rej)



    #---------------------------------------------------------------------------------------------------------
    #     ___                       _                                       _                 _ _             
    #    / _ \ _ __   ___ _ __ __ _| |_ ___  _ __ ___    _____   _____ _ __| | ___   __ _  __| (_)_ __   __ _ 
    #   | | | | &#39;_ \ / _ \ &#39;__/ _` | __/ _ \| &#39;__/ __|  / _ \ \ / / _ \ &#39;__| |/ _ \ / _` |/ _` | | &#39;_ \ / _` |
    #   | |_| | |_) |  __/ | | (_| | || (_) | |  \__ \ | (_) \ V /  __/ |  | | (_) | (_| | (_| | | | | | (_| |
    #    \___/| .__/ \___|_|  \__,_|\__\___/|_|  |___/  \___/ \_/ \___|_|  |_|\___/ \__,_|\__,_|_|_| |_|\__, |
    #         |_|                                                                                       |___/ 
    #---------------------------------------------------------------------------------------------------------
    
    def __eq__(self, other : &#39;Vect2D&#39;) -&gt; bool: # self == other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v2 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v3 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 == v2
        False
        &gt;&gt;&gt; v2 == v3
        True
        &#34;&#34;&#34;
        return isclose(self.x, other.x) and isclose(self.y, other.y)
    
    def __ne__(self, other : &#39;Vect2D&#39;) -&gt; bool: # self != other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v2 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v3 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 != v2
        True
        &gt;&gt;&gt; v2 != v3
        False
        &#34;&#34;&#34;
        return not (isclose(self.x, other.x) and isclose(self.y, other.y))
        
    def __neg__(self) -&gt; &#39;Vect2D&#39;: # -self
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; print(-v1)
        (-1.00E+00, 1.50E+00)
        &#34;&#34;&#34;
        return Vect2D(-self.x, -self.y)
        
    def __add__(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;: # self + other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v2 = Vect2D(-2.0, 1.0)
        &gt;&gt;&gt; print(v1 + v2)
        (-1.00E+00, -5.00E-01)
        &#34;&#34;&#34;
        return Vect2D(self.x + other.x, self.y + other.y)

    def __iadd__(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;: # self += other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 += Vect2D(-2.0, 1.0)
        &gt;&gt;&gt; print(v1)
        (-1.00E+00, -5.00E-01)
        &#34;&#34;&#34;
        self.x += other.x
        self.y += other.y
        return self

    def __sub__(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;: # self - other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v2 = Vect2D(-2.0, 1.0)
        &gt;&gt;&gt; print(v1 - v2)
        (3.00E+00, -2.50E+00)
        &#34;&#34;&#34;
        return Vect2D(self.x - other.x, self.y - other.y)

    def __isub__(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;: # self -= other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 -= Vect2D(-2.0, 1.0)
        &gt;&gt;&gt; print(v1)
        (3.00E+00, -2.50E+00)
        &#34;&#34;&#34;
        self.x -= other.x
        self.y -= other.y
        return self

    def __mul__(self, other : float) -&gt; &#39;Vect2D&#39;: # self * other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; print(v1 * 5.0)
        (5.00E+00, -7.50E+00)
        &#34;&#34;&#34;
        return Vect2D(self.x * other, self.y * other)

    def __rmul__(self, other : float) -&gt; &#39;Vect2D&#39;: # other * self
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; print(5.0 * v1)
        (5.00E+00, -7.50E+00)
        &#34;&#34;&#34;
        return Vect2D(self.x * other, self.y * other)

    def __imul__(self, other : float) -&gt; &#39;Vect2D&#39;: # self *= other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 *= 5.0
        &gt;&gt;&gt; print(v1)
        (5.00E+00, -7.50E+00)
        &#34;&#34;&#34;
        self.x *= other
        self.y *= other
        return self

    def __truediv__(self, other : float) -&gt; &#39;Vect2D&#39;: # self / other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; print(v1 / 2.0)
        (5.00E-01, -7.50E-01)
        &#34;&#34;&#34;
        return Vect2D(self.x / other, self.y / other)

    def __rtruediv__(self, other: float) -&gt; &#39;Vect2D&#39;: # other / self
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; print(2.0 / v1)
        (2.00E+00, -1.33E+00)
        &#34;&#34;&#34;
        return Vect2D(other / self.x, other / self.y)

    def __itruediv__(self, other : float) -&gt; &#39;Vect2D&#39;: # self /= other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 /= 2.0
        &gt;&gt;&gt; print(v1)
        (5.00E-01, -7.50E-01)
        &#34;&#34;&#34;
        self.x /= other
        self.y /= other
        return self
    
    
    
    #--------------------------------------------------------------------------------------------------------    
    #    _____                 _   _                                       _                 _ _             
    #   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___    _____   _____ _ __| | ___   __ _  __| (_)_ __   __ _ 
    #   | |_ | | | | &#39;_ \ / __| __| |/ _ \| &#39;_ \/ __|  / _ \ \ / / _ \ &#39;__| |/ _ \ / _` |/ _` | | &#39;_ \ / _` |
    #   |  _|| |_| | | | | (__| |_| | (_) | | | \__ \ | (_) \ V /  __/ |  | | (_) | (_| | (_| | | | | | (_| |
    #   |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/  \___/ \_/ \___|_|  |_|\___/ \__,_|\__,_|_|_| |_|\__, |
    #                                                                                                  |___/ 
    #--------------------------------------------------------------------------------------------------------    
    
    def __abs__(self) -&gt; &#39;Vect2D&#39;: # abs(self)
        &#34;&#34;&#34;Retourne les valeurs absolues de `x` et `y`.
        
        Retourne une nouvelle instance de `Vect2D` tout en ne modifiant pas 
        l&#39;instance courante. Les valeur `x` et `y` restent des `float` même 
        si elles sont arrondies.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.25, -1.75)
            &gt;&gt;&gt; v2 = abs(v1)
            &gt;&gt;&gt; print(v2)
            (2.25E+00, 1.75E+00)
        &#34;&#34;&#34;             
        return Vect2D(abs(self.x), abs(self.y))
    
    def __round__(self, ndigits=None) -&gt; &#39;Vect2D&#39;: # round(self)
        &#34;&#34;&#34;Arrondi les composantes x et y du vecteur vers l&#39;entier le plus près.
        
        Retourne une nouvelle instance de `Vect2D` tout en ne modifiant pas 
        l&#39;instance courante. Les valeur `x` et `y` restent des `float` même 
        si elles sont arrondies.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.25, -1.75)
            &gt;&gt;&gt; v2 = round(v1)
            &gt;&gt;&gt; print(v2)
            (2.00E+00, -2.00E+00)
        &#34;&#34;&#34;             
        return Vect2D(round(self.x, ndigits), round(self.y, ndigits))
    
    def __trunc__(self) -&gt; &#39;Vect2D&#39;: # trunc(self)
        &#34;&#34;&#34;Arrondi les composantes x et y du vecteur vers zéro.
        
        Retourne une nouvelle instance de `Vect2D` tout en ne modifiant pas 
        l&#39;instance courante. Les valeur `x` et `y` restent des `float` même 
        si elles sont arrondies.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.25, -1.75)
            &gt;&gt;&gt; v2 = trunc(v1)
            &gt;&gt;&gt; print(v2)
            (2.00E+00, -1.00E+00)
        &#34;&#34;&#34;             
        return Vect2D(trunc(self.x), trunc(self.y))
    
    def __floor__(self) -&gt; &#39;Vect2D&#39;: # floor(self)
        &#34;&#34;&#34;Arrondi les composantes x et y du vecteur vers l&#39;infini négatif.
        
        Retourne une nouvelle instance de `Vect2D` tout en ne modifiant pas 
        l&#39;instance courante. Les valeur `x` et `y` restent des `float` même 
        si elles sont arrondies.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.25, -1.75)
            &gt;&gt;&gt; v2 = floor(v1)
            &gt;&gt;&gt; print(v2)
            (2.00E+00, -2.00E+00)
        &#34;&#34;&#34;                
        return Vect2D(floor(self.x), floor(self.y))
    
    def __ceil__(self) -&gt; &#39;Vect2D&#39;: # ceil(self)
        &#34;&#34;&#34;Arrondi les composantes x et y du vecteur vers l&#39;infini positif.
        
        Retourne une nouvelle instance de `Vect2D` tout en ne modifiant pas 
        l&#39;instance courante. Les valeur `x` et `y` restent des `float` même 
        si elles sont arrondies.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.25, -1.75)
            &gt;&gt;&gt; v2 = ceil(v1)
            &gt;&gt;&gt; print(v2)
            (3.00E+00, -1.00E+00)
        &#34;&#34;&#34;        
        return Vect2D(ceil(self.x), ceil(self.y))


    def __complex__(self) -&gt; &#39;Vect2D&#39;: # complex(self)
        &#34;&#34;&#34;Crée un nombre complexe représentant le vecteur.
        
        Ne modifie pas l&#39;instance courante.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
            &gt;&gt;&gt; comp = complex(v1)
            &gt;&gt;&gt; print(comp)
            (2.5-1.5j)
        &#34;&#34;&#34;        
        return complex(self.x, self.y)
    
    
    @classmethod
    def from_data(cls, data : tuple[float, float] | list[float, float] | dict[str, float]) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Crée une nouvelle instance de `Vect2D` à partir d&#39;une structure existante :
        - tuple ou liste de 2 float : 
            - seulement 2 données
            - représentant le x et le y
            - (0.0, 0.0)
            - [0.0, 0.0]
        - dict de 2 float : 
            - les clés doivent des str &#39;x&#39; ou &#39;y&#39; 
            - toutes minuscules ou majuscules
            - { &#39;x&#39;:0.0, &#39;y&#39;:0.0 }
            - { &#39;X&#39;:0.0, &#39;Y&#39;:0.0 }
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D.from_data((1.0, 2.5))
            &gt;&gt;&gt; print(v1)
            (1.00E+00, 2.50E+00)
            &gt;&gt;&gt; v2 = Vect2D.from_data([1.0, 2.5])
            &gt;&gt;&gt; print(v2)
            (1.00E+00, 2.50E+00)
            &gt;&gt;&gt; v3 = Vect2D.from_data({&#39;x&#39;:1.0, &#39;y&#39;:2.5})
            &gt;&gt;&gt; print(v3)
            (1.00E+00, 2.50E+00)
            &gt;&gt;&gt; v4 = Vect2D.from_data({&#39;X&#39;:1.0, &#39;Y&#39;:2.5})
            &gt;&gt;&gt; print(v4)
            (1.00E+00, 2.50E+00)
        &#34;&#34;&#34;               
        if isinstance(data, tuple) and len(data) == 2:
            return Vect2D(data[0], data[1])
        if isinstance(data, list) and len(data) == 2:
            return Vect2D(data[0], data[1])
        if isinstance(data, dict):
            k = set(data.keys()) 
            if k == {&#39;x&#39;, &#39;y&#39;}:
                return Vect2D(data[&#39;x&#39;], data[&#39;y&#39;])
            elif k == {&#39;X&#39;, &#39;Y&#39;}:
                return Vect2D(data[&#39;X&#39;], data[&#39;Y&#39;])
        else:
            raise TypeError(&#34;data is not compatible - must be a tuple/list of 2 float or a dict with &#39;x&#39; or &#39;y&#39;&#34;)
    
    @property
    def as_tuple(self) -&gt; tuple[float, float]:
        &#34;&#34;&#34;Crée et retourne un tuple de deux réels. La liste créée possède 
        les abscisses et les ordonnées dans l&#39;ordre.
        
        Ne modifie pas l&#39;instance courante.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
            &gt;&gt;&gt; print(v1.as_tuple)
            (2.5, -1.5)
        &#34;&#34;&#34;     
        return (self.x, self.y)

    @property
    def as_list(self) -&gt; list[float, float]:
        &#34;&#34;&#34;Crée et retourne une liste de deux réels. La liste créée possède 
        les abscisses et les ordonnées dans l&#39;ordre.
        
        Ne modifie pas l&#39;instance courante.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
            &gt;&gt;&gt; print(v1.as_list)
            [2.5, -1.5]
        &#34;&#34;&#34;     
        return [self.x, self.y]

    @property
    def as_dict(self) -&gt; dict[str, int]:
        &#34;&#34;&#34;Crée et retourne un dictionnaire de deux réels. Le dictionnaire 
        possède les clés suivantes :
        - &#39;x&#39; : les abscisses 
        - &#39;y&#39; : les ordonnées
        
        Ne modifie pas l&#39;instance courante.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
            &gt;&gt;&gt; print(v1.as_dict)
            {&#39;x&#39;: 2.5, &#39;y&#39;: -1.5}
        &#34;&#34;&#34;             
        return { &#39;x&#39;:self.x, &#39;y&#39;:self.y }



Vect2D.UNDEFINED = Vect2D()
&#34;&#34;&#34;Représente un vecteur indéfini. C&#39;est à dire le vecteur (0.0, 0.0).&#34;&#34;&#34;



def __main_doctest():
    if bool(__debug__): # do not work
        import doctest
        doctest.testmod()#verbose=True)
def __main_doctest():
    import doctest
    doctest.testmod()#verbose=True)

if __name__ == &#34;__main__&#34;:
    __main_doctest()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vect2d.Vect2D"><code class="flex name class">
<span>class <span class="ident">Vect2D</span></span>
<span>(</span><span>x: int | float = 0.0, y: int | float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>La classe Vect2D encapsule les notions d'un vecteur mathématique.</p>
<p>Le vecteur est exprimé selon :</p>
<ul>
<li>un espace à deux dimensions</li>
<li>un système de coordonnées cartésiennes</li>
<li>deux nombres réels (float) :<ul>
<li>x, les abscisses</li>
<li>y, les ordonnées</li>
</ul>
</li>
</ul>
<p>Plusieurs fonctionnalités sont disponibles :</p>
<ul>
<li>propriétés et caractéristiques</li>
<li>représentation cartésienne et polaire</li>
<li>surcharge des opérateurs</li>
<li>vecteur unitaire</li>
<li>comparaison entre 2 vecteurs : angle, distance, perpendicularité, &hellip;</li>
<li>produits, projections et réjections<ul>
<li>scalaire</li>
<li>vectoriel</li>
</ul>
</li>
<li>plusieurs fonctions utilitaires :<ul>
<li>assignations diverses et réinitialisation</li>
<li>arrondissements</li>
<li>valeur absolue</li>
<li>distances</li>
</ul>
</li>
<li>génération aléatoire</li>
</ul>
<p>Il existe plusieurs façons de <strong>créer</strong> un <code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code> :</p>
<ul>
<li><code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></li>
<li><code><a title="vect2d.Vect2D.from_vect2d" href="#vect2d.Vect2D.from_vect2d">Vect2D.from_vect2d()</a></code></li>
<li><code><a title="vect2d.Vect2D.from_polar" href="#vect2d.Vect2D.from_polar">Vect2D.from_polar()</a></code></li>
<li><code><a title="vect2d.Vect2D.from_polar_degrees" href="#vect2d.Vect2D.from_polar_degrees">Vect2D.from_polar_degrees()</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_normalized" href="#vect2d.Vect2D.from_random_normalized">Vect2D.from_random_normalized()</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_cartesian" href="#vect2d.Vect2D.from_random_cartesian">Vect2D.from_random_cartesian()</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_polar" href="#vect2d.Vect2D.from_random_polar">Vect2D.from_random_polar()</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_polar_degrees" href="#vect2d.Vect2D.from_random_polar_degrees">Vect2D.from_random_polar_degrees()</a></code></li>
<li><code><a title="vect2d.Vect2D.from_data" href="#vect2d.Vect2D.from_data">Vect2D.from_data()</a></code></li>
</ul>
<p>Les <strong>propriétés</strong> (accesseurs et mutateurs) sont :</p>
<ul>
<li><code><a title="vect2d.Vect2D.is_defined" href="#vect2d.Vect2D.is_defined">Vect2D.is_defined</a></code> [lecture] : retourne vrai si le vecteur est défini</li>
<li><code><a title="vect2d.Vect2D.is_normalized" href="#vect2d.Vect2D.is_normalized">Vect2D.is_normalized</a></code> [lecture] : retourne vrai si le vecteur est de longueur 1</li>
<li><code><a title="vect2d.Vect2D.x" href="#vect2d.Vect2D.x">Vect2D.x</a></code> [lecture/écriture] : l'abscisse de la coordonnée cartésienne</li>
<li><code><a title="vect2d.Vect2D.y" href="#vect2d.Vect2D.y">Vect2D.y</a></code> [lecture/écriture] : l'ordonnée de la coordonnée cartésienne</li>
<li><code><a title="vect2d.Vect2D.length" href="#vect2d.Vect2D.length">Vect2D.length</a></code> [lecture/écriture] : la longueur de la coordonnée polaire</li>
<li><code><a title="vect2d.Vect2D.length_squared" href="#vect2d.Vect2D.length_squared">Vect2D.length_squared</a></code> [lecture/écriture] : la longueur au carré de la coordonnée polaire</li>
<li><code><a title="vect2d.Vect2D.orientation" href="#vect2d.Vect2D.orientation">Vect2D.orientation</a></code> [lecture/écriture] : l'orientation de la coordonnée polaire en radians</li>
<li><code><a title="vect2d.Vect2D.orientation_degrees" href="#vect2d.Vect2D.orientation_degrees">Vect2D.orientation_degrees</a></code> [lecture/écriture] : l'orientation de la coordonnée polaire en degrées</li>
<li><code><a title="vect2d.Vect2D.normalized" href="#vect2d.Vect2D.normalized">Vect2D.normalized</a></code> [lecture] : retourne vrai si le vecteur est unitaire</li>
<li><code><a title="vect2d.Vect2D.right_perpendicular" href="#vect2d.Vect2D.right_perpendicular">Vect2D.right_perpendicular</a></code> [lecture] : retourne le vecteur perpendiculaire de droite</li>
<li><code><a title="vect2d.Vect2D.left_perpendicular" href="#vect2d.Vect2D.left_perpendicular">Vect2D.left_perpendicular</a></code> [lecture] : retourne le vecteur perpendiculaire de gauche</li>
<li><code><a title="vect2d.Vect2D.flipped" href="#vect2d.Vect2D.flipped">Vect2D.flipped</a></code> [lecture] : retourne le vecteur permuté</li>
<li><code><a title="vect2d.Vect2D.manhattan_length" href="#vect2d.Vect2D.manhattan_length">Vect2D.manhattan_length</a></code> [lecture] : retourne la distance de Mannhatan</li>
<li><code><a title="vect2d.Vect2D.chebyshev_length" href="#vect2d.Vect2D.chebyshev_length">Vect2D.chebyshev_length</a></code> [lecture] : retourne la distance de Chebyshev</li>
<li><code><a title="vect2d.Vect2D.as_tuple" href="#vect2d.Vect2D.as_tuple">Vect2D.as_tuple</a></code> [lecture] : retourne un tuple de deux réels </li>
<li><code><a title="vect2d.Vect2D.as_list" href="#vect2d.Vect2D.as_list">Vect2D.as_list</a></code> [lecture] : retourne une liste de deux réels </li>
<li><code><a title="vect2d.Vect2D.as_dict" href="#vect2d.Vect2D.as_dict">Vect2D.as_dict</a></code> [lecture] : retourne un dictionnaire de deux réels avec 'x' et 'y' comme clés </li>
</ul>
<p>Pour le système de coordonnées <strong>cartésiennes</strong> :</p>
<ul>
<li><code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></li>
<li><code><a title="vect2d.Vect2D.x" href="#vect2d.Vect2D.x">Vect2D.x</a></code></li>
<li><code><a title="vect2d.Vect2D.y" href="#vect2d.Vect2D.y">Vect2D.y</a></code></li>
<li><code><a title="vect2d.Vect2D.clamp_x" href="#vect2d.Vect2D.clamp_x">Vect2D.clamp_x()</a></code></li>
<li><code><a title="vect2d.Vect2D.clamp_y" href="#vect2d.Vect2D.clamp_y">Vect2D.clamp_y()</a></code></li>
</ul>
<p>Pour le système de coordonnées <strong>polaires</strong> :</p>
<ul>
<li><code><a title="vect2d.Vect2D.from_polar" href="#vect2d.Vect2D.from_polar">Vect2D.from_polar()</a></code></li>
<li><code><a title="vect2d.Vect2D.set_polar" href="#vect2d.Vect2D.set_polar">Vect2D.set_polar()</a></code></li>
<li><code><a title="vect2d.Vect2D.length_squared" href="#vect2d.Vect2D.length_squared">Vect2D.length_squared</a></code></li>
<li><code><a title="vect2d.Vect2D.length" href="#vect2d.Vect2D.length">Vect2D.length</a></code></li>
<li><code><a title="vect2d.Vect2D.orientation" href="#vect2d.Vect2D.orientation">Vect2D.orientation</a></code></li>
<li><code><a title="vect2d.Vect2D.limit_length_squared" href="#vect2d.Vect2D.limit_length_squared">Vect2D.limit_length_squared()</a></code></li>
<li><code><a title="vect2d.Vect2D.limit_length" href="#vect2d.Vect2D.limit_length">Vect2D.limit_length()</a></code></li>
</ul>
<p>Pour la <strong>normalisation</strong> (unitaire) :</p>
<ul>
<li><code><a title="vect2d.Vect2D.is_normalized" href="#vect2d.Vect2D.is_normalized">Vect2D.is_normalized</a></code></li>
<li><code><a title="vect2d.Vect2D.normalize" href="#vect2d.Vect2D.normalize">Vect2D.normalize()</a></code></li>
<li><code><a title="vect2d.Vect2D.normalized" href="#vect2d.Vect2D.normalized">Vect2D.normalized</a></code></li>
</ul>
<p>Pour la <strong>génération aléatoire</strong> :</p>
<ul>
<li><code><a title="vect2d.Vect2D.randomize_normalized" href="#vect2d.Vect2D.randomize_normalized">Vect2D.randomize_normalized()</a></code></li>
<li><code><a title="vect2d.Vect2D.randomize_cartesian" href="#vect2d.Vect2D.randomize_cartesian">Vect2D.randomize_cartesian()</a></code></li>
<li><code><a title="vect2d.Vect2D.randomize_polar" href="#vect2d.Vect2D.randomize_polar">Vect2D.randomize_polar()</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_normalized" href="#vect2d.Vect2D.from_random_normalized">Vect2D.from_random_normalized()</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_cartesian" href="#vect2d.Vect2D.from_random_cartesian">Vect2D.from_random_cartesian()</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_polar" href="#vect2d.Vect2D.from_random_polar">Vect2D.from_random_polar()</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_polar_degrees" href="#vect2d.Vect2D.from_random_polar_degrees">Vect2D.from_random_polar_degrees()</a></code></li>
</ul>
<p><strong>Comparaison</strong> de deux vecteurs :</p>
<ul>
<li><code><a title="vect2d.Vect2D.distance_squared_from" href="#vect2d.Vect2D.distance_squared_from">Vect2D.distance_squared_from()</a></code></li>
<li><code><a title="vect2d.Vect2D.distance_from" href="#vect2d.Vect2D.distance_from">Vect2D.distance_from()</a></code></li>
<li><code><a title="vect2d.Vect2D.is_perpendicular_to" href="#vect2d.Vect2D.is_perpendicular_to">Vect2D.is_perpendicular_to()</a></code></li>
<li><code><a title="vect2d.Vect2D.is_parallel_to" href="#vect2d.Vect2D.is_parallel_to">Vect2D.is_parallel_to()</a></code></li>
<li><code><a title="vect2d.Vect2D.angle_between" href="#vect2d.Vect2D.angle_between">Vect2D.angle_between()</a></code></li>
<li><code><a title="vect2d.Vect2D.angle_disparity" href="#vect2d.Vect2D.angle_disparity">Vect2D.angle_disparity()</a></code></li>
<li><code><a title="vect2d.Vect2D.is_forming_accute_angle_with" href="#vect2d.Vect2D.is_forming_accute_angle_with">Vect2D.is_forming_accute_angle_with()</a></code></li>
<li><code><a title="vect2d.Vect2D.is_forming_obtuse_angle_with" href="#vect2d.Vect2D.is_forming_obtuse_angle_with">Vect2D.is_forming_obtuse_angle_with()</a></code></li>
</ul>
<p><strong>Produits</strong> et <strong>projection</strong> entre 2 vecteurs :</p>
<ul>
<li><code><a title="vect2d.Vect2D.dot" href="#vect2d.Vect2D.dot">Vect2D.dot()</a></code></li>
<li><code><a title="vect2d.Vect2D.cross" href="#vect2d.Vect2D.cross">Vect2D.cross()</a></code></li>
<li><code><a title="vect2d.Vect2D.scalar_projection" href="#vect2d.Vect2D.scalar_projection">Vect2D.scalar_projection()</a></code></li>
<li><code><a title="vect2d.Vect2D.vector_projection" href="#vect2d.Vect2D.vector_projection">Vect2D.vector_projection()</a></code></li>
<li><code><a title="vect2d.Vect2D.scalar_rejection" href="#vect2d.Vect2D.scalar_rejection">Vect2D.scalar_rejection()</a></code></li>
<li><code><a title="vect2d.Vect2D.vector_rejection" href="#vect2d.Vect2D.vector_rejection">Vect2D.vector_rejection()</a></code></li>
<li><code><a title="vect2d.Vect2D.projection_analysis" href="#vect2d.Vect2D.projection_analysis">Vect2D.projection_analysis()</a></code></li>
</ul>
<p><strong>Surcharge</strong> des <strong>opérateurs</strong> et <strong>fonctions</strong> standards de <code>Python</code> (<code>v</code> pour vecteur et <code>s</code> pour scalaire) :</p>
<ul>
<li>Comparaison entre 2 vecteurs : <ul>
<li><code>v1 == v2</code></li>
<li><code>v1 != v2</code></li>
<li>ne modifie pas les vecteurs</li>
<li>retourne un <code>bool</code></li>
</ul>
</li>
<li>Inverse d'un vecteur :<ul>
<li><code>-v</code></li>
<li>ne modifie pas le vecteur</li>
<li>retourne une nouvelle instance de <code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></li>
</ul>
</li>
<li>Addition ou soustraction de 2 vecteurs :<ul>
<li><code>v1 + v2</code></li>
<li><code>v1 - v2</code></li>
<li>ne modifie pas les vecteurs</li>
<li>retourne une nouvelle instance de <code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></li>
</ul>
</li>
<li>Addition ou soustraction avec assignation de 2 vecteurs :<ul>
<li><code>v1 += v2</code></li>
<li><code>v1 -= v2</code></li>
<li>modifie l'instance de gauche sans modifier l'instance de droite</li>
<li>retourne l'instance de gauche</li>
</ul>
</li>
<li>Multiplicationt ou division entre 1 vecteur et 1 scalaire :<ul>
<li><code>v * s</code></li>
<li><code>s * v</code></li>
<li><code>v / s</code></li>
<li><code>s / v</code></li>
<li>ne modifie pas le vecteur ou le scalaire</li>
<li>retourne une nouvelle instance de <code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></li>
</ul>
</li>
<li>Multiplicationt ou division avec assignation entre 1 vecteur et 1 scalaire :<ul>
<li><code>v *= s</code></li>
<li><code>v /= s</code></li>
<li>modifie l'instance de gauche (le vecteur) sans modifier l'instance de droite (le scalaire)</li>
<li>retourne l'instance de gauche (le vecteur)</li>
</ul>
</li>
<li>Fonctions d'arrondissement<ul>
<li>toutes ces fonction :<ul>
<li>ne modifie pas l'instance passée</li>
<li>retourne une nouvelle instance de <code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></li>
<li>les valeur <code>x</code> et <code>y</code> restent des <code>float</code> même si elles sont arrondies</li>
</ul>
</li>
<li><code>round(v)</code><ul>
<li>affectue l'arrondissement de <code>x</code> et de <code>y</code> vers l'entier le plus près</li>
</ul>
</li>
<li><code>trunc(v)</code><ul>
<li>affectue une arrondissement de <code>x</code> et de <code>y</code> vers zéro</li>
</ul>
</li>
<li><code>floor(v)</code><ul>
<li>affectue une arrondissement de <code>x</code> et de <code>y</code> vers l'infini négatif</li>
</ul>
</li>
<li><code>ceil(v)</code><ul>
<li>affectue une arrondissement de <code>x</code> et de <code>y</code> vers l'infini positif</li>
</ul>
</li>
</ul>
</li>
<li>Autres fonctions utilitaires<ul>
<li><code>abs(v)</code><ul>
<li>ne modifie pas l'instance passée</li>
<li>retourne une nouvelle instance de <code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></li>
<li>valeure absolue de <code>x</code> et de <code>y</code></li>
</ul>
</li>
<li><code>complex(v)</code><ul>
<li>ne modifie pas l'instance passée</li>
<li>retourne un nombre complexe représentant le vecteur</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Conversion</strong> vers un type externe et utilitaires :</p>
<ul>
<li>Conversion : <ul>
<li><code>bool(v)</code> :<ul>
<li>retourne un booléen vrai si le vecteur est défini</li>
</ul>
</li>
<li><code>repr(v)</code> :<ul>
<li>retourne une chaîne de caractères technique</li>
</ul>
</li>
<li><code>str(v)</code> :<ul>
<li>retourne une chaîne de caractères descriptive</li>
<li>les fonctions suivantes permettent de paramétriser la conversion<ul>
<li><code><a title="vect2d.Vect2D.set_string_format" href="#vect2d.Vect2D.set_string_format">Vect2D.set_string_format()</a></code></li>
<li><code><a title="vect2d.Vect2D.set_value_format" href="#vect2d.Vect2D.set_value_format">Vect2D.set_value_format()</a></code></li>
</ul>
</li>
</ul>
</li>
<li><code><a title="vect2d.Vect2D.as_tuple" href="#vect2d.Vect2D.as_tuple">Vect2D.as_tuple</a></code> :<ul>
<li>retourne un tuple de deux réels </li>
</ul>
</li>
<li><code><a title="vect2d.Vect2D.as_list" href="#vect2d.Vect2D.as_list">Vect2D.as_list</a></code> :<ul>
<li>retourne une liste de deux réels </li>
</ul>
</li>
<li><code><a title="vect2d.Vect2D.as_dict" href="#vect2d.Vect2D.as_dict">Vect2D.as_dict</a></code> :<ul>
<li>retourne un dictionnaire de deux réels </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Le vecteur est aussi un <strong>itérateur</strong> : </p>
<ul>
<li>l'itérateur pointe vers l'instance originale et reste une <em>vue</em> de ce
vecteur</li>
</ul>
<p>Exemples de l'itérateur :</p>
<pre><code>&gt;&gt;&gt; v1 = Vect2D(1.0, -2.5)
&gt;&gt;&gt; for coord in v1:
...     print(coord)
1.0
-2.5
&gt;&gt;&gt; i = iter(v1)
&gt;&gt;&gt; print(next(i))
1.0
&gt;&gt;&gt; v1.y = 100.0
&gt;&gt;&gt; print(next(i))
100.0
</code></pre>
<p>Création d'un objet <code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code> utilisant le système de coordonnées cartésiennes.</p>
<h2 id="args">Args</h2>
<p>x (int | float): La valeur des abscisse. Defaults = 0.0
y (int | float): La valeur des ordonnées. Defaults = 0.0</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; vect = Vect2D()
&gt;&gt;&gt; print(vect)
(0.00E+00, 0.00E+00)
&gt;&gt;&gt; vect = Vect2D(-1.0, 1.0)
&gt;&gt;&gt; print(vect)
(-1.00E+00, 1.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vect2D:
    &#34;&#34;&#34;La classe Vect2D encapsule les notions d&#39;un vecteur mathématique.
    
    Le vecteur est exprimé selon :
    
    - un espace à deux dimensions
    - un système de coordonnées cartésiennes
    - deux nombres réels (float) :
        - x, les abscisses
        - y, les ordonnées
    
    Plusieurs fonctionnalités sont disponibles :
    
    - propriétés et caractéristiques
    - représentation cartésienne et polaire
    - surcharge des opérateurs
    - vecteur unitaire
    - comparaison entre 2 vecteurs : angle, distance, perpendicularité, ...
    - produits, projections et réjections
        - scalaire
        - vectoriel
    - plusieurs fonctions utilitaires :
        - assignations diverses et réinitialisation
        - arrondissements
        - valeur absolue
        - distances
    - génération aléatoire
     
    Il existe plusieurs façons de **créer** un `Vect2D` :

    - `Vect2D()`
    - `Vect2D.from_vect2d`
    - `Vect2D.from_polar`
    - `Vect2D.from_polar_degrees`
    - `Vect2D.from_random_normalized`
    - `Vect2D.from_random_cartesian`
    - `Vect2D.from_random_polar`
    - `Vect2D.from_random_polar_degrees`
    - `Vect2D.from_data`
     
    Les **propriétés** (accesseurs et mutateurs) sont :
    
    - `Vect2D.is_defined` [lecture] : retourne vrai si le vecteur est défini
    - `Vect2D.is_normalized` [lecture] : retourne vrai si le vecteur est de longueur 1
    - `Vect2D.x` [lecture/écriture] : l&#39;abscisse de la coordonnée cartésienne
    - `Vect2D.y` [lecture/écriture] : l&#39;ordonnée de la coordonnée cartésienne
    - `Vect2D.length` [lecture/écriture] : la longueur de la coordonnée polaire
    - `Vect2D.length_squared` [lecture/écriture] : la longueur au carré de la coordonnée polaire
    - `Vect2D.orientation` [lecture/écriture] : l&#39;orientation de la coordonnée polaire en radians
    - `Vect2D.orientation_degrees` [lecture/écriture] : l&#39;orientation de la coordonnée polaire en degrées
    - `Vect2D.normalized` [lecture] : retourne vrai si le vecteur est unitaire
    - `Vect2D.right_perpendicular` [lecture] : retourne le vecteur perpendiculaire de droite
    - `Vect2D.left_perpendicular` [lecture] : retourne le vecteur perpendiculaire de gauche
    - `Vect2D.flipped` [lecture] : retourne le vecteur permuté
    - `Vect2D.manhattan_length` [lecture] : retourne la distance de Mannhatan
    - `Vect2D.chebyshev_length` [lecture] : retourne la distance de Chebyshev
    - `Vect2D.as_tuple` [lecture] : retourne un tuple de deux réels 
    - `Vect2D.as_list` [lecture] : retourne une liste de deux réels 
    - `Vect2D.as_dict` [lecture] : retourne un dictionnaire de deux réels avec &#39;x&#39; et &#39;y&#39; comme clés 
     
    Pour le système de coordonnées **cartésiennes** :
    
    - `Vect2D`
    - `Vect2D.x`
    - `Vect2D.y`
    - `Vect2D.clamp_x`
    - `Vect2D.clamp_y`
     
    Pour le système de coordonnées **polaires** :
    
    - `Vect2D.from_polar`
    - `Vect2D.set_polar`
    - `Vect2D.length_squared`
    - `Vect2D.length`
    - `Vect2D.orientation`
    - `Vect2D.limit_length_squared`
    - `Vect2D.limit_length`
     
    Pour la **normalisation** (unitaire) :
    
    - `Vect2D.is_normalized`
    - `Vect2D.normalize`
    - `Vect2D.normalized`
     
    Pour la **génération aléatoire** :

    - `Vect2D.randomize_normalized`
    - `Vect2D.randomize_cartesian`
    - `Vect2D.randomize_polar`
    - `Vect2D.from_random_normalized`
    - `Vect2D.from_random_cartesian`
    - `Vect2D.from_random_polar`
    - `Vect2D.from_random_polar_degrees`
    
    **Comparaison** de deux vecteurs :
    
    - `Vect2D.distance_squared_from`
    - `Vect2D.distance_from`
    - `Vect2D.is_perpendicular_to`
    - `Vect2D.is_parallel_to`
    - `Vect2D.angle_between`
    - `Vect2D.angle_disparity`
    - `Vect2D.is_forming_accute_angle_with`
    - `Vect2D.is_forming_obtuse_angle_with`
     
    **Produits** et **projection** entre 2 vecteurs :
    
    - `Vect2D.dot`
    - `Vect2D.cross`
    - `Vect2D.scalar_projection`
    - `Vect2D.vector_projection`
    - `Vect2D.scalar_rejection`
    - `Vect2D.vector_rejection`
    - `Vect2D.projection_analysis`
     
    **Surcharge** des **opérateurs** et **fonctions** standards de `Python` (`v` pour vecteur et `s` pour scalaire) :
    
    - Comparaison entre 2 vecteurs : 
        - `v1 == v2`
        - `v1 != v2`
        - ne modifie pas les vecteurs
        - retourne un `bool`
    - Inverse d&#39;un vecteur :
        - `-v`
        - ne modifie pas le vecteur
        - retourne une nouvelle instance de `Vect2D`
    - Addition ou soustraction de 2 vecteurs :
        - `v1 + v2`
        - `v1 - v2`
        - ne modifie pas les vecteurs
        - retourne une nouvelle instance de `Vect2D`
    - Addition ou soustraction avec assignation de 2 vecteurs :
        - `v1 += v2`
        - `v1 -= v2`
        - modifie l&#39;instance de gauche sans modifier l&#39;instance de droite
        - retourne l&#39;instance de gauche
    - Multiplicationt ou division entre 1 vecteur et 1 scalaire :
        - `v * s`
        - `s * v`
        - `v / s`
        - `s / v`
        - ne modifie pas le vecteur ou le scalaire
        - retourne une nouvelle instance de `Vect2D`
    - Multiplicationt ou division avec assignation entre 1 vecteur et 1 scalaire :
        - `v *= s`
        - `v /= s`
        - modifie l&#39;instance de gauche (le vecteur) sans modifier l&#39;instance de droite (le scalaire)
        - retourne l&#39;instance de gauche (le vecteur)
    - Fonctions d&#39;arrondissement
        - toutes ces fonction :
            - ne modifie pas l&#39;instance passée
            - retourne une nouvelle instance de `Vect2D`
            - les valeur `x` et `y` restent des `float` même si elles sont arrondies
        - `round(v)`
            - affectue l&#39;arrondissement de `x` et de `y` vers l&#39;entier le plus près
        - `trunc(v)`
            - affectue une arrondissement de `x` et de `y` vers zéro
        - `floor(v)`
            - affectue une arrondissement de `x` et de `y` vers l&#39;infini négatif
        - `ceil(v)`
            - affectue une arrondissement de `x` et de `y` vers l&#39;infini positif
    - Autres fonctions utilitaires
        - `abs(v)`
            - ne modifie pas l&#39;instance passée
            - retourne une nouvelle instance de `Vect2D`
            - valeure absolue de `x` et de `y`
        - `complex(v)`
            - ne modifie pas l&#39;instance passée
            - retourne un nombre complexe représentant le vecteur
            
    **Conversion** vers un type externe et utilitaires :
    
    - Conversion : 
        - `bool(v)` :
            - retourne un booléen vrai si le vecteur est défini
        - `repr(v)` :
            - retourne une chaîne de caractères technique
        - `str(v)` :
            - retourne une chaîne de caractères descriptive
            - les fonctions suivantes permettent de paramétriser la conversion
                - `Vect2D.set_string_format`
                - `Vect2D.set_value_format`
        - `Vect2D.as_tuple` :
            - retourne un tuple de deux réels 
        - `Vect2D.as_list` :
            - retourne une liste de deux réels 
        - `Vect2D.as_dict` :
            - retourne un dictionnaire de deux réels 

    Le vecteur est aussi un **itérateur** : 

    - l&#39;itérateur pointe vers l&#39;instance originale et reste une _vue_ de ce 
      vecteur
            
    Exemples de l&#39;itérateur :
    
        &gt;&gt;&gt; v1 = Vect2D(1.0, -2.5)
        &gt;&gt;&gt; for coord in v1:
        ...     print(coord)
        1.0
        -2.5
        &gt;&gt;&gt; i = iter(v1)
        &gt;&gt;&gt; print(next(i))
        1.0
        &gt;&gt;&gt; v1.y = 100.0
        &gt;&gt;&gt; print(next(i))
        100.0
    &#34;&#34;&#34;
    
    
    __slots__ = (&#39;x&#39;, &#39;y&#39;)

    
    def __clamp(min_value : int | float, value : int | float, max_value : int | float) -&gt; int | float:
        return max(min_value, min(value, max_value))
    
    
    #-------------------------------------------    
    #     ____                _   _             
    #    / ___|_ __ ___  __ _| |_(_) ___  _ __  
    #   | |   | &#39;__/ _ \/ _` | __| |/ _ \| &#39;_ \ 
    #   | |___| | |  __/ (_| | |_| | (_) | | | |
    #    \____|_|  \___|\__,_|\__|_|\___/|_| |_|
    #                                           
    #-------------------------------------------    
    def __init__(self, x : int | float = 0., y : int | float = 0.) -&gt; None:
        &#34;&#34;&#34;Création d&#39;un objet `Vect2D` utilisant le système de coordonnées cartésiennes.
        
        Args:
            x (int | float): La valeur des abscisse. Defaults = 0.0
            y (int | float): La valeur des ordonnées. Defaults = 0.0

        Exemples:
            &gt;&gt;&gt; vect = Vect2D()
            &gt;&gt;&gt; print(vect)
            (0.00E+00, 0.00E+00)
            &gt;&gt;&gt; vect = Vect2D(-1.0, 1.0)
            &gt;&gt;&gt; print(vect)
            (-1.00E+00, 1.00E+00)
        &#34;&#34;&#34;
        self.x : float = float(x)
        &#34;&#34;&#34;`Read &amp; Write`
        
        La valeur des abscisses selon le système de coordonnées cartésiennes.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.x = 5.0
            &gt;&gt;&gt; print(v1)
            (5.00E+00, 0.00E+00)
        &#34;&#34;&#34;
        self.y : float = float(y)
        &#34;&#34;&#34;`Read &amp; Write`
        
        La valeur des ordonnées selon le système de coordonnées cartésiennes.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.y = -5.0
            &gt;&gt;&gt; print(v1)
            (0.00E+00, -5.00E+00)
        &#34;&#34;&#34;

    @classmethod
    def from_vect2d(cls, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Création un nouvel objet `Vect2D` identique à un autre.
        
        Args:
            other (Vect2D): Le vecteur à cloner.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(-1.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D.from_vect2d(v1)
            &gt;&gt;&gt; print(v2)
            (-1.00E+00, 1.00E+00)
        &#34;&#34;&#34;
        return cls(other.x, other.y)
    
    
    
    #-----------------------------------------------------------------------------------
    #    ____  _        _                                                 _             
    #   / ___|| |_ _ __(_)_ __   __ _    ___ ___  _ ____   _____ _ __ ___(_) ___  _ __  
    #   \___ \| __| &#39;__| | &#39;_ \ / _` |  / __/ _ \| &#39;_ \ \ / / _ \ &#39;__/ __| |/ _ \| &#39;_ \ 
    #    ___) | |_| |  | | | | | (_| | | (_| (_) | | | \ V /  __/ |  \__ \ | (_) | | | |
    #   |____/ \__|_|  |_|_| |_|\__, |  \___\___/|_| |_|\_/ \___|_|  |___/_|\___/|_| |_|
    #                           |___/                                                   
    #-----------------------------------------------------------------------------------
    
    __string_prefix = &#39;(&#39;
    __string_separator = &#39;, &#39;
    __string_suffix = &#39;)&#39;
    __string_use_scientific_notation = True
    __string_trailing_zeros_length = 2
    __string_value_format = &#39;.2E&#39;
    
    @staticmethod
    def set_string_format(prefix : str = None, separator : str = None, suffix : str = None) -&gt; None:
        &#34;&#34;&#34;Détermine le format du texte lors de la conversion vers une chaîne 
        de caractères : préfixe, séparateur et suffixe.
        
        Args:
            prefix (str): Le text précédant la coordonnées x. Si None, le préfixe reste inchangé. Defaults = None
            separator (str): Le texte entre les coordonnées x et y. Si None, le séparator est laissé inchangé. Defaults = None
            suffix (str): le texte après la coordonnées y. Si None, le suffixe est laissé inchangé. Defaults = None

        Exemples:
            &gt;&gt;&gt; vect = Vect2D(20000.0, 3.141592654)
            &gt;&gt;&gt; print(vect)
            (2.00E+04, 3.14E+00)
            &gt;&gt;&gt; Vect2D.set_string_format(&#39;[[[ &#39;, &#39; : &#39;, &#39; ]]]&#39;)
            &gt;&gt;&gt; print(vect)
            [[[ 2.00E+04 : 3.14E+00 ]]]
            &gt;&gt;&gt; Vect2D.set_string_format(&#39;(&#39;, &#39;, &#39;, &#39;)&#39;)
        &#34;&#34;&#34;
        if prefix: Vect2D.__string_prefix = prefix
        if separator: Vect2D.__string_separator = separator
        if suffix: Vect2D.__string_suffix = suffix

        
    @staticmethod
    def set_value_format(use_scientific_notation : Optional[bool] = None, trailing_zeros_length : Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;Détermine le format des réels lors de la conversoin vers une chaîne 
        de caractères : la représentation des nombres réels x et y.
        
        Args:
            use_scientific_notation (bool): Si True, utilise la notation scientifique. Si False, la notation fixe. Si None, la notation reste inchangée. Defaults = None
            trailing_zeros_length (int): Détermine le nombre de 0 après la virgule. Si None, le &#39;padding&#39; reste inchangé. Defaults = None

        Exemples:
            &gt;&gt;&gt; vect = Vect2D(20000.0, 3.141592654)
            &gt;&gt;&gt; print(vect)
            (2.00E+04, 3.14E+00)
            &gt;&gt;&gt; Vect2D.set_value_format(False, 3)
            &gt;&gt;&gt; print(vect)
            (20000.000, 3.142)
            &gt;&gt;&gt; Vect2D.set_value_format(True, 2)
        &#34;&#34;&#34;
        use_scientific_notation = Vect2D.__string_use_scientific_notation if use_scientific_notation is None else use_scientific_notation
        trailing_zeros_length = Vect2D.__string_trailing_zeros_length if trailing_zeros_length is None else trailing_zeros_length
        Vect2D.__string_value_format = f&#39;.{trailing_zeros_length}{&#34;E&#34; if use_scientific_notation else &#34;f&#34;}&#39;


    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Retourne une chaîne de caractères contenant une représentation 
        technique de du vecteur.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, -2.0)
            &gt;&gt;&gt; print(repr(v1))
            vect2d.Vect2D(x=2.0, y=-2.0)
        &#34;&#34;&#34;
        return f&#39;vect2d.Vect2D(x={self.x}, y={self.y})&#39;


    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Retourne une chaîne de caractères représentant le vecteur.
        
        Cette représentation est paramétrée par les fonctions :
         - set_string_format
         - set_value_format

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, -2.0)
            &gt;&gt;&gt; print(v1)
            (2.00E+00, -2.00E+00)
        &#34;&#34;&#34;
        return f&#39;{Vect2D.__string_prefix}{self.x:{Vect2D.__string_value_format}}{Vect2D.__string_separator}{self.y:{Vect2D.__string_value_format}}{Vect2D.__string_suffix}&#39;

    class __Vect2D_Iter:
        def __init__(self, vect2d : &#39;Vect2D&#39;):
            self.__vect2d = vect2d
            self.__i = 0
            
        def __next__(self):
            if self.__i == 0:
                self.__i += 1
                return self.__vect2d.x
            if self.__i == 1:
                self.__i += 1
                return self.__vect2d.y
            else:
                raise StopIteration
            

    def __iter__(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(2.0, -1.5)
        &gt;&gt;&gt; tu = tuple(v1)
        &gt;&gt;&gt; li = list(v1)
        &gt;&gt;&gt; print(tu)
        (2.0, -1.5)
        &gt;&gt;&gt; print(li)
        [2.0, -1.5]
        &#34;&#34;&#34;
        return Vect2D.__Vect2D_Iter(self)
    

    #--------------------------------------
    #     ____                           _ 
    #    / ___| ___ _ __   ___ _ __ __ _| |
    #   | |  _ / _ \ &#39;_ \ / _ \ &#39;__/ _` | |
    #   | |_| |  __/ | | |  __/ | | (_| | |
    #    \____|\___|_| |_|\___|_|  \__,_|_|
    #                                      
    #--------------------------------------


    def __bool__(self) -&gt; bool:
        &#34;&#34;&#34;Conversion du vecteur vers un booléen en effectuant une validation
        du vecteur. Le vecteur est valide s&#39;il est défini.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; print(&#39;ok&#39; if v1 else &#39;failed&#39;)
            ok
            &gt;&gt;&gt; v1.reset()
            &gt;&gt;&gt; print(&#39;ok&#39; if v1 else &#39;failed&#39;)
            failed
        &#34;&#34;&#34;        
        return self.is_defined
    
    @property
    def is_defined(self) -&gt; bool:     
        &#34;&#34;&#34;`Read only`
        
        Retourne `True` si le vecteur est défini, `False` autrement. Un vecteur 
        indéfini est un vecteur de longueur 0.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; v1.is_defined
            True
            &gt;&gt;&gt; v1.reset()
            &gt;&gt;&gt; v1.is_defined
            False
        &#34;&#34;&#34;
        return not(isclose(self.x, 0.) and isclose(self.y, 0.))

    



    #---------------------------------------------------------------
    #       _            _                                  _       
    #      / \   ___ ___(_) __ _ _ __  _ __ ___   ___ _ __ | |_ ___ 
    #     / _ \ / __/ __| |/ _` | &#39;_ \| &#39;_ ` _ \ / _ \ &#39;_ \| __/ __|
    #    / ___ \\__ \__ \ | (_| | | | | | | | | |  __/ | | | |_\__ \
    #   /_/   \_\___/___/_|\__, |_| |_|_| |_| |_|\___|_| |_|\__|___/
    #                      |___/                                    
    #---------------------------------------------------------------

    def copy(self) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Retourne une copie (deepcopy) du vecteur. 
                
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.14, 2.81)
            &gt;&gt;&gt; v2 = v1.copy()
            &gt;&gt;&gt; print(v2)
            (3.14E+00, 2.81E+00)
        &#34;&#34;&#34;        
        return Vect2D(self.x, self.y)
    
    def copy_from(self, other : &#39;Vect2D&#39;) -&gt; None:
        &#34;&#34;&#34;Copie les coordonnées x et y d&#39;un vecteur source vers celui-ci.
        
        Args:
            other (Vect2D): Le vecteur source.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v2 = Vect2D(-2.0, 1.5)
            &gt;&gt;&gt; v1.copy_from(v2)
            &gt;&gt;&gt; print(v1)
            (-2.00E+00, 1.50E+00)
        &#34;&#34;&#34;
        self.x, self.y = other.x, other.y
    
    def copy_to(self, other : &#39;Vect2D&#39;) -&gt; None:
        &#34;&#34;&#34;Copie les coordonnées courantes x et y vers un autre vecteur.
        
        Args:
            other (Vect2D): Le vecteur cible.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v2 = Vect2D(2.0, -1.5)
            &gt;&gt;&gt; v2.copy_to(v1)
            &gt;&gt;&gt; print(v1)
            (2.00E+00, -1.50E+00)
        &#34;&#34;&#34;
        other.x, other.y = self.x, self.y

    def set(self, x : int | float, y : int | float) -&gt; None:      
        &#34;&#34;&#34;Détermine les valeurs x et y.
        
        Args:
            x (float | int): La coordonnées en x.
            y (float | int): La coordonnées en y.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.set(-2.0, -1.5)
            &gt;&gt;&gt; print(v1)
            (-2.00E+00, -1.50E+00)
        &#34;&#34;&#34;
        self.x, self.y = float(x), float(y)

    def reset(self) -&gt; None:
        &#34;&#34;&#34;Réinitialise le vecteur (0.0, 0.0). Le vecteur est indéfini.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 1.5)
            &gt;&gt;&gt; print(v1)
            (2.00E+00, 1.50E+00)
            &gt;&gt;&gt; v1.reset()
            &gt;&gt;&gt; print(v1)
            (0.00E+00, 0.00E+00)
        &#34;&#34;&#34;        
        self.x, self.y = 0., 0.



    #------------------------------------------------------------------------------------------------------    
    #     ____           _            _                                       _ _             _            
    #    / ___|__ _ _ __| |_ ___  ___(_) __ _ _ __     ___ ___   ___  _ __ __| (_)_ __   __ _| |_ ___  ___ 
    #   | |   / _` | &#39;__| __/ _ \/ __| |/ _` | &#39;_ \   / __/ _ \ / _ \| &#39;__/ _` | | &#39;_ \ / _` | __/ _ \/ __|
    #   | |__| (_| | |  | ||  __/\__ \ | (_| | | | | | (_| (_) | (_) | | | (_| | | | | | (_| | ||  __/\__ \
    #    \____\__,_|_|   \__\___||___/_|\__,_|_| |_|  \___\___/ \___/|_|  \__,_|_|_| |_|\__,_|\__\___||___/
    #                                                                                                      
    #------------------------------------------------------------------------------------------------------    
    def clamp_x(self, x_min : float, x_max : float) -&gt; None:
        &#34;&#34;&#34;Borne l&#39;abscisse entre deux limites.
        
        Args:
            x_min (float): La borne inférieure.
            x_max (float): La borne supérieure.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; v1.clamp_x(2.5, 5.0)
            &gt;&gt;&gt; print(v1)
            (2.50E+00, 0.00E+00)
        &#34;&#34;&#34;             
        self.x = Vect2D.__clamp(x_min, self.x, x_max)

    def clamp_y(self, y_min : float, y_max : float) -&gt; None:
        &#34;&#34;&#34;Borne l&#39;ordonnée entre deux limites.
        
        Args:
            y_min (float): La borne inférieure.
            y_max (float): La borne supérieure.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; v1.clamp_y(5.0, 10.0)
            &gt;&gt;&gt; print(v1)
            (2.00E+00, 5.00E+00)
        &#34;&#34;&#34;             
        self.y = Vect2D.__clamp(y_min, self.y, y_max)
    
    @property
    def manhattan_length(self) -&gt; float:
        &#34;&#34;&#34;`Read only`
        
        Retourne la distance de Manhattan.
        
        Cette distance correspond à la distance orthogonale totale à parcourir 
        considérant chacun des axes : | x | + | y |.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
            &gt;&gt;&gt; v1.manhattan_length
            7.0
        &#34;&#34;&#34;     
        return abs(self.x) + abs(self.y)
    
    @property
    def chebyshev_length(self) -&gt; float:
        &#34;&#34;&#34;`Read only`
        
        Retourne la distance de Chebyshev.
        
        Cette distance correspond à la distance la plus grande entre les 
        abscisses et les ordonnées.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
            &gt;&gt;&gt; v1.chebyshev_length
            5.0
        &#34;&#34;&#34;     
        return max(abs(self.x), abs(self.y))
    
    
    def minkowski_length(self, order : float = 2.) -&gt; float:
        &#34;&#34;&#34;Retourne la distance de Minkowski.
        
        Args:
            order (float): Le coefficient de puissance utilisé. Defaults = 2.0

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
            &gt;&gt;&gt; v1.minkowski_length(1)
            3.0
        &#34;&#34;&#34;               
        return (abs(self.x) ** order + abs(self.y) ** order) ** (1. / order)

    @property
    def right_perpendicular(self) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;`Read only`
        
        Retourne une nouvelle instance de &#39;Vect2D&#39; représentant une rotation 
        de 90° vers la droite.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
            &gt;&gt;&gt; print(v1.right_perpendicular)
            (1.00E+00, -2.00E+00)
        &#34;&#34;&#34;             
        return Vect2D(self.y, -self.x)
    
    @property # getter only
    def left_perpendicular(self) -&gt; &#39;Vect2D&#39;: # name ?
        &#34;&#34;&#34;`Read only`
        
        Retourne une nouvelle instance de &#39;Vect2D&#39; représentant une rotation 
        de 90° vers la gauche.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
            &gt;&gt;&gt; print(v1.left_perpendicular)
            (-1.00E+00, 2.00E+00)
        &#34;&#34;&#34;             
        return Vect2D(-self.y, self.x)    
    
    @property
    def flipped(self) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;`Read only`
        
        Retourne une nouvelle instance de &#39;Vect2D&#39; ayant les coordonnées 
        permutées.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
            &gt;&gt;&gt; print(v1.flipped)
            (5.00E+00, 2.00E+00)
        &#34;&#34;&#34;           
        return Vect2D(self.y, self.x)
        
    def flip(self) -&gt; None:
        &#34;&#34;&#34;Permute les valeurs x et y.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
            &gt;&gt;&gt; v1.flip()
            &gt;&gt;&gt; print(v1)
            (5.00E+00, 2.00E+00)
        &#34;&#34;&#34;
        self.x, self.y = self.y, self.x
        
        
        


        
    
    
    #-----------------------------------------------------------------------------------
    #    ____       _                                      _ _             _            
    #   |  _ \ ___ | | __ _ _ __    ___ ___   ___  _ __ __| (_)_ __   __ _| |_ ___  ___ 
    #   | |_) / _ \| |/ _` | &#39;__|  / __/ _ \ / _ \| &#39;__/ _` | | &#39;_ \ / _` | __/ _ \/ __|
    #   |  __/ (_) | | (_| | |    | (_| (_) | (_) | | | (_| | | | | | (_| | ||  __/\__ \
    #   |_|   \___/|_|\__,_|_|     \___\___/ \___/|_|  \__,_|_|_| |_|\__,_|\__\___||___/
    #                                                                                   
    #-----------------------------------------------------------------------------------

    @classmethod
    def from_polar(cls, length : float, orientation : float) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Retourne un vecteur issu de la représentation polaire passée en 
        argument. 
        
        La représentation finale du vecteur est toujours selon un 
        système de coordonnées cartésiennes.
        
        L&#39;orientation est en radians.
        
        Args:
            length (float): La longueur de la coordonnée polaire. 
            orientation (float): L&#39;orientation&#39; de la coordonnée polaire. 

        Exemples:
            &gt;&gt;&gt; from math import pi
            &gt;&gt;&gt; v1 = round(Vect2D.from_polar(5.0, pi/2.))
            &gt;&gt;&gt; print(v1)
            (0.00E+00, 5.00E+00)
        &#34;&#34;&#34;
        return cls(cos(orientation) * length, sin(orientation) * length)


    @classmethod
    def from_polar_degrees(cls, length : float, orientation : float) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Retourne un vecteur issu de la représentation polaire passée en 
        argument. 
        
        La représentation finale du vecteur est toujours selon un 
        système de coordonnées cartésiennes.
        
        L&#39;orientation est en degrées.
        
        Args:
            length (float): La longueur de la coordonnée polaire. 
            orientation (float): L&#39;orientation&#39; de la coordonnée polaire. 

        Exemples:
            &gt;&gt;&gt; v1 = round(Vect2D.from_polar_degrees(5.0, 90.))
            &gt;&gt;&gt; print(v1)
            (0.00E+00, 5.00E+00)
        &#34;&#34;&#34;
        return cls.from_polar(length, radians(orientation))
    
    def set_polar(self, length : float, orientation : float) -&gt; None:
        &#34;&#34;&#34;Détermine le vecteur courant par la représentation polaire passée en 
        argument. 
        
        La représentation finale du vecteur est toujours selon un 
        système de coordonnées cartésiennes.
        
        L&#39;orientation est en radians.
        
        Args:
            length (float): La longueur de la coordonnée polaire. 
            orientation (float): L&#39;orientation&#39; de la coordonnée polaire. 

        Exemples:
            &gt;&gt;&gt; from math import pi
            &gt;&gt;&gt; Vect2D.set_value_format(False, 1)
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.set_polar(5.0, pi/2.)
            &gt;&gt;&gt; print(v1)
            (0.0, 5.0)
            &gt;&gt;&gt; Vect2D.set_value_format(True, 2)
        &#34;&#34;&#34;        
        self.x = length * cos(orientation)
        self.y = length * sin(orientation)

    @property
    def length_squared(self) -&gt; float:
        &#34;&#34;&#34;`Read &amp; Write`
        
        La longueur du vecteur au carré.
        
        Correspond à la distance au carré du système de coordonnées polaires. 
        La métrique retournée correspond à la distance euclidienne.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(1.0, 2.0)
            &gt;&gt;&gt; v1.length_squared
            5.0
        &#34;&#34;&#34;
        return self.x ** 2. + self.y ** 2.
    
    @length_squared.setter
    def length_squared(self, value : float) -&gt; None:
        self.set_polar(sqrt(value), self.orientation)

    @property
    def length(self) -&gt; float:
        &#34;&#34;&#34;`Read &amp; Write`
        
        La longueur du vecteur.
        
        Correspond à la distance du système de coordonnées polaires. 
        La métrique retournée correspond à la distance euclidienne.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
            &gt;&gt;&gt; v1.length
            1.4142135623730951
        &#34;&#34;&#34;
        return sqrt(self.length_squared)
    
    @length.setter
    def length(self, value : float) -&gt; None:
        self.set_polar(value, self.orientation)
    
    @property
    def orientation(self) -&gt; float:
        &#34;&#34;&#34;`Read &amp; Write`
        
        L&#39;orientation du vecteur.
        
        Correspond à l&#39;orientation du système de coordonnées polaires. 
        La métrique retournée est l&#39;angle en radians.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
            &gt;&gt;&gt; v1.orientation
            0.7853981633974483
        &#34;&#34;&#34;        
        return atan2(self.y, self.x)
    
    @orientation.setter
    def orientation(self, value : float) -&gt; None:
        self.set_polar(self.length, value)
        
    @property
    def orientation_degrees(self) -&gt; float:
        &#34;&#34;&#34;`Read &amp; Write`
        
        L&#39;orientation du vecteur.
        
        Correspond à l&#39;orientation du système de coordonnées polaires. 
        La métrique retournée est l&#39;angle en degrées.
                
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
            &gt;&gt;&gt; v1.orientation_degrees
            45.0
        &#34;&#34;&#34;
        return degrees(atan2(self.y, self.x))
    
    @orientation_degrees.setter
    def orientation_degrees(self, value : float) -&gt; None:
        self.set_polar(self.length, radians(value))

    def limit_length_squared(self, max_length_squared : float) -&gt; None:
        &#34;&#34;&#34;Limite la longueur au carré du vecteur. 
        
        Si la longueur au carré est plus petite que la limite, le vecteur 
        reste inchangé. Si la longueur au carré est plus grande, le vecteur 
        est limité à la longueur au carré maximum indiquée. 
        
        Args:
            max_length_squared (float): La longueur au carré maximum que le 
            vecteur peut avoir. Cette longueur doit être strictement positive.
            (max_length_squared &gt; 0.0)

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; v1.limit_length_squared(9.0)
            &gt;&gt;&gt; print(v1)
            (3.00E+00, 0.00E+00)
            &gt;&gt;&gt; v1.limit_length_squared(25.0)
            &gt;&gt;&gt; print(v1)
            (3.00E+00, 0.00E+00)
        &#34;&#34;&#34;
        if self.length_squared &gt; max_length_squared:
            self.length_squared = max_length_squared

    def limit_length(self, max_length : float) -&gt; None:
        &#34;&#34;&#34;Limite la longueur du vecteur. 
        
        Si la longueur est plus petite que la limite, le vecteur reste 
        inchangé. Si la longueur est plus grande, le vecteur est limité 
        à la longueur maximum indiquée. 
        
        Args:
            max_length (float): La longueur maximum que le vecteur peut 
            avoir. Cette longueur doit être strictement positive.
            (max_length_squared &gt; 0.0)

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(0.0, 5.0)
            &gt;&gt;&gt; v1.limit_length(3.0)
            &gt;&gt;&gt; print(round(v1))
            (0.00E+00, 3.00E+00)
            &gt;&gt;&gt; v1.limit_length(5.0)
            &gt;&gt;&gt; print(round(v1))
            (0.00E+00, 3.00E+00)
        &#34;&#34;&#34;
        if self.length_squared &gt; max_length * max_length:
            self.length = max_length

    def clamp_length_squared(self, min_length_squared : float, max_length_squared : float) -&gt; None:
        &#34;&#34;&#34;Borne la longueur au carré du vecteur. 
        
        La longueur au carré est bornée aux limites inférieures et supérieures.
        
        0 &lt; min_length_squared &lt; max_length_squared
        
        Args:
            min_length_squared (float): La longueur au carré minimum que le 
                vecteur peut avoir. Cette longueur doit être strictement 
                positive et inférieure à la longueur au carré maximum. 
            max_length_squared (float): La longueur au carré maximum que le 
                vecteur peut avoir. Cette longueur doit être strictement 
                positive et supérieure à la longueur au carré minimum. 

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; v1.clamp_length_squared(9.0, 16.0)
            &gt;&gt;&gt; print(v1)
            (4.00E+00, 0.00E+00)
            &gt;&gt;&gt; v1.clamp_length_squared(9.0, 25.0)
            &gt;&gt;&gt; print(v1)
            (4.00E+00, 0.00E+00)
        &#34;&#34;&#34;
        length_squared = self.length_squared
        if length_squared &lt; min_length_squared:
            self.length_squared = min_length_squared
        elif length_squared &gt; max_length_squared:
            self.length_squared = max_length_squared

    def clamp_length(self, min_length : float, max_length : float) -&gt; None:
        &#34;&#34;&#34;Borne la longueur du vecteur. 
        
        La longueur est bornée aux limites inférieures et supérieures.
        
        0 &lt; min_length &lt; max_length

        Args:
            min_length (float): La longueur minimum que le vecteur peut 
                avoir. Cette longueur doit être strictement positive et 
                inférieure à la longueur maximum. 
            max_length (float): La longueur maximum que le vecteur peut 
                avoir. Cette longueur doit être strictement positive et 
                supérieure à la longueur minimum. 

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; v1.clamp_length(3.0, 4.0)
            &gt;&gt;&gt; print(v1)
            (4.00E+00, 0.00E+00)
            &gt;&gt;&gt; v1.clamp_length(3.0, 5.0)
            &gt;&gt;&gt; print(v1)
            (4.00E+00, 0.00E+00)
        &#34;&#34;&#34;
        length_sqared = self.length_squared
        if length_sqared &lt; min_length * min_length:
            self.length = min_length
        elif length_sqared &gt; max_length * max_length:
            self.length = max_length

    # to do
    # def clamp_orientation(self, orientation_from : float, orientation_to : float) -&gt; None:
    #     # orientation = self.orientation
    #     ...


    
    #--------------------------------------------------------------------
    #    _   _                            _ _          _   _             
    #   | \ | | ___  _ __ _ __ ___   __ _| (_)______ _| |_(_) ___  _ __  
    #   |  \| |/ _ \| &#39;__| &#39;_ ` _ \ / _` | | |_  / _` | __| |/ _ \| &#39;_ \ 
    #   | |\  | (_) | |  | | | | | | (_| | | |/ / (_| | |_| | (_) | | | |
    #   |_| \_|\___/|_|  |_| |_| |_|\__,_|_|_/___\__,_|\__|_|\___/|_| |_|
    #                                                                    
    #--------------------------------------------------------------------

    @property
    def is_normalized(self) -&gt; bool:
        &#34;&#34;&#34;`Read only`
        
        Est-ce que le vecteur est normalisé.
        
        Un vecteur normalisé est un vecteur unitaire (de longueur 1.0).
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v2 = Vect2D(1.0, 0.0)
            &gt;&gt;&gt; v1.is_normalized
            False
            &gt;&gt;&gt; v2.is_normalized
            True
        &#34;&#34;&#34;
        return isclose(self.length_squared, 1.0)    

    @property
    def normalized(self) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;`Read only`
        
        Retourne une nouvelle instance de &#39;Vect2D&#39; correspondant au vecteur  
        unitaire du vecteur courant.
        
        Le vecteur doit être défini.

        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; v2 = v1.normalized
            &gt;&gt;&gt; print(v2)
            (1.00E+00, 0.00E+00)
        &#34;&#34;&#34;        
        vect = Vect2D(self.x, self.y)
        vect.normalize()
        return vect
    
    def normalize(self) -&gt; None:
        &#34;&#34;&#34;Modifie le vecteur courant pour qu&#39;il soit unitaire.
        Cette transformation garde l&#39;angle du vecteur.
        
        Le vecteur doit être défini.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
            &gt;&gt;&gt; v1.normalize()
            &gt;&gt;&gt; print(v1)
            (1.00E+00, 0.00E+00)
        &#34;&#34;&#34;
        if self.is_defined:
            norm = self.length
            self.x /= norm
            self.y /= norm
        else:
            raise RuntimeError(&#39;cannot normalize a non defined vector&#39;)





    
#------------------------------------------------------------------------    
#    ____                 _                 _          _   _             
#   |  _ \ __ _ _ __   __| | ___  _ __ ___ (_)______ _| |_(_) ___  _ __  
#   | |_) / _` | &#39;_ \ / _` |/ _ \| &#39;_ ` _ \| |_  / _` | __| |/ _ \| &#39;_ \ 
#   |  _ &lt; (_| | | | | (_| | (_) | | | | | | |/ / (_| | |_| | (_) | | | |
#   |_| \_\__,_|_| |_|\__,_|\___/|_| |_| |_|_/___\__,_|\__|_|\___/|_| |_|
#                                                                        
#------------------------------------------------------------------------    



    def randomize_normalized(self) -&gt; None:
        &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur unitaire aléatoire.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.randomize_normalized()
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (1.00E+00, 0.00E+00)
        &#34;&#34;&#34;        
        self.set_polar(1.0, uniform(0., tau))

    def randomize_cartesian(self, x_min : float, x_max : float, y_min : float, y_max : float) -&gt; None:
        &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur aléatoire 
        paramétré dans le système de coordonnées cartésiennes.
        
        Args:
            x_min (float): La borne inférieure sur l&#39;axe des abscisses.
            x_max (float): La borne supérieure sur l&#39;axe des abscisses.
            y_min (float): La borne inférieure sur l&#39;axe des ordonnées.
            y_max (float): La borne supérieure sur l&#39;axe des ordonnées.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.randomize_cartesian(0., 100., 0, 100.)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 77.00E+00)
        &#34;&#34;&#34;                
        self.x = uniform(x_min, x_max)
        self.y = uniform(y_min, y_max)

    # def randomize_polar(self, minLength, maxLength, minOrientation=0., maxOrientation=tau) -&gt; None:
    #     self.set_polar(uniform(minLength, maxLength), uniform(minOrientation, maxOrientation))
    def randomize_polar(self, length_min : float, length_max : float, orientation_half_span  : float = tau, orientation_reference : float = 0.) -&gt; None:
        &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur aléatoire 
        paramétré dans le système de coordonnées polaires.
        
        L&#39;orientation est définie en radians.
                
        Args:
            length_min (float): La longueur inférieure (sur l&#39;axe des distances).
            length_max (float): La longueur spérieure (sur l&#39;axe des distances).
            orientation_half_span (float): L&#39;étendu de l&#39;orientation en radians (sur l&#39;axe de rotation). Defaults = tau
            orientation_reference (float): L&#39;angle de référence en radians (sur l&#39;axe de rotation). Defaults = 0.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 3.14)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 28.00E+00)
        &#34;&#34;&#34;                        
        self.set_polar(uniform(length_min, length_max), uniform(-orientation_half_span, orientation_half_span) + orientation_reference)
    
    def randomize_polar_degrees(self, length_min : float, length_max : float, orientation_half_span  : float = 360., orientation_reference : float = 0.) -&gt; None:
        &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur aléatoire 
        paramétré dans le système de coordonnées polaires.
        
        L&#39;orientation est définie en degrées.
        
        Args:
            length_min (float): La longueur inférieure (sur l&#39;axe des distances).
            length_max (float): La longueur spérieure (sur l&#39;axe des distances).
            orientation_half_span (float): L&#39;étendu de l&#39;orientation en degrées (sur l&#39;axe de rotation). Defaults = 360.
            orientation_reference (float): L&#39;angle de référence en degrées (sur l&#39;axe de rotation). Defaults = 0.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 90.)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 28.00E+00)
        &#34;&#34;&#34;                        
        self.randomize_polar(length_min, length_max, radians(orientation_half_span), radians(orientation_reference))
    
    @classmethod
    def from_random_normalized(cls) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; correspondant à vecteur unitaire aléatoire.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D.from_random_normalized()
            &gt;&gt;&gt; print() # doctest: +SKIP
            (1.00E+00, 0.00E+00)
        &#34;&#34;&#34;           
        vect2d = cls()
        vect2d.randomize_normalized()
        return vect2d
    
    @classmethod
    def from_random_cartesian(cls, x_min : float, x_max : float, y_min : float, y_max : float) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; aléatoirement paramétré 
        dans le système de coordonnées cartésiennes.
        
        Args:
            x_min (float): La borne inférieure sur l&#39;axe des abscisses.
            x_max (float): La borne supérieure sur l&#39;axe des abscisses.
            y_min (float): La borne inférieure sur l&#39;axe des ordonnées.
            y_max (float): La borne supérieure sur l&#39;axe des ordonnées.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D.from_random_cartesian(0., 100., 0, 100.)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 77.00E+00)
        &#34;&#34;&#34;    
        vect2d = cls()
        vect2d.randomize_cartesian(x_min, x_max, y_min, y_max)
        return vect2d
    
    @classmethod
    def from_random_polar(cls, length_min : float, length_max : float, orientation_half_span : float = tau, orientation_reference : float = 0.) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; aléatoirement paramétré
        dans le système de coordonnées polaires.
        
        L&#39;orientation est définie en radians.
                
        Args:
            length_min (float): La longueur inférieure (sur l&#39;axe des distances).
            length_max (float): La longueur spérieure (sur l&#39;axe des distances).
            orientation_half_span (float): L&#39;étendu de l&#39;orientation en radians (sur l&#39;axe de rotation). Defaults = tau
            orientation_reference (float): L&#39;angle de référence en radians (sur l&#39;axe de rotation). Defaults = 0.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D.from_random_polar(0., 100., 0., 3.14)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 28.00E+00)
        &#34;&#34;&#34;      
        vect2d = cls()
        vect2d.randomize_polar(length_min, length_max, orientation_half_span, orientation_reference)
        return vect2d
    
    @classmethod
    def from_random_polar_degrees(cls, length_min : float, length_max : float, orientation_half_span : float = 360., orientation_reference : float = 0.) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; aléatoirement paramétré
        dans le système de coordonnées polaires.
        
        L&#39;orientation est définie en degrées.
                
        Args:
            length_min (float): La longueur inférieure (sur l&#39;axe des distances).
            length_max (float): La longueur spérieure (sur l&#39;axe des distances).
            orientation_half_span (float): L&#39;étendu de l&#39;orientation en degrées (sur l&#39;axe de rotation). Defaults = 360.
            orientation_reference (float): L&#39;angle de référence en degrées (sur l&#39;axe de rotation). Defaults = 0.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D()
            &gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 90.)
            &gt;&gt;&gt; print(v1) # doctest: +SKIP
            (12.00E+00, 28.00E+00)
        &#34;&#34;&#34;
        return cls.from_random_polar_degrees(length_min, length_max, radians(orientation_half_span), radians(orientation_reference))
    
        

    

    #------------------------------------------------------------------------------------------------------------
    #   __        __         _    _                        _ _   _       ____   __     __        _   ____  ____  
    #   \ \      / /__  _ __| | _(_)_ __   __ _  __      _(_) |_| |__   |___ \  \ \   / /__  ___| |_|___ \|  _ \ 
    #    \ \ /\ / / _ \| &#39;__| |/ / | &#39;_ \ / _` | \ \ /\ / / | __| &#39;_ \    __) |  \ \ / / _ \/ __| __| __) | | | |
    #     \ V  V / (_) | |  |   &lt;| | | | | (_| |  \ V  V /| | |_| | | |  / __/    \ V /  __/ (__| |_ / __/| |_| |
    #      \_/\_/ \___/|_|  |_|\_\_|_| |_|\__, |   \_/\_/ |_|\__|_| |_| |_____|    \_/ \___|\___|\__|_____|____/ 
    #                                     |___/                                                                  
    #------------------------------------------------------------------------------------------------------------
    
    def distance_squared_from(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne la distance euclidienne au carré entre ce vecteur et 
        celui passé en argument.
        
        Args:
            other (Vect2D): L&#39;autre vecteur dont la distance est à évaluer.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
            &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
            &gt;&gt;&gt; v1.distance_squared_from(v2)
            25.0
        &#34;&#34;&#34;        
        return (self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y)
    
    def distance_from(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne la distance euclidienne entre ce vecteur et celui 
        passé en argument.
        
        Args:
            other (Vect2D): L&#39;autre vecteur dont la distance est à évaluer.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
            &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
            &gt;&gt;&gt; v1.distance_from(v2)
            5.0
        &#34;&#34;&#34;        
        return sqrt(self.distance_squared_from(other))
    
    def is_perpendicular_to(self, other : &#39;Vect2D&#39;) -&gt; bool:
        &#34;&#34;&#34;Retourne &#39;True&#39; si ce vecteur est perpendiculaire à celui 
        passé en argument. Sinon retourne &#39;False&#39;.
        
        Args:
            other (Vect2D): L&#39;autre vecteur à comparer.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
            &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
            &gt;&gt;&gt; v1.is_perpendicular_to(v2)
            False
            &gt;&gt;&gt; v1.is_perpendicular_to(v1.right_perpendicular)
            True
        &#34;&#34;&#34;         
        return isclose(self.dot(other), 0.0)
    
    def is_parallel_to(self, other : &#39;Vect2D&#39;) -&gt; bool:
        &#34;&#34;&#34;Retourne &#39;True&#39; si ce vecteur est perpendiculaire à celui 
        passé en argument. Sinon retourne &#39;False&#39;.
        
        Args:
            other (Vect2D): L&#39;autre vecteur à comparer.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
            &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
            &gt;&gt;&gt; v1.is_parallel_to(v2)
            False
            &gt;&gt;&gt; v1.is_parallel_to(v1.right_perpendicular.right_perpendicular)
            True
        &#34;&#34;&#34;
        return isclose(self.cross(other), 0.0)
        #return self.is_perpendicular_to(other.right_perpendicular)
    
    def is_forming_accute_angle_with(self, other : &#39;Vect2D&#39;) -&gt; bool: # the ~ same direction : acute angle 0 &lt;= theta &lt;= 90
        &#34;&#34;&#34;Retourne &#39;True&#39; si ce vecteur et celui passé en argument forment 
        un angle aigu. Sinon retourne &#39;False&#39;.
        
        Args:
            other (Vect2D): L&#39;autre vecteur à comparer.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D.from_polar_degrees(10.0, 45.0)
            &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(10.0, 75.0)
            &gt;&gt;&gt; v3 = Vect2D.from_polar_degrees(10.0, 185.0)
            &gt;&gt;&gt; v1.is_forming_accute_angle_with(v2)
            True
            &gt;&gt;&gt; v1.is_forming_accute_angle_with(v3)
            False
        &#34;&#34;&#34;
        return self.dot(other) &gt; 0.0
    
    def is_forming_obtuse_angle_with(self, other : &#39;Vect2D&#39;) -&gt; bool: # the ~ opposite direction : obtuse angle 90 &lt;= theta &lt;= 180
        return self.dot(other) &lt; 0.0

    
    
    #-----------------------------------------
    #    ____                _            _   
    #   |  _ \ _ __ ___   __| |_   _  ___| |_ 
    #   | |_) | &#39;__/ _ \ / _` | | | |/ __| __|
    #   |  __/| | | (_) | (_| | |_| | (__| |_ 
    #   |_|   |_|  \___/ \__,_|\__,_|\___|\__|
    #                                         
    #-----------------------------------------
    def dot(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne le produit scalaire de ce vecteur avec celui passé en 
        argument.
        
        Args:
            other (Vect2D): L&#39;autre vecteur.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, -5.0)
            &gt;&gt;&gt; v2 = Vect2D(-3.0, 2.0)
            &gt;&gt;&gt; v1.dot(v2)
            -16.0
        &#34;&#34;&#34;
        return self.x * other.x + self.y * other.y
    
    def cross(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne le produit vectoriel de ce vecteur avec celui passé en 
        argument.
        
        Args:
            other (Vect2D): L&#39;autre vecteur.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.0, -5.0)
            &gt;&gt;&gt; v2 = Vect2D(-3.0, 2.0)
            &gt;&gt;&gt; v1.cross(v2)
            -11.0
        &#34;&#34;&#34;        
        return self.x * other.y - self.y * other.x
    
    
    
    # def translate(self, ...)
    # def rotate(self, ...)
    # def scale(self, ...)
    # def transform(self, ...)
    
    
    #----------------------------------------------------------------------------------------------------
    #    ____            _           _   _                  __  ____       _           _   _             
    #   |  _ \ _ __ ___ (_) ___  ___| |_(_) ___  _ __      / / |  _ \ ___ (_) ___  ___| |_(_) ___  _ __  
    #   | |_) | &#39;__/ _ \| |/ _ \/ __| __| |/ _ \| &#39;_ \    / /  | |_) / _ \| |/ _ \/ __| __| |/ _ \| &#39;_ \ 
    #   |  __/| | | (_) | |  __/ (__| |_| | (_) | | | |  / /   |  _ &lt;  __/| |  __/ (__| |_| | (_) | | | |
    #   |_|   |_|  \___// |\___|\___|\__|_|\___/|_| |_| /_/    |_| \_\___|/ |\___|\___|\__|_|\___/|_| |_|
    #                 |__/                                              |__/                                 
    #----------------------------------------------------------------------------------------------------
    def angle_between(self, other : &#39;Vect2D&#39;) -&gt; float: # in radians
        &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument.
        
        L&#39;angle est en radians.
        
        Args:
            other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
        
        Exemples:
            &gt;&gt;&gt; from math import isclose, pi, degrees
            &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
            &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
            &gt;&gt;&gt; isclose(v1.angle_between(v2), pi / 8.0)
            True
            &gt;&gt;&gt; round(degrees(v1.angle_between(v2)), 1)
            22.5
        &#34;&#34;&#34;
        return acos(self.dot(other) / sqrt(self.length_squared * other.length_squared))

    def angle_between_degrees(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument.
        
        L&#39;angle est en degrées.
        
        Args:
            other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
        
        Exemples:
            &gt;&gt;&gt; from math import isclose, pi, degrees
            &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
            &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
            &gt;&gt;&gt; isclose(v1.angle_between_degrees(v2), 22.5)
            True
            &gt;&gt;&gt; round(v1.angle_between_degrees(v2),1)
            22.5
        &#34;&#34;&#34;
        return degrees(self.angle_between(other))
    
    def angle_disparity(self, other : &#39;Vect2D&#39;) -&gt; float: # angle in radians with direction
        &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument. 
        La direction de l&#39;angle est donné contrairement à la fonction 
        angle_between :
         - si l&#39;angle est négatif, l&#39;autre vecteur se trouve dans le sens 
           inverse de rotation
         - si l&#39;angle est positif, l&#39;autre vecteur se trouve dans le sens 
           de rotation
        
        L&#39;angle est en radians.
        
        Args:
            other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
        
        Exemples:
            &gt;&gt;&gt; from math import isclose, pi, degrees
            &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
            &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
            &gt;&gt;&gt; isclose(v1.angle_disparity(v2), pi / 8.0)
            True
            &gt;&gt;&gt; round(degrees(v1.angle_disparity(v2)), 1)
            22.5
            &gt;&gt;&gt; round(degrees(v2.angle_disparity(v1)), 1)
            -22.5
        &#34;&#34;&#34;
        return atan2(self.cross(other), self.x * other.x + self.y * other.y)
    
    def angle_disparity_degrees(self, other : &#39;Vect2D&#39;) -&gt; float: # angle in radians with direction
        &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument. 
        La direction de l&#39;angle est donné contrairement à la fonction 
        angle_between :
         - si l&#39;angle est négatif, l&#39;autre vecteur se trouve dans le sens 
           inverse de la rotation
         - si l&#39;angle est positif, l&#39;autre vecteur se trouve dans le sens 
           de la rotation
        
        L&#39;angle est en degrées.
        
        Args:
            other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
        
        Exemples:
            &gt;&gt;&gt; from math import isclose
            &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
            &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
            &gt;&gt;&gt; isclose(v1.angle_disparity_degrees(v2), 22.5)
            True
            &gt;&gt;&gt; round(v1.angle_disparity_degrees(v2), 1)
            22.5
            &gt;&gt;&gt; round(v2.angle_disparity_degrees(v1), 1)
            -22.5
        &#34;&#34;&#34;
        return degrees(self.angle_disparity(other))
    
    
    
    def scalar_projection(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne la projection scalaire de ce vecteur sur le vecteur passé 
        en argument.
        
        Args:
            other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
            courant.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; v1.scalar_projection(v2)
            3.0
        &#34;&#34;&#34;
        return self.dot(other) / other.length

    def vector_projection(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Retourne la projection vectorielle de ce vecteur sur le vecteur passé 
        en argument.
        
        Args:
            other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
            courant.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; print(v1.vector_projection(v2))
            (3.00E+00, 0.00E+00)
        &#34;&#34;&#34;        
        return self.dot(other) / other.dot(other) * other
    
    def scalar_rejection(self, other : &#39;Vect2D&#39;) -&gt; float:
        &#34;&#34;&#34;Retourne la réjection scalaire de ce vecteur sur le vecteur passé 
        en argument.
        
        Args:
            other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
            courant.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; v1.scalar_rejection(v2)
            1.0
        &#34;&#34;&#34;
        return (self.y * other.x - self.x * other.y) / other.length
    
    def vector_rejection(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Retourne la réjection vectorielle de ce vecteur sur le vecteur passé 
        en argument.
        
        Args:
            other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
            courant.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; print(v1.vector_rejection(v2))
            (0.00E+00, 1.00E+00)
        &#34;&#34;&#34;     
        return self - self.vector_projection(other)
    
    def projection_analysis(self, other : &#39;Vect2D&#39;) -&gt; tuple[float, &#39;Vect2D&#39;, float, &#39;Vect2D&#39;]:
        &#34;&#34;&#34;Retourne l&#39;analyse complète de la projection de ce vecteur sur le vecteur passé 
        en argument.
        
        Args:
            other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
            courant.

        Returns:
            un tuple contenant :
             - la projection scalaire
             - la projection vectorielle
             - la réjection scalaire
             - la réjection vectorielle
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
            &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
            &gt;&gt;&gt; analysis = v1.projection_analysis(v2)
            &gt;&gt;&gt; print(f&#39;Projection : {analysis[0]} | {analysis[1]}&#39;)
            Projection : 3.0 | (3.00E+00, 0.00E+00)
            &gt;&gt;&gt; print(f&#39;Réjection : {analysis[2]} | {analysis[3]}&#39;)
            Réjection : 1.0 | (0.00E+00, 1.00E+00)
        &#34;&#34;&#34;             
        scalar_proj = self.scalar_projection(other)
        vector_proj = scalar_proj * other.normalized
        scalar_rej = self.scalar_rejection(other)
        vector_rej = self - vector_proj
        
        return (scalar_proj, vector_proj, scalar_rej, vector_rej)



    #---------------------------------------------------------------------------------------------------------
    #     ___                       _                                       _                 _ _             
    #    / _ \ _ __   ___ _ __ __ _| |_ ___  _ __ ___    _____   _____ _ __| | ___   __ _  __| (_)_ __   __ _ 
    #   | | | | &#39;_ \ / _ \ &#39;__/ _` | __/ _ \| &#39;__/ __|  / _ \ \ / / _ \ &#39;__| |/ _ \ / _` |/ _` | | &#39;_ \ / _` |
    #   | |_| | |_) |  __/ | | (_| | || (_) | |  \__ \ | (_) \ V /  __/ |  | | (_) | (_| | (_| | | | | | (_| |
    #    \___/| .__/ \___|_|  \__,_|\__\___/|_|  |___/  \___/ \_/ \___|_|  |_|\___/ \__,_|\__,_|_|_| |_|\__, |
    #         |_|                                                                                       |___/ 
    #---------------------------------------------------------------------------------------------------------
    
    def __eq__(self, other : &#39;Vect2D&#39;) -&gt; bool: # self == other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v2 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v3 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 == v2
        False
        &gt;&gt;&gt; v2 == v3
        True
        &#34;&#34;&#34;
        return isclose(self.x, other.x) and isclose(self.y, other.y)
    
    def __ne__(self, other : &#39;Vect2D&#39;) -&gt; bool: # self != other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v2 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v3 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 != v2
        True
        &gt;&gt;&gt; v2 != v3
        False
        &#34;&#34;&#34;
        return not (isclose(self.x, other.x) and isclose(self.y, other.y))
        
    def __neg__(self) -&gt; &#39;Vect2D&#39;: # -self
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; print(-v1)
        (-1.00E+00, 1.50E+00)
        &#34;&#34;&#34;
        return Vect2D(-self.x, -self.y)
        
    def __add__(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;: # self + other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v2 = Vect2D(-2.0, 1.0)
        &gt;&gt;&gt; print(v1 + v2)
        (-1.00E+00, -5.00E-01)
        &#34;&#34;&#34;
        return Vect2D(self.x + other.x, self.y + other.y)

    def __iadd__(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;: # self += other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 += Vect2D(-2.0, 1.0)
        &gt;&gt;&gt; print(v1)
        (-1.00E+00, -5.00E-01)
        &#34;&#34;&#34;
        self.x += other.x
        self.y += other.y
        return self

    def __sub__(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;: # self - other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v2 = Vect2D(-2.0, 1.0)
        &gt;&gt;&gt; print(v1 - v2)
        (3.00E+00, -2.50E+00)
        &#34;&#34;&#34;
        return Vect2D(self.x - other.x, self.y - other.y)

    def __isub__(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;: # self -= other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 -= Vect2D(-2.0, 1.0)
        &gt;&gt;&gt; print(v1)
        (3.00E+00, -2.50E+00)
        &#34;&#34;&#34;
        self.x -= other.x
        self.y -= other.y
        return self

    def __mul__(self, other : float) -&gt; &#39;Vect2D&#39;: # self * other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; print(v1 * 5.0)
        (5.00E+00, -7.50E+00)
        &#34;&#34;&#34;
        return Vect2D(self.x * other, self.y * other)

    def __rmul__(self, other : float) -&gt; &#39;Vect2D&#39;: # other * self
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; print(5.0 * v1)
        (5.00E+00, -7.50E+00)
        &#34;&#34;&#34;
        return Vect2D(self.x * other, self.y * other)

    def __imul__(self, other : float) -&gt; &#39;Vect2D&#39;: # self *= other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 *= 5.0
        &gt;&gt;&gt; print(v1)
        (5.00E+00, -7.50E+00)
        &#34;&#34;&#34;
        self.x *= other
        self.y *= other
        return self

    def __truediv__(self, other : float) -&gt; &#39;Vect2D&#39;: # self / other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; print(v1 / 2.0)
        (5.00E-01, -7.50E-01)
        &#34;&#34;&#34;
        return Vect2D(self.x / other, self.y / other)

    def __rtruediv__(self, other: float) -&gt; &#39;Vect2D&#39;: # other / self
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; print(2.0 / v1)
        (2.00E+00, -1.33E+00)
        &#34;&#34;&#34;
        return Vect2D(other / self.x, other / self.y)

    def __itruediv__(self, other : float) -&gt; &#39;Vect2D&#39;: # self /= other
        &#34;&#34;&#34;
        &gt;&gt;&gt; v1 = Vect2D(1.0, -1.5)
        &gt;&gt;&gt; v1 /= 2.0
        &gt;&gt;&gt; print(v1)
        (5.00E-01, -7.50E-01)
        &#34;&#34;&#34;
        self.x /= other
        self.y /= other
        return self
    
    
    
    #--------------------------------------------------------------------------------------------------------    
    #    _____                 _   _                                       _                 _ _             
    #   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___    _____   _____ _ __| | ___   __ _  __| (_)_ __   __ _ 
    #   | |_ | | | | &#39;_ \ / __| __| |/ _ \| &#39;_ \/ __|  / _ \ \ / / _ \ &#39;__| |/ _ \ / _` |/ _` | | &#39;_ \ / _` |
    #   |  _|| |_| | | | | (__| |_| | (_) | | | \__ \ | (_) \ V /  __/ |  | | (_) | (_| | (_| | | | | | (_| |
    #   |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/  \___/ \_/ \___|_|  |_|\___/ \__,_|\__,_|_|_| |_|\__, |
    #                                                                                                  |___/ 
    #--------------------------------------------------------------------------------------------------------    
    
    def __abs__(self) -&gt; &#39;Vect2D&#39;: # abs(self)
        &#34;&#34;&#34;Retourne les valeurs absolues de `x` et `y`.
        
        Retourne une nouvelle instance de `Vect2D` tout en ne modifiant pas 
        l&#39;instance courante. Les valeur `x` et `y` restent des `float` même 
        si elles sont arrondies.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.25, -1.75)
            &gt;&gt;&gt; v2 = abs(v1)
            &gt;&gt;&gt; print(v2)
            (2.25E+00, 1.75E+00)
        &#34;&#34;&#34;             
        return Vect2D(abs(self.x), abs(self.y))
    
    def __round__(self, ndigits=None) -&gt; &#39;Vect2D&#39;: # round(self)
        &#34;&#34;&#34;Arrondi les composantes x et y du vecteur vers l&#39;entier le plus près.
        
        Retourne une nouvelle instance de `Vect2D` tout en ne modifiant pas 
        l&#39;instance courante. Les valeur `x` et `y` restent des `float` même 
        si elles sont arrondies.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.25, -1.75)
            &gt;&gt;&gt; v2 = round(v1)
            &gt;&gt;&gt; print(v2)
            (2.00E+00, -2.00E+00)
        &#34;&#34;&#34;             
        return Vect2D(round(self.x, ndigits), round(self.y, ndigits))
    
    def __trunc__(self) -&gt; &#39;Vect2D&#39;: # trunc(self)
        &#34;&#34;&#34;Arrondi les composantes x et y du vecteur vers zéro.
        
        Retourne une nouvelle instance de `Vect2D` tout en ne modifiant pas 
        l&#39;instance courante. Les valeur `x` et `y` restent des `float` même 
        si elles sont arrondies.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.25, -1.75)
            &gt;&gt;&gt; v2 = trunc(v1)
            &gt;&gt;&gt; print(v2)
            (2.00E+00, -1.00E+00)
        &#34;&#34;&#34;             
        return Vect2D(trunc(self.x), trunc(self.y))
    
    def __floor__(self) -&gt; &#39;Vect2D&#39;: # floor(self)
        &#34;&#34;&#34;Arrondi les composantes x et y du vecteur vers l&#39;infini négatif.
        
        Retourne une nouvelle instance de `Vect2D` tout en ne modifiant pas 
        l&#39;instance courante. Les valeur `x` et `y` restent des `float` même 
        si elles sont arrondies.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.25, -1.75)
            &gt;&gt;&gt; v2 = floor(v1)
            &gt;&gt;&gt; print(v2)
            (2.00E+00, -2.00E+00)
        &#34;&#34;&#34;                
        return Vect2D(floor(self.x), floor(self.y))
    
    def __ceil__(self) -&gt; &#39;Vect2D&#39;: # ceil(self)
        &#34;&#34;&#34;Arrondi les composantes x et y du vecteur vers l&#39;infini positif.
        
        Retourne une nouvelle instance de `Vect2D` tout en ne modifiant pas 
        l&#39;instance courante. Les valeur `x` et `y` restent des `float` même 
        si elles sont arrondies.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.25, -1.75)
            &gt;&gt;&gt; v2 = ceil(v1)
            &gt;&gt;&gt; print(v2)
            (3.00E+00, -1.00E+00)
        &#34;&#34;&#34;        
        return Vect2D(ceil(self.x), ceil(self.y))


    def __complex__(self) -&gt; &#39;Vect2D&#39;: # complex(self)
        &#34;&#34;&#34;Crée un nombre complexe représentant le vecteur.
        
        Ne modifie pas l&#39;instance courante.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
            &gt;&gt;&gt; comp = complex(v1)
            &gt;&gt;&gt; print(comp)
            (2.5-1.5j)
        &#34;&#34;&#34;        
        return complex(self.x, self.y)
    
    
    @classmethod
    def from_data(cls, data : tuple[float, float] | list[float, float] | dict[str, float]) -&gt; &#39;Vect2D&#39;:
        &#34;&#34;&#34;Crée une nouvelle instance de `Vect2D` à partir d&#39;une structure existante :
        - tuple ou liste de 2 float : 
            - seulement 2 données
            - représentant le x et le y
            - (0.0, 0.0)
            - [0.0, 0.0]
        - dict de 2 float : 
            - les clés doivent des str &#39;x&#39; ou &#39;y&#39; 
            - toutes minuscules ou majuscules
            - { &#39;x&#39;:0.0, &#39;y&#39;:0.0 }
            - { &#39;X&#39;:0.0, &#39;Y&#39;:0.0 }
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D.from_data((1.0, 2.5))
            &gt;&gt;&gt; print(v1)
            (1.00E+00, 2.50E+00)
            &gt;&gt;&gt; v2 = Vect2D.from_data([1.0, 2.5])
            &gt;&gt;&gt; print(v2)
            (1.00E+00, 2.50E+00)
            &gt;&gt;&gt; v3 = Vect2D.from_data({&#39;x&#39;:1.0, &#39;y&#39;:2.5})
            &gt;&gt;&gt; print(v3)
            (1.00E+00, 2.50E+00)
            &gt;&gt;&gt; v4 = Vect2D.from_data({&#39;X&#39;:1.0, &#39;Y&#39;:2.5})
            &gt;&gt;&gt; print(v4)
            (1.00E+00, 2.50E+00)
        &#34;&#34;&#34;               
        if isinstance(data, tuple) and len(data) == 2:
            return Vect2D(data[0], data[1])
        if isinstance(data, list) and len(data) == 2:
            return Vect2D(data[0], data[1])
        if isinstance(data, dict):
            k = set(data.keys()) 
            if k == {&#39;x&#39;, &#39;y&#39;}:
                return Vect2D(data[&#39;x&#39;], data[&#39;y&#39;])
            elif k == {&#39;X&#39;, &#39;Y&#39;}:
                return Vect2D(data[&#39;X&#39;], data[&#39;Y&#39;])
        else:
            raise TypeError(&#34;data is not compatible - must be a tuple/list of 2 float or a dict with &#39;x&#39; or &#39;y&#39;&#34;)
    
    @property
    def as_tuple(self) -&gt; tuple[float, float]:
        &#34;&#34;&#34;Crée et retourne un tuple de deux réels. La liste créée possède 
        les abscisses et les ordonnées dans l&#39;ordre.
        
        Ne modifie pas l&#39;instance courante.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
            &gt;&gt;&gt; print(v1.as_tuple)
            (2.5, -1.5)
        &#34;&#34;&#34;     
        return (self.x, self.y)

    @property
    def as_list(self) -&gt; list[float, float]:
        &#34;&#34;&#34;Crée et retourne une liste de deux réels. La liste créée possède 
        les abscisses et les ordonnées dans l&#39;ordre.
        
        Ne modifie pas l&#39;instance courante.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
            &gt;&gt;&gt; print(v1.as_list)
            [2.5, -1.5]
        &#34;&#34;&#34;     
        return [self.x, self.y]

    @property
    def as_dict(self) -&gt; dict[str, int]:
        &#34;&#34;&#34;Crée et retourne un dictionnaire de deux réels. Le dictionnaire 
        possède les clés suivantes :
        - &#39;x&#39; : les abscisses 
        - &#39;y&#39; : les ordonnées
        
        Ne modifie pas l&#39;instance courante.
        
        Exemples:
            &gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
            &gt;&gt;&gt; print(v1.as_dict)
            {&#39;x&#39;: 2.5, &#39;y&#39;: -1.5}
        &#34;&#34;&#34;             
        return { &#39;x&#39;:self.x, &#39;y&#39;:self.y }</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="vect2d.Vect2D.UNDEFINED"><code class="name">var <span class="ident">UNDEFINED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="vect2d.Vect2D.from_data"><code class="name flex">
<span>def <span class="ident">from_data</span></span>(<span>data: tuple[float, float] | list[float, float] | dict[str, float]) ‑> <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Crée une nouvelle instance de <code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code> à partir d'une structure existante :
- tuple ou liste de 2 float :
- seulement 2 données
- représentant le x et le y
- (0.0, 0.0)
- [0.0, 0.0]
- dict de 2 float :
- les clés doivent des str 'x' ou 'y'
- toutes minuscules ou majuscules
- { 'x':0.0, 'y':0.0 }
- { 'X':0.0, 'Y':0.0 }</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D.from_data((1.0, 2.5))
&gt;&gt;&gt; print(v1)
(1.00E+00, 2.50E+00)
&gt;&gt;&gt; v2 = Vect2D.from_data([1.0, 2.5])
&gt;&gt;&gt; print(v2)
(1.00E+00, 2.50E+00)
&gt;&gt;&gt; v3 = Vect2D.from_data({'x':1.0, 'y':2.5})
&gt;&gt;&gt; print(v3)
(1.00E+00, 2.50E+00)
&gt;&gt;&gt; v4 = Vect2D.from_data({'X':1.0, 'Y':2.5})
&gt;&gt;&gt; print(v4)
(1.00E+00, 2.50E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_data(cls, data : tuple[float, float] | list[float, float] | dict[str, float]) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;Crée une nouvelle instance de `Vect2D` à partir d&#39;une structure existante :
    - tuple ou liste de 2 float : 
        - seulement 2 données
        - représentant le x et le y
        - (0.0, 0.0)
        - [0.0, 0.0]
    - dict de 2 float : 
        - les clés doivent des str &#39;x&#39; ou &#39;y&#39; 
        - toutes minuscules ou majuscules
        - { &#39;x&#39;:0.0, &#39;y&#39;:0.0 }
        - { &#39;X&#39;:0.0, &#39;Y&#39;:0.0 }
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D.from_data((1.0, 2.5))
        &gt;&gt;&gt; print(v1)
        (1.00E+00, 2.50E+00)
        &gt;&gt;&gt; v2 = Vect2D.from_data([1.0, 2.5])
        &gt;&gt;&gt; print(v2)
        (1.00E+00, 2.50E+00)
        &gt;&gt;&gt; v3 = Vect2D.from_data({&#39;x&#39;:1.0, &#39;y&#39;:2.5})
        &gt;&gt;&gt; print(v3)
        (1.00E+00, 2.50E+00)
        &gt;&gt;&gt; v4 = Vect2D.from_data({&#39;X&#39;:1.0, &#39;Y&#39;:2.5})
        &gt;&gt;&gt; print(v4)
        (1.00E+00, 2.50E+00)
    &#34;&#34;&#34;               
    if isinstance(data, tuple) and len(data) == 2:
        return Vect2D(data[0], data[1])
    if isinstance(data, list) and len(data) == 2:
        return Vect2D(data[0], data[1])
    if isinstance(data, dict):
        k = set(data.keys()) 
        if k == {&#39;x&#39;, &#39;y&#39;}:
            return Vect2D(data[&#39;x&#39;], data[&#39;y&#39;])
        elif k == {&#39;X&#39;, &#39;Y&#39;}:
            return Vect2D(data[&#39;X&#39;], data[&#39;Y&#39;])
    else:
        raise TypeError(&#34;data is not compatible - must be a tuple/list of 2 float or a dict with &#39;x&#39; or &#39;y&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.from_polar"><code class="name flex">
<span>def <span class="ident">from_polar</span></span>(<span>length: float, orientation: float) ‑> <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retourne un vecteur issu de la représentation polaire passée en
argument. </p>
<p>La représentation finale du vecteur est toujours selon un
système de coordonnées cartésiennes.</p>
<p>L'orientation est en radians.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur de la coordonnée polaire. </dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>float</code></dt>
<dd>L'orientation' de la coordonnée polaire. </dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; v1 = round(Vect2D.from_polar(5.0, pi/2.))
&gt;&gt;&gt; print(v1)
(0.00E+00, 5.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_polar(cls, length : float, orientation : float) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;Retourne un vecteur issu de la représentation polaire passée en 
    argument. 
    
    La représentation finale du vecteur est toujours selon un 
    système de coordonnées cartésiennes.
    
    L&#39;orientation est en radians.
    
    Args:
        length (float): La longueur de la coordonnée polaire. 
        orientation (float): L&#39;orientation&#39; de la coordonnée polaire. 

    Exemples:
        &gt;&gt;&gt; from math import pi
        &gt;&gt;&gt; v1 = round(Vect2D.from_polar(5.0, pi/2.))
        &gt;&gt;&gt; print(v1)
        (0.00E+00, 5.00E+00)
    &#34;&#34;&#34;
    return cls(cos(orientation) * length, sin(orientation) * length)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.from_polar_degrees"><code class="name flex">
<span>def <span class="ident">from_polar_degrees</span></span>(<span>length: float, orientation: float) ‑> <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retourne un vecteur issu de la représentation polaire passée en
argument. </p>
<p>La représentation finale du vecteur est toujours selon un
système de coordonnées cartésiennes.</p>
<p>L'orientation est en degrées.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur de la coordonnée polaire. </dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>float</code></dt>
<dd>L'orientation' de la coordonnée polaire. </dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = round(Vect2D.from_polar_degrees(5.0, 90.))
&gt;&gt;&gt; print(v1)
(0.00E+00, 5.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_polar_degrees(cls, length : float, orientation : float) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;Retourne un vecteur issu de la représentation polaire passée en 
    argument. 
    
    La représentation finale du vecteur est toujours selon un 
    système de coordonnées cartésiennes.
    
    L&#39;orientation est en degrées.
    
    Args:
        length (float): La longueur de la coordonnée polaire. 
        orientation (float): L&#39;orientation&#39; de la coordonnée polaire. 

    Exemples:
        &gt;&gt;&gt; v1 = round(Vect2D.from_polar_degrees(5.0, 90.))
        &gt;&gt;&gt; print(v1)
        (0.00E+00, 5.00E+00)
    &#34;&#34;&#34;
    return cls.from_polar(length, radians(orientation))</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.from_random_cartesian"><code class="name flex">
<span>def <span class="ident">from_random_cartesian</span></span>(<span>x_min: float, x_max: float, y_min: float, y_max: float) ‑> <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Crée une nouvelle instance de 'Vect2D' aléatoirement paramétré
dans le système de coordonnées cartésiennes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x_min</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne inférieure sur l'axe des abscisses.</dd>
<dt><strong><code>x_max</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne supérieure sur l'axe des abscisses.</dd>
<dt><strong><code>y_min</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne inférieure sur l'axe des ordonnées.</dd>
<dt><strong><code>y_max</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne supérieure sur l'axe des ordonnées.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D.from_random_cartesian(0., 100., 0, 100.)
&gt;&gt;&gt; print(v1) # doctest: +SKIP
(12.00E+00, 77.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_random_cartesian(cls, x_min : float, x_max : float, y_min : float, y_max : float) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; aléatoirement paramétré 
    dans le système de coordonnées cartésiennes.
    
    Args:
        x_min (float): La borne inférieure sur l&#39;axe des abscisses.
        x_max (float): La borne supérieure sur l&#39;axe des abscisses.
        y_min (float): La borne inférieure sur l&#39;axe des ordonnées.
        y_max (float): La borne supérieure sur l&#39;axe des ordonnées.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D.from_random_cartesian(0., 100., 0, 100.)
        &gt;&gt;&gt; print(v1) # doctest: +SKIP
        (12.00E+00, 77.00E+00)
    &#34;&#34;&#34;    
    vect2d = cls()
    vect2d.randomize_cartesian(x_min, x_max, y_min, y_max)
    return vect2d</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.from_random_normalized"><code class="name flex">
<span>def <span class="ident">from_random_normalized</span></span>(<span>) ‑> <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Crée une nouvelle instance de 'Vect2D' correspondant à vecteur unitaire aléatoire.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D.from_random_normalized()
&gt;&gt;&gt; print() # doctest: +SKIP
(1.00E+00, 0.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_random_normalized(cls) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; correspondant à vecteur unitaire aléatoire.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D.from_random_normalized()
        &gt;&gt;&gt; print() # doctest: +SKIP
        (1.00E+00, 0.00E+00)
    &#34;&#34;&#34;           
    vect2d = cls()
    vect2d.randomize_normalized()
    return vect2d</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.from_random_polar"><code class="name flex">
<span>def <span class="ident">from_random_polar</span></span>(<span>length_min: float, length_max: float, orientation_half_span: float = 6.283185307179586, orientation_reference: float = 0.0) ‑> <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Crée une nouvelle instance de 'Vect2D' aléatoirement paramétré
dans le système de coordonnées polaires.</p>
<p>L'orientation est définie en radians.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length_min</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur inférieure (sur l'axe des distances).</dd>
<dt><strong><code>length_max</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur spérieure (sur l'axe des distances).</dd>
<dt><strong><code>orientation_half_span</code></strong> :&ensp;<code>float</code></dt>
<dd>L'étendu de l'orientation en radians (sur l'axe de rotation). Defaults = tau</dd>
<dt><strong><code>orientation_reference</code></strong> :&ensp;<code>float</code></dt>
<dd>L'angle de référence en radians (sur l'axe de rotation). Defaults = 0.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D.from_random_polar(0., 100., 0., 3.14)
&gt;&gt;&gt; print(v1) # doctest: +SKIP
(12.00E+00, 28.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_random_polar(cls, length_min : float, length_max : float, orientation_half_span : float = tau, orientation_reference : float = 0.) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; aléatoirement paramétré
    dans le système de coordonnées polaires.
    
    L&#39;orientation est définie en radians.
            
    Args:
        length_min (float): La longueur inférieure (sur l&#39;axe des distances).
        length_max (float): La longueur spérieure (sur l&#39;axe des distances).
        orientation_half_span (float): L&#39;étendu de l&#39;orientation en radians (sur l&#39;axe de rotation). Defaults = tau
        orientation_reference (float): L&#39;angle de référence en radians (sur l&#39;axe de rotation). Defaults = 0.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D.from_random_polar(0., 100., 0., 3.14)
        &gt;&gt;&gt; print(v1) # doctest: +SKIP
        (12.00E+00, 28.00E+00)
    &#34;&#34;&#34;      
    vect2d = cls()
    vect2d.randomize_polar(length_min, length_max, orientation_half_span, orientation_reference)
    return vect2d</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.from_random_polar_degrees"><code class="name flex">
<span>def <span class="ident">from_random_polar_degrees</span></span>(<span>length_min: float, length_max: float, orientation_half_span: float = 360.0, orientation_reference: float = 0.0) ‑> <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Crée une nouvelle instance de 'Vect2D' aléatoirement paramétré
dans le système de coordonnées polaires.</p>
<p>L'orientation est définie en degrées.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length_min</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur inférieure (sur l'axe des distances).</dd>
<dt><strong><code>length_max</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur spérieure (sur l'axe des distances).</dd>
<dt><strong><code>orientation_half_span</code></strong> :&ensp;<code>float</code></dt>
<dd>L'étendu de l'orientation en degrées (sur l'axe de rotation). Defaults = 360.</dd>
<dt><strong><code>orientation_reference</code></strong> :&ensp;<code>float</code></dt>
<dd>L'angle de référence en degrées (sur l'axe de rotation). Defaults = 0.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 90.)
&gt;&gt;&gt; print(v1) # doctest: +SKIP
(12.00E+00, 28.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_random_polar_degrees(cls, length_min : float, length_max : float, orientation_half_span : float = 360., orientation_reference : float = 0.) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;Crée une nouvelle instance de &#39;Vect2D&#39; aléatoirement paramétré
    dans le système de coordonnées polaires.
    
    L&#39;orientation est définie en degrées.
            
    Args:
        length_min (float): La longueur inférieure (sur l&#39;axe des distances).
        length_max (float): La longueur spérieure (sur l&#39;axe des distances).
        orientation_half_span (float): L&#39;étendu de l&#39;orientation en degrées (sur l&#39;axe de rotation). Defaults = 360.
        orientation_reference (float): L&#39;angle de référence en degrées (sur l&#39;axe de rotation). Defaults = 0.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 90.)
        &gt;&gt;&gt; print(v1) # doctest: +SKIP
        (12.00E+00, 28.00E+00)
    &#34;&#34;&#34;
    return cls.from_random_polar_degrees(length_min, length_max, radians(orientation_half_span), radians(orientation_reference))</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.from_vect2d"><code class="name flex">
<span>def <span class="ident">from_vect2d</span></span>(<span>other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Création un nouvel objet <code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code> identique à un autre.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>Le vecteur à cloner.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(-1.0, 1.0)
&gt;&gt;&gt; v2 = Vect2D.from_vect2d(v1)
&gt;&gt;&gt; print(v2)
(-1.00E+00, 1.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_vect2d(cls, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;Création un nouvel objet `Vect2D` identique à un autre.
    
    Args:
        other (Vect2D): Le vecteur à cloner.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(-1.0, 1.0)
        &gt;&gt;&gt; v2 = Vect2D.from_vect2d(v1)
        &gt;&gt;&gt; print(v2)
        (-1.00E+00, 1.00E+00)
    &#34;&#34;&#34;
    return cls(other.x, other.y)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.set_string_format"><code class="name flex">
<span>def <span class="ident">set_string_format</span></span>(<span>prefix: str = None, separator: str = None, suffix: str = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Détermine le format du texte lors de la conversion vers une chaîne
de caractères : préfixe, séparateur et suffixe.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>Le text précédant la coordonnées x. Si None, le préfixe reste inchangé. Defaults = None</dd>
<dt><strong><code>separator</code></strong> :&ensp;<code>str</code></dt>
<dd>Le texte entre les coordonnées x et y. Si None, le séparator est laissé inchangé. Defaults = None</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code></dt>
<dd>le texte après la coordonnées y. Si None, le suffixe est laissé inchangé. Defaults = None</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; vect = Vect2D(20000.0, 3.141592654)
&gt;&gt;&gt; print(vect)
(2.00E+04, 3.14E+00)
&gt;&gt;&gt; Vect2D.set_string_format('[[[ ', ' : ', ' ]]]')
&gt;&gt;&gt; print(vect)
[[[ 2.00E+04 : 3.14E+00 ]]]
&gt;&gt;&gt; Vect2D.set_string_format('(', ', ', ')')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_string_format(prefix : str = None, separator : str = None, suffix : str = None) -&gt; None:
    &#34;&#34;&#34;Détermine le format du texte lors de la conversion vers une chaîne 
    de caractères : préfixe, séparateur et suffixe.
    
    Args:
        prefix (str): Le text précédant la coordonnées x. Si None, le préfixe reste inchangé. Defaults = None
        separator (str): Le texte entre les coordonnées x et y. Si None, le séparator est laissé inchangé. Defaults = None
        suffix (str): le texte après la coordonnées y. Si None, le suffixe est laissé inchangé. Defaults = None

    Exemples:
        &gt;&gt;&gt; vect = Vect2D(20000.0, 3.141592654)
        &gt;&gt;&gt; print(vect)
        (2.00E+04, 3.14E+00)
        &gt;&gt;&gt; Vect2D.set_string_format(&#39;[[[ &#39;, &#39; : &#39;, &#39; ]]]&#39;)
        &gt;&gt;&gt; print(vect)
        [[[ 2.00E+04 : 3.14E+00 ]]]
        &gt;&gt;&gt; Vect2D.set_string_format(&#39;(&#39;, &#39;, &#39;, &#39;)&#39;)
    &#34;&#34;&#34;
    if prefix: Vect2D.__string_prefix = prefix
    if separator: Vect2D.__string_separator = separator
    if suffix: Vect2D.__string_suffix = suffix</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.set_value_format"><code class="name flex">
<span>def <span class="ident">set_value_format</span></span>(<span>use_scientific_notation: Optional[bool] = None, trailing_zeros_length: Optional[int] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Détermine le format des réels lors de la conversoin vers une chaîne
de caractères : la représentation des nombres réels x et y.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>use_scientific_notation</code></strong> :&ensp;<code>bool</code></dt>
<dd>Si True, utilise la notation scientifique. Si False, la notation fixe. Si None, la notation reste inchangée. Defaults = None</dd>
<dt><strong><code>trailing_zeros_length</code></strong> :&ensp;<code>int</code></dt>
<dd>Détermine le nombre de 0 après la virgule. Si None, le 'padding' reste inchangé. Defaults = None</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; vect = Vect2D(20000.0, 3.141592654)
&gt;&gt;&gt; print(vect)
(2.00E+04, 3.14E+00)
&gt;&gt;&gt; Vect2D.set_value_format(False, 3)
&gt;&gt;&gt; print(vect)
(20000.000, 3.142)
&gt;&gt;&gt; Vect2D.set_value_format(True, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_value_format(use_scientific_notation : Optional[bool] = None, trailing_zeros_length : Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;Détermine le format des réels lors de la conversoin vers une chaîne 
    de caractères : la représentation des nombres réels x et y.
    
    Args:
        use_scientific_notation (bool): Si True, utilise la notation scientifique. Si False, la notation fixe. Si None, la notation reste inchangée. Defaults = None
        trailing_zeros_length (int): Détermine le nombre de 0 après la virgule. Si None, le &#39;padding&#39; reste inchangé. Defaults = None

    Exemples:
        &gt;&gt;&gt; vect = Vect2D(20000.0, 3.141592654)
        &gt;&gt;&gt; print(vect)
        (2.00E+04, 3.14E+00)
        &gt;&gt;&gt; Vect2D.set_value_format(False, 3)
        &gt;&gt;&gt; print(vect)
        (20000.000, 3.142)
        &gt;&gt;&gt; Vect2D.set_value_format(True, 2)
    &#34;&#34;&#34;
    use_scientific_notation = Vect2D.__string_use_scientific_notation if use_scientific_notation is None else use_scientific_notation
    trailing_zeros_length = Vect2D.__string_trailing_zeros_length if trailing_zeros_length is None else trailing_zeros_length
    Vect2D.__string_value_format = f&#39;.{trailing_zeros_length}{&#34;E&#34; if use_scientific_notation else &#34;f&#34;}&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vect2d.Vect2D.as_dict"><code class="name">var <span class="ident">as_dict</span> : dict[str, int]</code></dt>
<dd>
<div class="desc"><p>Crée et retourne un dictionnaire de deux réels. Le dictionnaire
possède les clés suivantes :
- 'x' : les abscisses
- 'y' : les ordonnées</p>
<p>Ne modifie pas l'instance courante.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
&gt;&gt;&gt; print(v1.as_dict)
{'x': 2.5, 'y': -1.5}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; dict[str, int]:
    &#34;&#34;&#34;Crée et retourne un dictionnaire de deux réels. Le dictionnaire 
    possède les clés suivantes :
    - &#39;x&#39; : les abscisses 
    - &#39;y&#39; : les ordonnées
    
    Ne modifie pas l&#39;instance courante.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
        &gt;&gt;&gt; print(v1.as_dict)
        {&#39;x&#39;: 2.5, &#39;y&#39;: -1.5}
    &#34;&#34;&#34;             
    return { &#39;x&#39;:self.x, &#39;y&#39;:self.y }</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.as_list"><code class="name">var <span class="ident">as_list</span> : list[float, float]</code></dt>
<dd>
<div class="desc"><p>Crée et retourne une liste de deux réels. La liste créée possède
les abscisses et les ordonnées dans l'ordre.</p>
<p>Ne modifie pas l'instance courante.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
&gt;&gt;&gt; print(v1.as_list)
[2.5, -1.5]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_list(self) -&gt; list[float, float]:
    &#34;&#34;&#34;Crée et retourne une liste de deux réels. La liste créée possède 
    les abscisses et les ordonnées dans l&#39;ordre.
    
    Ne modifie pas l&#39;instance courante.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
        &gt;&gt;&gt; print(v1.as_list)
        [2.5, -1.5]
    &#34;&#34;&#34;     
    return [self.x, self.y]</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.as_tuple"><code class="name">var <span class="ident">as_tuple</span> : tuple[float, float]</code></dt>
<dd>
<div class="desc"><p>Crée et retourne un tuple de deux réels. La liste créée possède
les abscisses et les ordonnées dans l'ordre.</p>
<p>Ne modifie pas l'instance courante.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
&gt;&gt;&gt; print(v1.as_tuple)
(2.5, -1.5)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_tuple(self) -&gt; tuple[float, float]:
    &#34;&#34;&#34;Crée et retourne un tuple de deux réels. La liste créée possède 
    les abscisses et les ordonnées dans l&#39;ordre.
    
    Ne modifie pas l&#39;instance courante.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.5, -1.5)
        &gt;&gt;&gt; print(v1.as_tuple)
        (2.5, -1.5)
    &#34;&#34;&#34;     
    return (self.x, self.y)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.chebyshev_length"><code class="name">var <span class="ident">chebyshev_length</span> : float</code></dt>
<dd>
<div class="desc"><p><code>Read only</code></p>
<p>Retourne la distance de Chebyshev.</p>
<p>Cette distance correspond à la distance la plus grande entre les
abscisses et les ordonnées.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
&gt;&gt;&gt; v1.chebyshev_length
5.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def chebyshev_length(self) -&gt; float:
    &#34;&#34;&#34;`Read only`
    
    Retourne la distance de Chebyshev.
    
    Cette distance correspond à la distance la plus grande entre les 
    abscisses et les ordonnées.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
        &gt;&gt;&gt; v1.chebyshev_length
        5.0
    &#34;&#34;&#34;     
    return max(abs(self.x), abs(self.y))</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.flipped"><code class="name">var <span class="ident">flipped</span> : <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>
<div class="desc"><p><code>Read only</code></p>
<p>Retourne une nouvelle instance de 'Vect2D' ayant les coordonnées
permutées.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
&gt;&gt;&gt; print(v1.flipped)
(5.00E+00, 2.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flipped(self) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;`Read only`
    
    Retourne une nouvelle instance de &#39;Vect2D&#39; ayant les coordonnées 
    permutées.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
        &gt;&gt;&gt; print(v1.flipped)
        (5.00E+00, 2.00E+00)
    &#34;&#34;&#34;           
    return Vect2D(self.y, self.x)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.is_defined"><code class="name">var <span class="ident">is_defined</span> : bool</code></dt>
<dd>
<div class="desc"><p><code>Read only</code></p>
<p>Retourne <code>True</code> si le vecteur est défini, <code>False</code> autrement. Un vecteur
indéfini est un vecteur de longueur 0.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
&gt;&gt;&gt; v1.is_defined
True
&gt;&gt;&gt; v1.reset()
&gt;&gt;&gt; v1.is_defined
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_defined(self) -&gt; bool:     
    &#34;&#34;&#34;`Read only`
    
    Retourne `True` si le vecteur est défini, `False` autrement. Un vecteur 
    indéfini est un vecteur de longueur 0.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
        &gt;&gt;&gt; v1.is_defined
        True
        &gt;&gt;&gt; v1.reset()
        &gt;&gt;&gt; v1.is_defined
        False
    &#34;&#34;&#34;
    return not(isclose(self.x, 0.) and isclose(self.y, 0.))</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.is_normalized"><code class="name">var <span class="ident">is_normalized</span> : bool</code></dt>
<dd>
<div class="desc"><p><code>Read only</code></p>
<p>Est-ce que le vecteur est normalisé.</p>
<p>Un vecteur normalisé est un vecteur unitaire (de longueur 1.0).</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v2 = Vect2D(1.0, 0.0)
&gt;&gt;&gt; v1.is_normalized
False
&gt;&gt;&gt; v2.is_normalized
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_normalized(self) -&gt; bool:
    &#34;&#34;&#34;`Read only`
    
    Est-ce que le vecteur est normalisé.
    
    Un vecteur normalisé est un vecteur unitaire (de longueur 1.0).
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v2 = Vect2D(1.0, 0.0)
        &gt;&gt;&gt; v1.is_normalized
        False
        &gt;&gt;&gt; v2.is_normalized
        True
    &#34;&#34;&#34;
    return isclose(self.length_squared, 1.0)    </code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.left_perpendicular"><code class="name">var <span class="ident">left_perpendicular</span> : <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>
<div class="desc"><p><code>Read only</code></p>
<p>Retourne une nouvelle instance de 'Vect2D' représentant une rotation
de 90° vers la gauche.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
&gt;&gt;&gt; print(v1.left_perpendicular)
(-1.00E+00, 2.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property # getter only
def left_perpendicular(self) -&gt; &#39;Vect2D&#39;: # name ?
    &#34;&#34;&#34;`Read only`
    
    Retourne une nouvelle instance de &#39;Vect2D&#39; représentant une rotation 
    de 90° vers la gauche.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
        &gt;&gt;&gt; print(v1.left_perpendicular)
        (-1.00E+00, 2.00E+00)
    &#34;&#34;&#34;             
    return Vect2D(-self.y, self.x)    </code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.length"><code class="name">var <span class="ident">length</span> : float</code></dt>
<dd>
<div class="desc"><p><code>Read &amp; Write</code></p>
<p>La longueur du vecteur.</p>
<p>Correspond à la distance du système de coordonnées polaires.
La métrique retournée correspond à la distance euclidienne.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
&gt;&gt;&gt; v1.length
1.4142135623730951
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self) -&gt; float:
    &#34;&#34;&#34;`Read &amp; Write`
    
    La longueur du vecteur.
    
    Correspond à la distance du système de coordonnées polaires. 
    La métrique retournée correspond à la distance euclidienne.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
        &gt;&gt;&gt; v1.length
        1.4142135623730951
    &#34;&#34;&#34;
    return sqrt(self.length_squared)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.length_squared"><code class="name">var <span class="ident">length_squared</span> : float</code></dt>
<dd>
<div class="desc"><p><code>Read &amp; Write</code></p>
<p>La longueur du vecteur au carré.</p>
<p>Correspond à la distance au carré du système de coordonnées polaires.
La métrique retournée correspond à la distance euclidienne.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(1.0, 2.0)
&gt;&gt;&gt; v1.length_squared
5.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length_squared(self) -&gt; float:
    &#34;&#34;&#34;`Read &amp; Write`
    
    La longueur du vecteur au carré.
    
    Correspond à la distance au carré du système de coordonnées polaires. 
    La métrique retournée correspond à la distance euclidienne.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(1.0, 2.0)
        &gt;&gt;&gt; v1.length_squared
        5.0
    &#34;&#34;&#34;
    return self.x ** 2. + self.y ** 2.</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.manhattan_length"><code class="name">var <span class="ident">manhattan_length</span> : float</code></dt>
<dd>
<div class="desc"><p><code>Read only</code></p>
<p>Retourne la distance de Manhattan.</p>
<p>Cette distance correspond à la distance orthogonale totale à parcourir
considérant chacun des axes : | x | + | y |.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
&gt;&gt;&gt; v1.manhattan_length
7.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def manhattan_length(self) -&gt; float:
    &#34;&#34;&#34;`Read only`
    
    Retourne la distance de Manhattan.
    
    Cette distance correspond à la distance orthogonale totale à parcourir 
    considérant chacun des axes : | x | + | y |.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
        &gt;&gt;&gt; v1.manhattan_length
        7.0
    &#34;&#34;&#34;     
    return abs(self.x) + abs(self.y)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.normalized"><code class="name">var <span class="ident">normalized</span> : <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>
<div class="desc"><p><code>Read only</code></p>
<p>Retourne une nouvelle instance de 'Vect2D' correspondant au vecteur<br>
unitaire du vecteur courant.</p>
<p>Le vecteur doit être défini.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
&gt;&gt;&gt; v2 = v1.normalized
&gt;&gt;&gt; print(v2)
(1.00E+00, 0.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def normalized(self) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;`Read only`
    
    Retourne une nouvelle instance de &#39;Vect2D&#39; correspondant au vecteur  
    unitaire du vecteur courant.
    
    Le vecteur doit être défini.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
        &gt;&gt;&gt; v2 = v1.normalized
        &gt;&gt;&gt; print(v2)
        (1.00E+00, 0.00E+00)
    &#34;&#34;&#34;        
    vect = Vect2D(self.x, self.y)
    vect.normalize()
    return vect</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.orientation"><code class="name">var <span class="ident">orientation</span> : float</code></dt>
<dd>
<div class="desc"><p><code>Read &amp; Write</code></p>
<p>L'orientation du vecteur.</p>
<p>Correspond à l'orientation du système de coordonnées polaires.
La métrique retournée est l'angle en radians.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
&gt;&gt;&gt; v1.orientation
0.7853981633974483
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def orientation(self) -&gt; float:
    &#34;&#34;&#34;`Read &amp; Write`
    
    L&#39;orientation du vecteur.
    
    Correspond à l&#39;orientation du système de coordonnées polaires. 
    La métrique retournée est l&#39;angle en radians.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
        &gt;&gt;&gt; v1.orientation
        0.7853981633974483
    &#34;&#34;&#34;        
    return atan2(self.y, self.x)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.orientation_degrees"><code class="name">var <span class="ident">orientation_degrees</span> : float</code></dt>
<dd>
<div class="desc"><p><code>Read &amp; Write</code></p>
<p>L'orientation du vecteur.</p>
<p>Correspond à l'orientation du système de coordonnées polaires.
La métrique retournée est l'angle en degrées.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
&gt;&gt;&gt; v1.orientation_degrees
45.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def orientation_degrees(self) -&gt; float:
    &#34;&#34;&#34;`Read &amp; Write`
    
    L&#39;orientation du vecteur.
    
    Correspond à l&#39;orientation du système de coordonnées polaires. 
    La métrique retournée est l&#39;angle en degrées.
            
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(1.0, 1.0)
        &gt;&gt;&gt; v1.orientation_degrees
        45.0
    &#34;&#34;&#34;
    return degrees(atan2(self.y, self.x))</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.right_perpendicular"><code class="name">var <span class="ident">right_perpendicular</span> : <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>
<div class="desc"><p><code>Read only</code></p>
<p>Retourne une nouvelle instance de 'Vect2D' représentant une rotation
de 90° vers la droite.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
&gt;&gt;&gt; print(v1.right_perpendicular)
(1.00E+00, -2.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def right_perpendicular(self) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;`Read only`
    
    Retourne une nouvelle instance de &#39;Vect2D&#39; représentant une rotation 
    de 90° vers la droite.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
        &gt;&gt;&gt; print(v1.right_perpendicular)
        (1.00E+00, -2.00E+00)
    &#34;&#34;&#34;             
    return Vect2D(self.y, -self.x)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p><code>Read &amp; Write</code></p>
<p>La valeur des abscisses selon le système de coordonnées cartésiennes.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v1.x = 5.0
&gt;&gt;&gt; print(v1)
(5.00E+00, 0.00E+00)
</code></pre></div>
</dd>
<dt id="vect2d.Vect2D.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p><code>Read &amp; Write</code></p>
<p>La valeur des ordonnées selon le système de coordonnées cartésiennes.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v1.y = -5.0
&gt;&gt;&gt; print(v1)
(0.00E+00, -5.00E+00)
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vect2d.Vect2D.angle_between"><code class="name flex">
<span>def <span class="ident">angle_between</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne l'angle créé avec le vecteur passé en argument.</p>
<p>L'angle est en radians.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>L'autre vecteur formant l'angle.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from math import isclose, pi, degrees
&gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
&gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
&gt;&gt;&gt; isclose(v1.angle_between(v2), pi / 8.0)
True
&gt;&gt;&gt; round(degrees(v1.angle_between(v2)), 1)
22.5
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angle_between(self, other : &#39;Vect2D&#39;) -&gt; float: # in radians
    &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument.
    
    L&#39;angle est en radians.
    
    Args:
        other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
    
    Exemples:
        &gt;&gt;&gt; from math import isclose, pi, degrees
        &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
        &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
        &gt;&gt;&gt; isclose(v1.angle_between(v2), pi / 8.0)
        True
        &gt;&gt;&gt; round(degrees(v1.angle_between(v2)), 1)
        22.5
    &#34;&#34;&#34;
    return acos(self.dot(other) / sqrt(self.length_squared * other.length_squared))</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.angle_between_degrees"><code class="name flex">
<span>def <span class="ident">angle_between_degrees</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne l'angle créé avec le vecteur passé en argument.</p>
<p>L'angle est en degrées.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>L'autre vecteur formant l'angle.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from math import isclose, pi, degrees
&gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
&gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
&gt;&gt;&gt; isclose(v1.angle_between_degrees(v2), 22.5)
True
&gt;&gt;&gt; round(v1.angle_between_degrees(v2),1)
22.5
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angle_between_degrees(self, other : &#39;Vect2D&#39;) -&gt; float:
    &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument.
    
    L&#39;angle est en degrées.
    
    Args:
        other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
    
    Exemples:
        &gt;&gt;&gt; from math import isclose, pi, degrees
        &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
        &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
        &gt;&gt;&gt; isclose(v1.angle_between_degrees(v2), 22.5)
        True
        &gt;&gt;&gt; round(v1.angle_between_degrees(v2),1)
        22.5
    &#34;&#34;&#34;
    return degrees(self.angle_between(other))</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.angle_disparity"><code class="name flex">
<span>def <span class="ident">angle_disparity</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne l'angle créé avec le vecteur passé en argument.
La direction de l'angle est donné contrairement à la fonction
angle_between :
- si l'angle est négatif, l'autre vecteur se trouve dans le sens
inverse de rotation
- si l'angle est positif, l'autre vecteur se trouve dans le sens
de rotation</p>
<p>L'angle est en radians.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>L'autre vecteur formant l'angle.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from math import isclose, pi, degrees
&gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
&gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
&gt;&gt;&gt; isclose(v1.angle_disparity(v2), pi / 8.0)
True
&gt;&gt;&gt; round(degrees(v1.angle_disparity(v2)), 1)
22.5
&gt;&gt;&gt; round(degrees(v2.angle_disparity(v1)), 1)
-22.5
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angle_disparity(self, other : &#39;Vect2D&#39;) -&gt; float: # angle in radians with direction
    &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument. 
    La direction de l&#39;angle est donné contrairement à la fonction 
    angle_between :
     - si l&#39;angle est négatif, l&#39;autre vecteur se trouve dans le sens 
       inverse de rotation
     - si l&#39;angle est positif, l&#39;autre vecteur se trouve dans le sens 
       de rotation
    
    L&#39;angle est en radians.
    
    Args:
        other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
    
    Exemples:
        &gt;&gt;&gt; from math import isclose, pi, degrees
        &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
        &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
        &gt;&gt;&gt; isclose(v1.angle_disparity(v2), pi / 8.0)
        True
        &gt;&gt;&gt; round(degrees(v1.angle_disparity(v2)), 1)
        22.5
        &gt;&gt;&gt; round(degrees(v2.angle_disparity(v1)), 1)
        -22.5
    &#34;&#34;&#34;
    return atan2(self.cross(other), self.x * other.x + self.y * other.y)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.angle_disparity_degrees"><code class="name flex">
<span>def <span class="ident">angle_disparity_degrees</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne l'angle créé avec le vecteur passé en argument.
La direction de l'angle est donné contrairement à la fonction
angle_between :
- si l'angle est négatif, l'autre vecteur se trouve dans le sens
inverse de la rotation
- si l'angle est positif, l'autre vecteur se trouve dans le sens
de la rotation</p>
<p>L'angle est en degrées.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>L'autre vecteur formant l'angle.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from math import isclose
&gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
&gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
&gt;&gt;&gt; isclose(v1.angle_disparity_degrees(v2), 22.5)
True
&gt;&gt;&gt; round(v1.angle_disparity_degrees(v2), 1)
22.5
&gt;&gt;&gt; round(v2.angle_disparity_degrees(v1), 1)
-22.5
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angle_disparity_degrees(self, other : &#39;Vect2D&#39;) -&gt; float: # angle in radians with direction
    &#34;&#34;&#34;Retourne l&#39;angle créé avec le vecteur passé en argument. 
    La direction de l&#39;angle est donné contrairement à la fonction 
    angle_between :
     - si l&#39;angle est négatif, l&#39;autre vecteur se trouve dans le sens 
       inverse de la rotation
     - si l&#39;angle est positif, l&#39;autre vecteur se trouve dans le sens 
       de la rotation
    
    L&#39;angle est en degrées.
    
    Args:
        other (Vect2D): L&#39;autre vecteur formant l&#39;angle.
    
    Exemples:
        &gt;&gt;&gt; from math import isclose
        &gt;&gt;&gt; v1 = Vect2D(5.0, 5.0)
        &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(5.0, 67.5)
        &gt;&gt;&gt; isclose(v1.angle_disparity_degrees(v2), 22.5)
        True
        &gt;&gt;&gt; round(v1.angle_disparity_degrees(v2), 1)
        22.5
        &gt;&gt;&gt; round(v2.angle_disparity_degrees(v1), 1)
        -22.5
    &#34;&#34;&#34;
    return degrees(self.angle_disparity(other))</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.clamp_length"><code class="name flex">
<span>def <span class="ident">clamp_length</span></span>(<span>self, min_length: float, max_length: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Borne la longueur du vecteur. </p>
<p>La longueur est bornée aux limites inférieures et supérieures.</p>
<p>0 &lt; min_length &lt; max_length</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>min_length</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur minimum que le vecteur peut
avoir. Cette longueur doit être strictement positive et
inférieure à la longueur maximum. </dd>
<dt><strong><code>max_length</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur maximum que le vecteur peut
avoir. Cette longueur doit être strictement positive et
supérieure à la longueur minimum. </dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
&gt;&gt;&gt; v1.clamp_length(3.0, 4.0)
&gt;&gt;&gt; print(v1)
(4.00E+00, 0.00E+00)
&gt;&gt;&gt; v1.clamp_length(3.0, 5.0)
&gt;&gt;&gt; print(v1)
(4.00E+00, 0.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clamp_length(self, min_length : float, max_length : float) -&gt; None:
    &#34;&#34;&#34;Borne la longueur du vecteur. 
    
    La longueur est bornée aux limites inférieures et supérieures.
    
    0 &lt; min_length &lt; max_length

    Args:
        min_length (float): La longueur minimum que le vecteur peut 
            avoir. Cette longueur doit être strictement positive et 
            inférieure à la longueur maximum. 
        max_length (float): La longueur maximum que le vecteur peut 
            avoir. Cette longueur doit être strictement positive et 
            supérieure à la longueur minimum. 

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
        &gt;&gt;&gt; v1.clamp_length(3.0, 4.0)
        &gt;&gt;&gt; print(v1)
        (4.00E+00, 0.00E+00)
        &gt;&gt;&gt; v1.clamp_length(3.0, 5.0)
        &gt;&gt;&gt; print(v1)
        (4.00E+00, 0.00E+00)
    &#34;&#34;&#34;
    length_sqared = self.length_squared
    if length_sqared &lt; min_length * min_length:
        self.length = min_length
    elif length_sqared &gt; max_length * max_length:
        self.length = max_length</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.clamp_length_squared"><code class="name flex">
<span>def <span class="ident">clamp_length_squared</span></span>(<span>self, min_length_squared: float, max_length_squared: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Borne la longueur au carré du vecteur. </p>
<p>La longueur au carré est bornée aux limites inférieures et supérieures.</p>
<p>0 &lt; min_length_squared &lt; max_length_squared</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>min_length_squared</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur au carré minimum que le
vecteur peut avoir. Cette longueur doit être strictement
positive et inférieure à la longueur au carré maximum. </dd>
<dt><strong><code>max_length_squared</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur au carré maximum que le
vecteur peut avoir. Cette longueur doit être strictement
positive et supérieure à la longueur au carré minimum. </dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
&gt;&gt;&gt; v1.clamp_length_squared(9.0, 16.0)
&gt;&gt;&gt; print(v1)
(4.00E+00, 0.00E+00)
&gt;&gt;&gt; v1.clamp_length_squared(9.0, 25.0)
&gt;&gt;&gt; print(v1)
(4.00E+00, 0.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clamp_length_squared(self, min_length_squared : float, max_length_squared : float) -&gt; None:
    &#34;&#34;&#34;Borne la longueur au carré du vecteur. 
    
    La longueur au carré est bornée aux limites inférieures et supérieures.
    
    0 &lt; min_length_squared &lt; max_length_squared
    
    Args:
        min_length_squared (float): La longueur au carré minimum que le 
            vecteur peut avoir. Cette longueur doit être strictement 
            positive et inférieure à la longueur au carré maximum. 
        max_length_squared (float): La longueur au carré maximum que le 
            vecteur peut avoir. Cette longueur doit être strictement 
            positive et supérieure à la longueur au carré minimum. 

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
        &gt;&gt;&gt; v1.clamp_length_squared(9.0, 16.0)
        &gt;&gt;&gt; print(v1)
        (4.00E+00, 0.00E+00)
        &gt;&gt;&gt; v1.clamp_length_squared(9.0, 25.0)
        &gt;&gt;&gt; print(v1)
        (4.00E+00, 0.00E+00)
    &#34;&#34;&#34;
    length_squared = self.length_squared
    if length_squared &lt; min_length_squared:
        self.length_squared = min_length_squared
    elif length_squared &gt; max_length_squared:
        self.length_squared = max_length_squared</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.clamp_x"><code class="name flex">
<span>def <span class="ident">clamp_x</span></span>(<span>self, x_min: float, x_max: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Borne l'abscisse entre deux limites.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x_min</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne inférieure.</dd>
<dt><strong><code>x_max</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne supérieure.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
&gt;&gt;&gt; v1.clamp_x(2.5, 5.0)
&gt;&gt;&gt; print(v1)
(2.50E+00, 0.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clamp_x(self, x_min : float, x_max : float) -&gt; None:
    &#34;&#34;&#34;Borne l&#39;abscisse entre deux limites.
    
    Args:
        x_min (float): La borne inférieure.
        x_max (float): La borne supérieure.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
        &gt;&gt;&gt; v1.clamp_x(2.5, 5.0)
        &gt;&gt;&gt; print(v1)
        (2.50E+00, 0.00E+00)
    &#34;&#34;&#34;             
    self.x = Vect2D.__clamp(x_min, self.x, x_max)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.clamp_y"><code class="name flex">
<span>def <span class="ident">clamp_y</span></span>(<span>self, y_min: float, y_max: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Borne l'ordonnée entre deux limites.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y_min</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne inférieure.</dd>
<dt><strong><code>y_max</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne supérieure.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
&gt;&gt;&gt; v1.clamp_y(5.0, 10.0)
&gt;&gt;&gt; print(v1)
(2.00E+00, 5.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clamp_y(self, y_min : float, y_max : float) -&gt; None:
    &#34;&#34;&#34;Borne l&#39;ordonnée entre deux limites.
    
    Args:
        y_min (float): La borne inférieure.
        y_max (float): La borne supérieure.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
        &gt;&gt;&gt; v1.clamp_y(5.0, 10.0)
        &gt;&gt;&gt; print(v1)
        (2.00E+00, 5.00E+00)
    &#34;&#34;&#34;             
    self.y = Vect2D.__clamp(y_min, self.y, y_max)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ‑> <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retourne une copie (deepcopy) du vecteur. </p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(3.14, 2.81)
&gt;&gt;&gt; v2 = v1.copy()
&gt;&gt;&gt; print(v2)
(3.14E+00, 2.81E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;Retourne une copie (deepcopy) du vecteur. 
            
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(3.14, 2.81)
        &gt;&gt;&gt; v2 = v1.copy()
        &gt;&gt;&gt; print(v2)
        (3.14E+00, 2.81E+00)
    &#34;&#34;&#34;        
    return Vect2D(self.x, self.y)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.copy_from"><code class="name flex">
<span>def <span class="ident">copy_from</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Copie les coordonnées x et y d'un vecteur source vers celui-ci.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>Le vecteur source.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v2 = Vect2D(-2.0, 1.5)
&gt;&gt;&gt; v1.copy_from(v2)
&gt;&gt;&gt; print(v1)
(-2.00E+00, 1.50E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_from(self, other : &#39;Vect2D&#39;) -&gt; None:
    &#34;&#34;&#34;Copie les coordonnées x et y d&#39;un vecteur source vers celui-ci.
    
    Args:
        other (Vect2D): Le vecteur source.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v2 = Vect2D(-2.0, 1.5)
        &gt;&gt;&gt; v1.copy_from(v2)
        &gt;&gt;&gt; print(v1)
        (-2.00E+00, 1.50E+00)
    &#34;&#34;&#34;
    self.x, self.y = other.x, other.y</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.copy_to"><code class="name flex">
<span>def <span class="ident">copy_to</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Copie les coordonnées courantes x et y vers un autre vecteur.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>Le vecteur cible.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v2 = Vect2D(2.0, -1.5)
&gt;&gt;&gt; v2.copy_to(v1)
&gt;&gt;&gt; print(v1)
(2.00E+00, -1.50E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_to(self, other : &#39;Vect2D&#39;) -&gt; None:
    &#34;&#34;&#34;Copie les coordonnées courantes x et y vers un autre vecteur.
    
    Args:
        other (Vect2D): Le vecteur cible.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v2 = Vect2D(2.0, -1.5)
        &gt;&gt;&gt; v2.copy_to(v1)
        &gt;&gt;&gt; print(v1)
        (2.00E+00, -1.50E+00)
    &#34;&#34;&#34;
    other.x, other.y = self.x, self.y</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.cross"><code class="name flex">
<span>def <span class="ident">cross</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne le produit vectoriel de ce vecteur avec celui passé en
argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>L'autre vecteur.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, -5.0)
&gt;&gt;&gt; v2 = Vect2D(-3.0, 2.0)
&gt;&gt;&gt; v1.cross(v2)
-11.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross(self, other : &#39;Vect2D&#39;) -&gt; float:
    &#34;&#34;&#34;Retourne le produit vectoriel de ce vecteur avec celui passé en 
    argument.
    
    Args:
        other (Vect2D): L&#39;autre vecteur.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, -5.0)
        &gt;&gt;&gt; v2 = Vect2D(-3.0, 2.0)
        &gt;&gt;&gt; v1.cross(v2)
        -11.0
    &#34;&#34;&#34;        
    return self.x * other.y - self.y * other.x</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.distance_from"><code class="name flex">
<span>def <span class="ident">distance_from</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne la distance euclidienne entre ce vecteur et celui
passé en argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>L'autre vecteur dont la distance est à évaluer.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
&gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
&gt;&gt;&gt; v1.distance_from(v2)
5.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_from(self, other : &#39;Vect2D&#39;) -&gt; float:
    &#34;&#34;&#34;Retourne la distance euclidienne entre ce vecteur et celui 
    passé en argument.
    
    Args:
        other (Vect2D): L&#39;autre vecteur dont la distance est à évaluer.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
        &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
        &gt;&gt;&gt; v1.distance_from(v2)
        5.0
    &#34;&#34;&#34;        
    return sqrt(self.distance_squared_from(other))</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.distance_squared_from"><code class="name flex">
<span>def <span class="ident">distance_squared_from</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne la distance euclidienne au carré entre ce vecteur et
celui passé en argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>L'autre vecteur dont la distance est à évaluer.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
&gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
&gt;&gt;&gt; v1.distance_squared_from(v2)
25.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_squared_from(self, other : &#39;Vect2D&#39;) -&gt; float:
    &#34;&#34;&#34;Retourne la distance euclidienne au carré entre ce vecteur et 
    celui passé en argument.
    
    Args:
        other (Vect2D): L&#39;autre vecteur dont la distance est à évaluer.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
        &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
        &gt;&gt;&gt; v1.distance_squared_from(v2)
        25.0
    &#34;&#34;&#34;        
    return (self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.dot"><code class="name flex">
<span>def <span class="ident">dot</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne le produit scalaire de ce vecteur avec celui passé en
argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>L'autre vecteur.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, -5.0)
&gt;&gt;&gt; v2 = Vect2D(-3.0, 2.0)
&gt;&gt;&gt; v1.dot(v2)
-16.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dot(self, other : &#39;Vect2D&#39;) -&gt; float:
    &#34;&#34;&#34;Retourne le produit scalaire de ce vecteur avec celui passé en 
    argument.
    
    Args:
        other (Vect2D): L&#39;autre vecteur.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, -5.0)
        &gt;&gt;&gt; v2 = Vect2D(-3.0, 2.0)
        &gt;&gt;&gt; v1.dot(v2)
        -16.0
    &#34;&#34;&#34;
    return self.x * other.x + self.y * other.y</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.flip"><code class="name flex">
<span>def <span class="ident">flip</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Permute les valeurs x et y.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
&gt;&gt;&gt; v1.flip()
&gt;&gt;&gt; print(v1)
(5.00E+00, 2.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip(self) -&gt; None:
    &#34;&#34;&#34;Permute les valeurs x et y.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 5.0)
        &gt;&gt;&gt; v1.flip()
        &gt;&gt;&gt; print(v1)
        (5.00E+00, 2.00E+00)
    &#34;&#34;&#34;
    self.x, self.y = self.y, self.x</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.is_forming_accute_angle_with"><code class="name flex">
<span>def <span class="ident">is_forming_accute_angle_with</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne 'True' si ce vecteur et celui passé en argument forment
un angle aigu. Sinon retourne 'False'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>L'autre vecteur à comparer.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D.from_polar_degrees(10.0, 45.0)
&gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(10.0, 75.0)
&gt;&gt;&gt; v3 = Vect2D.from_polar_degrees(10.0, 185.0)
&gt;&gt;&gt; v1.is_forming_accute_angle_with(v2)
True
&gt;&gt;&gt; v1.is_forming_accute_angle_with(v3)
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_forming_accute_angle_with(self, other : &#39;Vect2D&#39;) -&gt; bool: # the ~ same direction : acute angle 0 &lt;= theta &lt;= 90
    &#34;&#34;&#34;Retourne &#39;True&#39; si ce vecteur et celui passé en argument forment 
    un angle aigu. Sinon retourne &#39;False&#39;.
    
    Args:
        other (Vect2D): L&#39;autre vecteur à comparer.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D.from_polar_degrees(10.0, 45.0)
        &gt;&gt;&gt; v2 = Vect2D.from_polar_degrees(10.0, 75.0)
        &gt;&gt;&gt; v3 = Vect2D.from_polar_degrees(10.0, 185.0)
        &gt;&gt;&gt; v1.is_forming_accute_angle_with(v2)
        True
        &gt;&gt;&gt; v1.is_forming_accute_angle_with(v3)
        False
    &#34;&#34;&#34;
    return self.dot(other) &gt; 0.0</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.is_forming_obtuse_angle_with"><code class="name flex">
<span>def <span class="ident">is_forming_obtuse_angle_with</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_forming_obtuse_angle_with(self, other : &#39;Vect2D&#39;) -&gt; bool: # the ~ opposite direction : obtuse angle 90 &lt;= theta &lt;= 180
    return self.dot(other) &lt; 0.0</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.is_parallel_to"><code class="name flex">
<span>def <span class="ident">is_parallel_to</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne 'True' si ce vecteur est perpendiculaire à celui
passé en argument. Sinon retourne 'False'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>L'autre vecteur à comparer.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
&gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
&gt;&gt;&gt; v1.is_parallel_to(v2)
False
&gt;&gt;&gt; v1.is_parallel_to(v1.right_perpendicular.right_perpendicular)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_parallel_to(self, other : &#39;Vect2D&#39;) -&gt; bool:
    &#34;&#34;&#34;Retourne &#39;True&#39; si ce vecteur est perpendiculaire à celui 
    passé en argument. Sinon retourne &#39;False&#39;.
    
    Args:
        other (Vect2D): L&#39;autre vecteur à comparer.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
        &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
        &gt;&gt;&gt; v1.is_parallel_to(v2)
        False
        &gt;&gt;&gt; v1.is_parallel_to(v1.right_perpendicular.right_perpendicular)
        True
    &#34;&#34;&#34;
    return isclose(self.cross(other), 0.0)
    #return self.is_perpendicular_to(other.right_perpendicular)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.is_perpendicular_to"><code class="name flex">
<span>def <span class="ident">is_perpendicular_to</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne 'True' si ce vecteur est perpendiculaire à celui
passé en argument. Sinon retourne 'False'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>L'autre vecteur à comparer.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
&gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
&gt;&gt;&gt; v1.is_perpendicular_to(v2)
False
&gt;&gt;&gt; v1.is_perpendicular_to(v1.right_perpendicular)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_perpendicular_to(self, other : &#39;Vect2D&#39;) -&gt; bool:
    &#34;&#34;&#34;Retourne &#39;True&#39; si ce vecteur est perpendiculaire à celui 
    passé en argument. Sinon retourne &#39;False&#39;.
    
    Args:
        other (Vect2D): L&#39;autre vecteur à comparer.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(8.0, -2.0)
        &gt;&gt;&gt; v2 = Vect2D(12.0, -5.0)
        &gt;&gt;&gt; v1.is_perpendicular_to(v2)
        False
        &gt;&gt;&gt; v1.is_perpendicular_to(v1.right_perpendicular)
        True
    &#34;&#34;&#34;         
    return isclose(self.dot(other), 0.0)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.limit_length"><code class="name flex">
<span>def <span class="ident">limit_length</span></span>(<span>self, max_length: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Limite la longueur du vecteur. </p>
<p>Si la longueur est plus petite que la limite, le vecteur reste
inchangé. Si la longueur est plus grande, le vecteur est limité
à la longueur maximum indiquée. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>max_length</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur maximum que le vecteur peut </dd>
</dl>
<p>avoir. Cette longueur doit être strictement positive.
(max_length_squared &gt; 0.0)</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(0.0, 5.0)
&gt;&gt;&gt; v1.limit_length(3.0)
&gt;&gt;&gt; print(round(v1))
(0.00E+00, 3.00E+00)
&gt;&gt;&gt; v1.limit_length(5.0)
&gt;&gt;&gt; print(round(v1))
(0.00E+00, 3.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit_length(self, max_length : float) -&gt; None:
    &#34;&#34;&#34;Limite la longueur du vecteur. 
    
    Si la longueur est plus petite que la limite, le vecteur reste 
    inchangé. Si la longueur est plus grande, le vecteur est limité 
    à la longueur maximum indiquée. 
    
    Args:
        max_length (float): La longueur maximum que le vecteur peut 
        avoir. Cette longueur doit être strictement positive.
        (max_length_squared &gt; 0.0)

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(0.0, 5.0)
        &gt;&gt;&gt; v1.limit_length(3.0)
        &gt;&gt;&gt; print(round(v1))
        (0.00E+00, 3.00E+00)
        &gt;&gt;&gt; v1.limit_length(5.0)
        &gt;&gt;&gt; print(round(v1))
        (0.00E+00, 3.00E+00)
    &#34;&#34;&#34;
    if self.length_squared &gt; max_length * max_length:
        self.length = max_length</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.limit_length_squared"><code class="name flex">
<span>def <span class="ident">limit_length_squared</span></span>(<span>self, max_length_squared: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Limite la longueur au carré du vecteur. </p>
<p>Si la longueur au carré est plus petite que la limite, le vecteur
reste inchangé. Si la longueur au carré est plus grande, le vecteur
est limité à la longueur au carré maximum indiquée. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>max_length_squared</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur au carré maximum que le </dd>
</dl>
<p>vecteur peut avoir. Cette longueur doit être strictement positive.
(max_length_squared &gt; 0.0)</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
&gt;&gt;&gt; v1.limit_length_squared(9.0)
&gt;&gt;&gt; print(v1)
(3.00E+00, 0.00E+00)
&gt;&gt;&gt; v1.limit_length_squared(25.0)
&gt;&gt;&gt; print(v1)
(3.00E+00, 0.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit_length_squared(self, max_length_squared : float) -&gt; None:
    &#34;&#34;&#34;Limite la longueur au carré du vecteur. 
    
    Si la longueur au carré est plus petite que la limite, le vecteur 
    reste inchangé. Si la longueur au carré est plus grande, le vecteur 
    est limité à la longueur au carré maximum indiquée. 
    
    Args:
        max_length_squared (float): La longueur au carré maximum que le 
        vecteur peut avoir. Cette longueur doit être strictement positive.
        (max_length_squared &gt; 0.0)

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(5.0, 0.0)
        &gt;&gt;&gt; v1.limit_length_squared(9.0)
        &gt;&gt;&gt; print(v1)
        (3.00E+00, 0.00E+00)
        &gt;&gt;&gt; v1.limit_length_squared(25.0)
        &gt;&gt;&gt; print(v1)
        (3.00E+00, 0.00E+00)
    &#34;&#34;&#34;
    if self.length_squared &gt; max_length_squared:
        self.length_squared = max_length_squared</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.minkowski_length"><code class="name flex">
<span>def <span class="ident">minkowski_length</span></span>(<span>self, order: float = 2.0) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne la distance de Minkowski.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>float</code></dt>
<dd>Le coefficient de puissance utilisé. Defaults = 2.0</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
&gt;&gt;&gt; v1.minkowski_length(1)
3.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minkowski_length(self, order : float = 2.) -&gt; float:
    &#34;&#34;&#34;Retourne la distance de Minkowski.
    
    Args:
        order (float): Le coefficient de puissance utilisé. Defaults = 2.0

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 1.0)
        &gt;&gt;&gt; v1.minkowski_length(1)
        3.0
    &#34;&#34;&#34;               
    return (abs(self.x) ** order + abs(self.y) ** order) ** (1. / order)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Modifie le vecteur courant pour qu'il soit unitaire.
Cette transformation garde l'angle du vecteur.</p>
<p>Le vecteur doit être défini.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
&gt;&gt;&gt; v1.normalize()
&gt;&gt;&gt; print(v1)
(1.00E+00, 0.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(self) -&gt; None:
    &#34;&#34;&#34;Modifie le vecteur courant pour qu&#39;il soit unitaire.
    Cette transformation garde l&#39;angle du vecteur.
    
    Le vecteur doit être défini.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 0.0)
        &gt;&gt;&gt; v1.normalize()
        &gt;&gt;&gt; print(v1)
        (1.00E+00, 0.00E+00)
    &#34;&#34;&#34;
    if self.is_defined:
        norm = self.length
        self.x /= norm
        self.y /= norm
    else:
        raise RuntimeError(&#39;cannot normalize a non defined vector&#39;)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.projection_analysis"><code class="name flex">
<span>def <span class="ident">projection_analysis</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> tuple[float, '<a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>', float, '<a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>']</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne l'analyse complète de la projection de ce vecteur sur le vecteur passé
en argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>Le vecteur sur lequel est projeté le vecteur </dd>
</dl>
<p>courant.</p>
<h2 id="returns">Returns</h2>
<p>un tuple contenant :
- la projection scalaire
- la projection vectorielle
- la réjection scalaire
- la réjection vectorielle</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
&gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
&gt;&gt;&gt; analysis = v1.projection_analysis(v2)
&gt;&gt;&gt; print(f'Projection : {analysis[0]} | {analysis[1]}')
Projection : 3.0 | (3.00E+00, 0.00E+00)
&gt;&gt;&gt; print(f'Réjection : {analysis[2]} | {analysis[3]}')
Réjection : 1.0 | (0.00E+00, 1.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projection_analysis(self, other : &#39;Vect2D&#39;) -&gt; tuple[float, &#39;Vect2D&#39;, float, &#39;Vect2D&#39;]:
    &#34;&#34;&#34;Retourne l&#39;analyse complète de la projection de ce vecteur sur le vecteur passé 
    en argument.
    
    Args:
        other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
        courant.

    Returns:
        un tuple contenant :
         - la projection scalaire
         - la projection vectorielle
         - la réjection scalaire
         - la réjection vectorielle
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
        &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
        &gt;&gt;&gt; analysis = v1.projection_analysis(v2)
        &gt;&gt;&gt; print(f&#39;Projection : {analysis[0]} | {analysis[1]}&#39;)
        Projection : 3.0 | (3.00E+00, 0.00E+00)
        &gt;&gt;&gt; print(f&#39;Réjection : {analysis[2]} | {analysis[3]}&#39;)
        Réjection : 1.0 | (0.00E+00, 1.00E+00)
    &#34;&#34;&#34;             
    scalar_proj = self.scalar_projection(other)
    vector_proj = scalar_proj * other.normalized
    scalar_rej = self.scalar_rejection(other)
    vector_rej = self - vector_proj
    
    return (scalar_proj, vector_proj, scalar_rej, vector_rej)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.randomize_cartesian"><code class="name flex">
<span>def <span class="ident">randomize_cartesian</span></span>(<span>self, x_min: float, x_max: float, y_min: float, y_max: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Modifie le vecteur courant de façon à créer un vecteur aléatoire
paramétré dans le système de coordonnées cartésiennes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x_min</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne inférieure sur l'axe des abscisses.</dd>
<dt><strong><code>x_max</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne supérieure sur l'axe des abscisses.</dd>
<dt><strong><code>y_min</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne inférieure sur l'axe des ordonnées.</dd>
<dt><strong><code>y_max</code></strong> :&ensp;<code>float</code></dt>
<dd>La borne supérieure sur l'axe des ordonnées.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v1.randomize_cartesian(0., 100., 0, 100.)
&gt;&gt;&gt; print(v1) # doctest: +SKIP
(12.00E+00, 77.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def randomize_cartesian(self, x_min : float, x_max : float, y_min : float, y_max : float) -&gt; None:
    &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur aléatoire 
    paramétré dans le système de coordonnées cartésiennes.
    
    Args:
        x_min (float): La borne inférieure sur l&#39;axe des abscisses.
        x_max (float): La borne supérieure sur l&#39;axe des abscisses.
        y_min (float): La borne inférieure sur l&#39;axe des ordonnées.
        y_max (float): La borne supérieure sur l&#39;axe des ordonnées.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v1.randomize_cartesian(0., 100., 0, 100.)
        &gt;&gt;&gt; print(v1) # doctest: +SKIP
        (12.00E+00, 77.00E+00)
    &#34;&#34;&#34;                
    self.x = uniform(x_min, x_max)
    self.y = uniform(y_min, y_max)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.randomize_normalized"><code class="name flex">
<span>def <span class="ident">randomize_normalized</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Modifie le vecteur courant de façon à créer un vecteur unitaire aléatoire.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v1.randomize_normalized()
&gt;&gt;&gt; print(v1) # doctest: +SKIP
(1.00E+00, 0.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def randomize_normalized(self) -&gt; None:
    &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur unitaire aléatoire.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v1.randomize_normalized()
        &gt;&gt;&gt; print(v1) # doctest: +SKIP
        (1.00E+00, 0.00E+00)
    &#34;&#34;&#34;        
    self.set_polar(1.0, uniform(0., tau))</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.randomize_polar"><code class="name flex">
<span>def <span class="ident">randomize_polar</span></span>(<span>self, length_min: float, length_max: float, orientation_half_span: float = 6.283185307179586, orientation_reference: float = 0.0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Modifie le vecteur courant de façon à créer un vecteur aléatoire
paramétré dans le système de coordonnées polaires.</p>
<p>L'orientation est définie en radians.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length_min</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur inférieure (sur l'axe des distances).</dd>
<dt><strong><code>length_max</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur spérieure (sur l'axe des distances).</dd>
<dt><strong><code>orientation_half_span</code></strong> :&ensp;<code>float</code></dt>
<dd>L'étendu de l'orientation en radians (sur l'axe de rotation). Defaults = tau</dd>
<dt><strong><code>orientation_reference</code></strong> :&ensp;<code>float</code></dt>
<dd>L'angle de référence en radians (sur l'axe de rotation). Defaults = 0.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 3.14)
&gt;&gt;&gt; print(v1) # doctest: +SKIP
(12.00E+00, 28.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def randomize_polar(self, length_min : float, length_max : float, orientation_half_span  : float = tau, orientation_reference : float = 0.) -&gt; None:
    &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur aléatoire 
    paramétré dans le système de coordonnées polaires.
    
    L&#39;orientation est définie en radians.
            
    Args:
        length_min (float): La longueur inférieure (sur l&#39;axe des distances).
        length_max (float): La longueur spérieure (sur l&#39;axe des distances).
        orientation_half_span (float): L&#39;étendu de l&#39;orientation en radians (sur l&#39;axe de rotation). Defaults = tau
        orientation_reference (float): L&#39;angle de référence en radians (sur l&#39;axe de rotation). Defaults = 0.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 3.14)
        &gt;&gt;&gt; print(v1) # doctest: +SKIP
        (12.00E+00, 28.00E+00)
    &#34;&#34;&#34;                        
    self.set_polar(uniform(length_min, length_max), uniform(-orientation_half_span, orientation_half_span) + orientation_reference)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.randomize_polar_degrees"><code class="name flex">
<span>def <span class="ident">randomize_polar_degrees</span></span>(<span>self, length_min: float, length_max: float, orientation_half_span: float = 360.0, orientation_reference: float = 0.0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Modifie le vecteur courant de façon à créer un vecteur aléatoire
paramétré dans le système de coordonnées polaires.</p>
<p>L'orientation est définie en degrées.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length_min</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur inférieure (sur l'axe des distances).</dd>
<dt><strong><code>length_max</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur spérieure (sur l'axe des distances).</dd>
<dt><strong><code>orientation_half_span</code></strong> :&ensp;<code>float</code></dt>
<dd>L'étendu de l'orientation en degrées (sur l'axe de rotation). Defaults = 360.</dd>
<dt><strong><code>orientation_reference</code></strong> :&ensp;<code>float</code></dt>
<dd>L'angle de référence en degrées (sur l'axe de rotation). Defaults = 0.</dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 90.)
&gt;&gt;&gt; print(v1) # doctest: +SKIP
(12.00E+00, 28.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def randomize_polar_degrees(self, length_min : float, length_max : float, orientation_half_span  : float = 360., orientation_reference : float = 0.) -&gt; None:
    &#34;&#34;&#34;Modifie le vecteur courant de façon à créer un vecteur aléatoire 
    paramétré dans le système de coordonnées polaires.
    
    L&#39;orientation est définie en degrées.
    
    Args:
        length_min (float): La longueur inférieure (sur l&#39;axe des distances).
        length_max (float): La longueur spérieure (sur l&#39;axe des distances).
        orientation_half_span (float): L&#39;étendu de l&#39;orientation en degrées (sur l&#39;axe de rotation). Defaults = 360.
        orientation_reference (float): L&#39;angle de référence en degrées (sur l&#39;axe de rotation). Defaults = 0.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v1.randomize_polar(0., 100., 0., 90.)
        &gt;&gt;&gt; print(v1) # doctest: +SKIP
        (12.00E+00, 28.00E+00)
    &#34;&#34;&#34;                        
    self.randomize_polar(length_min, length_max, radians(orientation_half_span), radians(orientation_reference))</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Réinitialise le vecteur (0.0, 0.0). Le vecteur est indéfini.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(2.0, 1.5)
&gt;&gt;&gt; print(v1)
(2.00E+00, 1.50E+00)
&gt;&gt;&gt; v1.reset()
&gt;&gt;&gt; print(v1)
(0.00E+00, 0.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self) -&gt; None:
    &#34;&#34;&#34;Réinitialise le vecteur (0.0, 0.0). Le vecteur est indéfini.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(2.0, 1.5)
        &gt;&gt;&gt; print(v1)
        (2.00E+00, 1.50E+00)
        &gt;&gt;&gt; v1.reset()
        &gt;&gt;&gt; print(v1)
        (0.00E+00, 0.00E+00)
    &#34;&#34;&#34;        
    self.x, self.y = 0., 0.</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.scalar_projection"><code class="name flex">
<span>def <span class="ident">scalar_projection</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne la projection scalaire de ce vecteur sur le vecteur passé
en argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>Le vecteur sur lequel est projeté le vecteur </dd>
</dl>
<p>courant.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
&gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
&gt;&gt;&gt; v1.scalar_projection(v2)
3.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scalar_projection(self, other : &#39;Vect2D&#39;) -&gt; float:
    &#34;&#34;&#34;Retourne la projection scalaire de ce vecteur sur le vecteur passé 
    en argument.
    
    Args:
        other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
        courant.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
        &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
        &gt;&gt;&gt; v1.scalar_projection(v2)
        3.0
    &#34;&#34;&#34;
    return self.dot(other) / other.length</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.scalar_rejection"><code class="name flex">
<span>def <span class="ident">scalar_rejection</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne la réjection scalaire de ce vecteur sur le vecteur passé
en argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>Le vecteur sur lequel est projeté le vecteur </dd>
</dl>
<p>courant.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
&gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
&gt;&gt;&gt; v1.scalar_rejection(v2)
1.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scalar_rejection(self, other : &#39;Vect2D&#39;) -&gt; float:
    &#34;&#34;&#34;Retourne la réjection scalaire de ce vecteur sur le vecteur passé 
    en argument.
    
    Args:
        other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
        courant.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
        &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
        &gt;&gt;&gt; v1.scalar_rejection(v2)
        1.0
    &#34;&#34;&#34;
    return (self.y * other.x - self.x * other.y) / other.length</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, x: int | float, y: int | float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Détermine les valeurs x et y.</p>
<h2 id="args">Args</h2>
<p>x (float | int): La coordonnées en x.
y (float | int): La coordonnées en y.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v1.set(-2.0, -1.5)
&gt;&gt;&gt; print(v1)
(-2.00E+00, -1.50E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, x : int | float, y : int | float) -&gt; None:      
    &#34;&#34;&#34;Détermine les valeurs x et y.
    
    Args:
        x (float | int): La coordonnées en x.
        y (float | int): La coordonnées en y.

    Exemples:
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v1.set(-2.0, -1.5)
        &gt;&gt;&gt; print(v1)
        (-2.00E+00, -1.50E+00)
    &#34;&#34;&#34;
    self.x, self.y = float(x), float(y)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.set_polar"><code class="name flex">
<span>def <span class="ident">set_polar</span></span>(<span>self, length: float, orientation: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Détermine le vecteur courant par la représentation polaire passée en
argument. </p>
<p>La représentation finale du vecteur est toujours selon un
système de coordonnées cartésiennes.</p>
<p>L'orientation est en radians.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>La longueur de la coordonnée polaire. </dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>float</code></dt>
<dd>L'orientation' de la coordonnée polaire. </dd>
</dl>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; Vect2D.set_value_format(False, 1)
&gt;&gt;&gt; v1 = Vect2D()
&gt;&gt;&gt; v1.set_polar(5.0, pi/2.)
&gt;&gt;&gt; print(v1)
(0.0, 5.0)
&gt;&gt;&gt; Vect2D.set_value_format(True, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_polar(self, length : float, orientation : float) -&gt; None:
    &#34;&#34;&#34;Détermine le vecteur courant par la représentation polaire passée en 
    argument. 
    
    La représentation finale du vecteur est toujours selon un 
    système de coordonnées cartésiennes.
    
    L&#39;orientation est en radians.
    
    Args:
        length (float): La longueur de la coordonnée polaire. 
        orientation (float): L&#39;orientation&#39; de la coordonnée polaire. 

    Exemples:
        &gt;&gt;&gt; from math import pi
        &gt;&gt;&gt; Vect2D.set_value_format(False, 1)
        &gt;&gt;&gt; v1 = Vect2D()
        &gt;&gt;&gt; v1.set_polar(5.0, pi/2.)
        &gt;&gt;&gt; print(v1)
        (0.0, 5.0)
        &gt;&gt;&gt; Vect2D.set_value_format(True, 2)
    &#34;&#34;&#34;        
    self.x = length * cos(orientation)
    self.y = length * sin(orientation)</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.vector_projection"><code class="name flex">
<span>def <span class="ident">vector_projection</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retourne la projection vectorielle de ce vecteur sur le vecteur passé
en argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>Le vecteur sur lequel est projeté le vecteur </dd>
</dl>
<p>courant.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
&gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
&gt;&gt;&gt; print(v1.vector_projection(v2))
(3.00E+00, 0.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vector_projection(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;Retourne la projection vectorielle de ce vecteur sur le vecteur passé 
    en argument.
    
    Args:
        other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
        courant.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
        &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
        &gt;&gt;&gt; print(v1.vector_projection(v2))
        (3.00E+00, 0.00E+00)
    &#34;&#34;&#34;        
    return self.dot(other) / other.dot(other) * other</code></pre>
</details>
</dd>
<dt id="vect2d.Vect2D.vector_rejection"><code class="name flex">
<span>def <span class="ident">vector_rejection</span></span>(<span>self, other: <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a>) ‑> <a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retourne la réjection vectorielle de ce vecteur sur le vecteur passé
en argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></dt>
<dd>Le vecteur sur lequel est projeté le vecteur </dd>
</dl>
<p>courant.</p>
<h2 id="exemples">Exemples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
&gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
&gt;&gt;&gt; print(v1.vector_rejection(v2))
(0.00E+00, 1.00E+00)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vector_rejection(self, other : &#39;Vect2D&#39;) -&gt; &#39;Vect2D&#39;:
    &#34;&#34;&#34;Retourne la réjection vectorielle de ce vecteur sur le vecteur passé 
    en argument.
    
    Args:
        other (Vect2D): Le vecteur sur lequel est projeté le vecteur 
        courant.
    
    Exemples:
        &gt;&gt;&gt; v1 = Vect2D(3.0, 1.0)
        &gt;&gt;&gt; v2 = Vect2D(5.0, 0.0)
        &gt;&gt;&gt; print(v1.vector_rejection(v2))
        (0.00E+00, 1.00E+00)
    &#34;&#34;&#34;     
    return self - self.vector_projection(other)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vect2d.Vect2D" href="#vect2d.Vect2D">Vect2D</a></code></h4>
<ul class="">
<li><code><a title="vect2d.Vect2D.UNDEFINED" href="#vect2d.Vect2D.UNDEFINED">UNDEFINED</a></code></li>
<li><code><a title="vect2d.Vect2D.angle_between" href="#vect2d.Vect2D.angle_between">angle_between</a></code></li>
<li><code><a title="vect2d.Vect2D.angle_between_degrees" href="#vect2d.Vect2D.angle_between_degrees">angle_between_degrees</a></code></li>
<li><code><a title="vect2d.Vect2D.angle_disparity" href="#vect2d.Vect2D.angle_disparity">angle_disparity</a></code></li>
<li><code><a title="vect2d.Vect2D.angle_disparity_degrees" href="#vect2d.Vect2D.angle_disparity_degrees">angle_disparity_degrees</a></code></li>
<li><code><a title="vect2d.Vect2D.as_dict" href="#vect2d.Vect2D.as_dict">as_dict</a></code></li>
<li><code><a title="vect2d.Vect2D.as_list" href="#vect2d.Vect2D.as_list">as_list</a></code></li>
<li><code><a title="vect2d.Vect2D.as_tuple" href="#vect2d.Vect2D.as_tuple">as_tuple</a></code></li>
<li><code><a title="vect2d.Vect2D.chebyshev_length" href="#vect2d.Vect2D.chebyshev_length">chebyshev_length</a></code></li>
<li><code><a title="vect2d.Vect2D.clamp_length" href="#vect2d.Vect2D.clamp_length">clamp_length</a></code></li>
<li><code><a title="vect2d.Vect2D.clamp_length_squared" href="#vect2d.Vect2D.clamp_length_squared">clamp_length_squared</a></code></li>
<li><code><a title="vect2d.Vect2D.clamp_x" href="#vect2d.Vect2D.clamp_x">clamp_x</a></code></li>
<li><code><a title="vect2d.Vect2D.clamp_y" href="#vect2d.Vect2D.clamp_y">clamp_y</a></code></li>
<li><code><a title="vect2d.Vect2D.copy" href="#vect2d.Vect2D.copy">copy</a></code></li>
<li><code><a title="vect2d.Vect2D.copy_from" href="#vect2d.Vect2D.copy_from">copy_from</a></code></li>
<li><code><a title="vect2d.Vect2D.copy_to" href="#vect2d.Vect2D.copy_to">copy_to</a></code></li>
<li><code><a title="vect2d.Vect2D.cross" href="#vect2d.Vect2D.cross">cross</a></code></li>
<li><code><a title="vect2d.Vect2D.distance_from" href="#vect2d.Vect2D.distance_from">distance_from</a></code></li>
<li><code><a title="vect2d.Vect2D.distance_squared_from" href="#vect2d.Vect2D.distance_squared_from">distance_squared_from</a></code></li>
<li><code><a title="vect2d.Vect2D.dot" href="#vect2d.Vect2D.dot">dot</a></code></li>
<li><code><a title="vect2d.Vect2D.flip" href="#vect2d.Vect2D.flip">flip</a></code></li>
<li><code><a title="vect2d.Vect2D.flipped" href="#vect2d.Vect2D.flipped">flipped</a></code></li>
<li><code><a title="vect2d.Vect2D.from_data" href="#vect2d.Vect2D.from_data">from_data</a></code></li>
<li><code><a title="vect2d.Vect2D.from_polar" href="#vect2d.Vect2D.from_polar">from_polar</a></code></li>
<li><code><a title="vect2d.Vect2D.from_polar_degrees" href="#vect2d.Vect2D.from_polar_degrees">from_polar_degrees</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_cartesian" href="#vect2d.Vect2D.from_random_cartesian">from_random_cartesian</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_normalized" href="#vect2d.Vect2D.from_random_normalized">from_random_normalized</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_polar" href="#vect2d.Vect2D.from_random_polar">from_random_polar</a></code></li>
<li><code><a title="vect2d.Vect2D.from_random_polar_degrees" href="#vect2d.Vect2D.from_random_polar_degrees">from_random_polar_degrees</a></code></li>
<li><code><a title="vect2d.Vect2D.from_vect2d" href="#vect2d.Vect2D.from_vect2d">from_vect2d</a></code></li>
<li><code><a title="vect2d.Vect2D.is_defined" href="#vect2d.Vect2D.is_defined">is_defined</a></code></li>
<li><code><a title="vect2d.Vect2D.is_forming_accute_angle_with" href="#vect2d.Vect2D.is_forming_accute_angle_with">is_forming_accute_angle_with</a></code></li>
<li><code><a title="vect2d.Vect2D.is_forming_obtuse_angle_with" href="#vect2d.Vect2D.is_forming_obtuse_angle_with">is_forming_obtuse_angle_with</a></code></li>
<li><code><a title="vect2d.Vect2D.is_normalized" href="#vect2d.Vect2D.is_normalized">is_normalized</a></code></li>
<li><code><a title="vect2d.Vect2D.is_parallel_to" href="#vect2d.Vect2D.is_parallel_to">is_parallel_to</a></code></li>
<li><code><a title="vect2d.Vect2D.is_perpendicular_to" href="#vect2d.Vect2D.is_perpendicular_to">is_perpendicular_to</a></code></li>
<li><code><a title="vect2d.Vect2D.left_perpendicular" href="#vect2d.Vect2D.left_perpendicular">left_perpendicular</a></code></li>
<li><code><a title="vect2d.Vect2D.length" href="#vect2d.Vect2D.length">length</a></code></li>
<li><code><a title="vect2d.Vect2D.length_squared" href="#vect2d.Vect2D.length_squared">length_squared</a></code></li>
<li><code><a title="vect2d.Vect2D.limit_length" href="#vect2d.Vect2D.limit_length">limit_length</a></code></li>
<li><code><a title="vect2d.Vect2D.limit_length_squared" href="#vect2d.Vect2D.limit_length_squared">limit_length_squared</a></code></li>
<li><code><a title="vect2d.Vect2D.manhattan_length" href="#vect2d.Vect2D.manhattan_length">manhattan_length</a></code></li>
<li><code><a title="vect2d.Vect2D.minkowski_length" href="#vect2d.Vect2D.minkowski_length">minkowski_length</a></code></li>
<li><code><a title="vect2d.Vect2D.normalize" href="#vect2d.Vect2D.normalize">normalize</a></code></li>
<li><code><a title="vect2d.Vect2D.normalized" href="#vect2d.Vect2D.normalized">normalized</a></code></li>
<li><code><a title="vect2d.Vect2D.orientation" href="#vect2d.Vect2D.orientation">orientation</a></code></li>
<li><code><a title="vect2d.Vect2D.orientation_degrees" href="#vect2d.Vect2D.orientation_degrees">orientation_degrees</a></code></li>
<li><code><a title="vect2d.Vect2D.projection_analysis" href="#vect2d.Vect2D.projection_analysis">projection_analysis</a></code></li>
<li><code><a title="vect2d.Vect2D.randomize_cartesian" href="#vect2d.Vect2D.randomize_cartesian">randomize_cartesian</a></code></li>
<li><code><a title="vect2d.Vect2D.randomize_normalized" href="#vect2d.Vect2D.randomize_normalized">randomize_normalized</a></code></li>
<li><code><a title="vect2d.Vect2D.randomize_polar" href="#vect2d.Vect2D.randomize_polar">randomize_polar</a></code></li>
<li><code><a title="vect2d.Vect2D.randomize_polar_degrees" href="#vect2d.Vect2D.randomize_polar_degrees">randomize_polar_degrees</a></code></li>
<li><code><a title="vect2d.Vect2D.reset" href="#vect2d.Vect2D.reset">reset</a></code></li>
<li><code><a title="vect2d.Vect2D.right_perpendicular" href="#vect2d.Vect2D.right_perpendicular">right_perpendicular</a></code></li>
<li><code><a title="vect2d.Vect2D.scalar_projection" href="#vect2d.Vect2D.scalar_projection">scalar_projection</a></code></li>
<li><code><a title="vect2d.Vect2D.scalar_rejection" href="#vect2d.Vect2D.scalar_rejection">scalar_rejection</a></code></li>
<li><code><a title="vect2d.Vect2D.set" href="#vect2d.Vect2D.set">set</a></code></li>
<li><code><a title="vect2d.Vect2D.set_polar" href="#vect2d.Vect2D.set_polar">set_polar</a></code></li>
<li><code><a title="vect2d.Vect2D.set_string_format" href="#vect2d.Vect2D.set_string_format">set_string_format</a></code></li>
<li><code><a title="vect2d.Vect2D.set_value_format" href="#vect2d.Vect2D.set_value_format">set_value_format</a></code></li>
<li><code><a title="vect2d.Vect2D.vector_projection" href="#vect2d.Vect2D.vector_projection">vector_projection</a></code></li>
<li><code><a title="vect2d.Vect2D.vector_rejection" href="#vect2d.Vect2D.vector_rejection">vector_rejection</a></code></li>
<li><code><a title="vect2d.Vect2D.x" href="#vect2d.Vect2D.x">x</a></code></li>
<li><code><a title="vect2d.Vect2D.y" href="#vect2d.Vect2D.y">y</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>