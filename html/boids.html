<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>boids API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>boids</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
from abc import abstractmethod
import tkinter as tk
from tkinter import Tk, ttk
from PIL import Image, ImageDraw, ImageTk
from vect2d import Vect2D
import math

#  __    __  .___________. __   __       __  .___________. __   _______     _______.
# |  |  |  | |           ||  | |  |     |  | |           ||  | |   ____|   /       |
# |  |  |  | `---|  |----`|  | |  |     |  | `---|  |----`|  | |  |__     |   (----`
# |  |  |  |     |  |     |  | |  |     |  |     |  |     |  | |   __|     \   \    
# |  `--&#39;  |     |  |     |  | |  `----.|  |     |  |     |  | |  |____.----)   |   
#  \______/      |__|     |__| |_______||__|     |__|     |__| |_______|_______/                                                                                                                               
class Utils():
    &#34;&#34;&#34;
    This class contains two static methods. One is used to clamp a value between a min and max value and
    one  is used to reads a file and returns a list of strings to populate the scenario combobox.
    &#34;&#34;&#34;          
    def clamp_max(value, max):
        return min(value, max)
    
    def readfile(filename:str)-&gt;list:
        data = []
        with open(filename, &#39;r&#39;) as file:
            for line in file:
                data.append(line)
        return data

class RGBAColor():
    &#34;&#34;&#34;
    This class is used to create a color object that can be used to draw shapes on the image.
    It can be used to create a random color or a specific color. To create a random color, use the
    randomize_color() method. To create a specific color, use the RGBAColor(r, g, b, a) constructor.
    &#34;&#34;&#34;
    def __init__(self, r:int=255, g:int=255, b:int=255, a:int=255, randomize:bool=False):
        self.__r = r
        self.__g = g
        self.__b = b
        self.__a = a

        if randomize:
            self.randomize_color()
        
    @property
    def r(self):
        return self.__r
        
    @property
    def g(self):
        return self.__g
        
    @property
    def b(self):
        return self.__b
        
    @property
    def a(self):
        return self.__a
    
    @property
    def rgba(self):
        return (self.__r, self.__g, self.__b, self.__a)
    
    @rgba.setter
    def rgba(self, rgba):
        self.r = rgba[0]
        self.g = rgba[1]
        self.b = rgba[2]
        self.a = rgba[3]
        
    def randomize_color(self):
        self.__r = random.randint(0, 255)
        self.__g = random.randint(0, 255)
        self.__b = random.randint(0, 255)
        self.__a = random.randint(0, 255)
    &#34;&#34;&#34;randomize_color() returns None and randomizes the color values of the object.&#34;&#34;&#34;


#      _______.___________. _______  _______ .______       __  .__   __.   _______    .______    _______  __    __       ___   ____    ____  __    ______   .______          _______.
#     /       |           ||   ____||   ____||   _  \     |  | |  \ |  |  /  _____|   |   _  \  |   ____||  |  |  |     /   \  \   \  /   / |  |  /  __  \  |   _  \        /       |
#    |   (----`---|  |----`|  |__   |  |__   |  |_)  |    |  | |   \|  | |  |  __     |  |_)  | |  |__   |  |__|  |    /  ^  \  \   \/   /  |  | |  |  |  | |  |_)  |      |   (----`
#     \   \       |  |     |   __|  |   __|  |      /     |  | |  . `  | |  | |_ |    |   _  &lt;  |   __|  |   __   |   /  /_\  \  \      /   |  | |  |  |  | |      /        \   \    
# .----)   |      |  |     |  |____ |  |____ |  |\  \----.|  | |  |\   | |  |__| |    |  |_)  | |  |____ |  |  |  |  /  _____  \  \    /    |  | |  `--&#39;  | |  |\  \----.----)   |   
# |_______/       |__|     |_______||_______|| _| `._____||__| |__| \__|  \______|    |______/  |_______||__|  |__| /__/     \__\  \__/     |__|  \______/  | _| `._____|_______/    
                                                                                                                                                                                   
class SteeringBehavior():
    &#34;&#34;&#34;
    This class is used to create a steering behavior object that can be used to steer an entity.
    It is an abstract class. It contains a abstract method called behave() that is used to steer an entity (dynamicCircles).
    &#34;&#34;&#34;
    def __init__(self, target_entities:type[&#39;Entity&#39;]=None, attraction_repulsion_force:Vect2D=None):
        self.__attraction_repulsion_force = attraction_repulsion_force
        self.__resulting_direction = Vect2D(0, 0)
        self.__target_entities = [] if target_entities is None else target_entities

    @abstractmethod    
    def behave(self, origin_entity:type[&#39;Entity&#39;]):
        pass  
    
    @property
    def attraction_repulsion_force(self):
        return self.__attraction_repulsion_force
    
    @property
    def resulting_direction(self):
        return self.__resulting_direction
    
    @resulting_direction.setter
    def resulting_direction(self, resulting_direction):
        self.__resulting_direction = resulting_direction

    @property
    def target_entities(self):
        return self.__target_entities
    
    @target_entities.setter
    def target_entities(self, target_entities):
        self.__target_entities = target_entities
        
    def add_target_entity(self, target_entity):
        self.__target_entities.append(target_entity)
        
    def remove_target_entity(self, target_entity):
        self.__target_entities.remove(target_entity)


class Seek(SteeringBehavior):
    &#34;&#34;&#34;
    This class is used to create a seek steering behavior object.
    It is a child class of the SteeringBehavior class.
    &#34;&#34;&#34;
    def __init__(self, target_entities:type[&#39;Entity&#39;]=None, attraction_repulsion_force:int=1): 
        SteeringBehavior.__init__(self, target_entities, attraction_repulsion_force)

    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        sum_of_forces = Vect2D(0, 0)
        for target_entity in self.target_entities:
            if target_entity is not None:
                if isinstance(target_entity, Entity):
                    desired_speed = (target_entity.position - origin_entity.position).normalized * origin_entity.max_speed
                    sum_of_forces += desired_speed - origin_entity.speed * self.attraction_repulsion_force
                elif isinstance(target_entity, Vect2D) and (target_entity.x != -1 and target_entity.y != -1):
                    desired_speed = (target_entity - origin_entity.position).normalized * origin_entity.max_speed
                    sum_of_forces += (desired_speed - origin_entity.speed) * self.attraction_repulsion_force
        return sum_of_forces
     
class FollowBiggestBoidSeen(SteeringBehavior):
    &#34;&#34;&#34;
    This class is used to create a follow biggest boid steering behavior object.
    It is a child class of the SteeringBehavior class.
    It will follow the biggest boid in the field of view or will not apply any force if the biggest boid is too small.
    &#34;&#34;&#34;
    def __init__(self, target_entities:type[&#39;Entity&#39;]=None, attraction_repulsion_force:int=1, minimum_boids_radius:float=5.0): 
        SteeringBehavior.__init__(self, target_entities, attraction_repulsion_force)
        self.minimum_boids_radius = minimum_boids_radius

    &#34;&#34;&#34;
    This function is used to calculate the force to apply to the boid.
    It is a child function of the SteeringBehavior class.
    &#34;&#34;&#34;
    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        sum_of_forces = Vect2D(0, 0)
        biggest_boid = None
        for target_entity in self.target_entities:
            if target_entity is not None:
                if biggest_boid is None:
                    biggest_boid = target_entity
                elif biggest_boid.radius &lt; target_entity.radius:
                    biggest_boid = target_entity
        if biggest_boid is not None:
            if biggest_boid.radius &gt; self.minimum_boids_radius:
                target_position = biggest_boid.position - biggest_boid.speed.normalized * 1.5 * biggest_boid.radius
                distance = (target_position - origin_entity.position).length
                new_maximum_speed = biggest_boid.original_max_speed * (1 + min(100, distance) / 100.0 * 0.25)
                origin_entity.max_speed = new_maximum_speed
                desired_speed = (target_position - origin_entity.position).normalized * origin_entity.max_speed
                sum_of_forces += desired_speed - origin_entity.speed * self.attraction_repulsion_force
            else:
                origin_entity.max_speed = origin_entity.original_max_speed
        return sum_of_forces

class Wander(Seek):
    def __init__(self, radius:float=50, circle_distance:float=100, is_in:bool=True, attraction_repulsion_force:int=1):
        super().__init__(attraction_repulsion_force=attraction_repulsion_force)
        &#39;&#39;&#39;radius will increase the turning distance
        circle_distance will increase the distance before turning
        &#39;&#39;&#39;        
        self.__circle_distance = circle_distance
        self.__radius = radius
        self.__is_in = is_in
        self.__circle_center = None
   
    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        &#39;&#39;&#39;Returns a vector that points in a random direction

        Args:
            origin_entity (Entity): the sprite that is wandering

        Returns:
            Vect2D: displacement vector
        &#39;&#39;&#39;        
        circle_center_sprite_relative = origin_entity.speed.normalized * self.__circle_distance
        self.__circle_center = origin_entity.position + circle_center_sprite_relative
        displacement = Vect2D.from_random_normalized()
        
        if self.__is_in:
            displacement *= random.random() * self.__radius
        else:
            displacement *= self.__radius
        
        self.target_entities = []
        self.target_entities.append(self.__circle_center + displacement)
        
        return super().behave(origin_entity)
        
    def draw(self, draw):
        for target_entity in self.target_entities:
            draw.ellipse([self.__circle_center.x - self.radius, self.__circle_center.y - self.radius, self.__circle_center.x + self.radius, self.__circle_center.y  + self.radius], outline=&#34;blue&#34;)
            draw.ellipse([target_entity.x - 5, target_entity.y - 5, target_entity.x + 5, target_entity.y + 5], fill=&#34;cyan&#34;)
        
    @property
    def circle_distance(self):
        return self.__circle_distance
    
    @property
    def radius(self):
        return self.__radius


class PseudoWander(SteeringBehavior):
    def __init__(self, radius:float=100, circle_distance:float=100, angle_change:float=0.5):
        super().__init__()
        &#39;&#39;&#39;radius will increase the turning distance
        circle_distance will increase the distance before turning
        angle_change will increase the turning rate
        &#39;&#39;&#39;        
        self.__circle_distance = circle_distance
        self.__radius = radius
        self.__angle_change = angle_change
        self.__wander_angle = random.random() * 2 * math.pi
        
    def set_angle(self, vector:Vect2D, angle:float) -&gt; Vect2D:
        length = vector.length
        vector.x = math.cos(angle) * length
        vector.y = math.sin(angle) * length
        return vector
        
    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:     
        &#39;&#39;&#39;Retruns a vector that points in a random direction

        Args:
            origin_entity (Entity): the sprite that is wandering

        Returns:
            Vect2D: displacement vector
        &#39;&#39;&#39;        
        circle_center = origin_entity.speed.copy()
        circle_center.normalize()
        circle_center *= self.__circle_distance
        
        displacement = Vect2D.from_random_normalized()
        displacement *= self.__radius
        
        self.set_angle(displacement, self.__wander_angle)
        
        self.__wander_angle += (random.random() * self.__angle_change) - (self.__angle_change * .5)
        
        desired_speed = circle_center + displacement
        
        return desired_speed - origin_entity.speed


class Flee(Seek):
    def __init__(self, target_entities:type[&#39;Entity&#39;]=None, attraction_repulsion_force:int=1):
        super().__init__(target_entities, attraction_repulsion_force)
        
    def behave(self, origin_entity: type[&#39;Entity&#39;])-&gt; Vect2D:
        return super().behave(origin_entity) * -1


class Pursuit(SteeringBehavior):
    def __init__(self, target_entities:type[&#39;Entity&#39;]=None, ratio:int = 1, attraction_repulsion_force:int=1):
        super().__init__(target_entities, attraction_repulsion_force=attraction_repulsion_force)
        self.__ratio = ratio
        
    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        sum_of_forces = Vect2D(0, 0)
        for target_entity in self.target_entities:
            if target_entity is not None:
                estimated_position = target_entity.position + target_entity.speed  * self.__ratio 
                desired_speed = (estimated_position - origin_entity.position).normalized * origin_entity.max_speed
                sum_of_forces += (desired_speed - origin_entity.speed) * self.attraction_repulsion_force
        return sum_of_forces


class BorderRepulsion(SteeringBehavior): 

    def __init__(self, attraction_repulsion_force=50000, sim_dim:Vect2D=None):       
        SteeringBehavior.__init__(self, attraction_repulsion_force=attraction_repulsion_force)
        self.__sim_dim = sim_dim

    def behave(self, origin_entity:type[&#39;Entity&#39;]) -&gt; Vect2D:
        force = self.attraction_repulsion_force

        distance_from_left = origin_entity.position.x - origin_entity.width / 2
        distance_from_right = self.__sim_dim.x - origin_entity.position.x - origin_entity.width / 2
        distance_from_top = origin_entity.position.y - origin_entity.height / 2
        distance_from_bottom = self.__sim_dim.y - origin_entity.position.y - origin_entity.height / 2

        repulsive_force_left = round((Vect2D(force, 0))/(distance_from_left) ** 2, 0) if distance_from_left &gt; 0 else Vect2D(force, 0)
        repulsive_force_right = round((Vect2D(-force, 0))/(distance_from_right) ** 2, 0) if distance_from_right &gt; 0 else Vect2D(-force, 0)
        repulsive_force_top = round((Vect2D(0, force))/(distance_from_top) ** 2, 2) if distance_from_top &gt; 0 else Vect2D(0, force)
        repulsive_force_bottom = round((Vect2D(0, -force))/(distance_from_bottom) ** 2, 0) if distance_from_bottom &gt; 0 else Vect2D(0, -force)
        
        return repulsive_force_left + repulsive_force_right + repulsive_force_top + repulsive_force_bottom


class EntityRepulsion(SteeringBehavior):
    def __init__(self, target_entities:list[type[&#39;Entity&#39;]|type[&#39;Vect2D&#39;]], attraction_repulsion_force:int=2000000000):
        SteeringBehavior.__init__(self, attraction_repulsion_force=attraction_repulsion_force)
    
        self.__target_entities = target_entities

    def behave(self, origin_entity:type[&#39;Entity&#39;]) -&gt; Vect2D:
        force = self.attraction_repulsion_force
        for target_entity in self.__target_entities:
            if target_entity is not origin_entity:
                if isinstance(target_entity, Entity):
                    orientation = (origin_entity.position - target_entity.position).normalized
                    distance = (origin_entity.position - target_entity.position).length - origin_entity.radius - target_entity.radius
                elif isinstance(target_entity, Vect2D):
                    orientation = (origin_entity.position - target_entity).normalized
                    distance = (origin_entity.position - target_entity).length - origin_entity.radius
                
                self.resulting_direction += orientation/distance ** 2 * force
                
        return self.resulting_direction


class Evade(Pursuit):
    def __init__(self, target_entity:type[&#39;Entity&#39;]=None, ratio:int = 1, attraction_repulsion_force:int=1):
        super().__init__(target_entity, ratio, attraction_repulsion_force)
        
    def behave(self, origin_entity: type[&#39;Entity&#39;])-&gt; Vect2D:
        return super().behave(origin_entity) * - 1   


class Cohesion(SteeringBehavior):
    def __init__(self, target_entities:list[type[&#39;Entity&#39;]|type[&#39;Vect2D&#39;]], attraction_repulsion_force:int=50):
        super().__init__(target_entities, attraction_repulsion_force)

        self.__center_of_gravity = Vect2D()
        
        self.__origin_entity = None

    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        if not self.__origin_entity:
            self.__origin_entity = origin_entity
        sum_of_positions = Vect2D()
        for target_entity in self.target_entities:
            if target_entity is not None:
                if isinstance(target_entity, Entity):
                    sum_of_positions.set(sum_of_positions.x + target_entity.position.x, sum_of_positions.y + target_entity.position.y)
                else: 
                    sum_of_position += target_entity
        self.__center_of_gravity.set(sum_of_positions.x / len(self.target_entities), sum_of_positions.y / len(self.target_entities)) 
        desired_speed = (self.__center_of_gravity - origin_entity.position).normalized * origin_entity.max_speed
        sum_of_forces = (desired_speed - origin_entity.speed) * self.attraction_repulsion_force
        return sum_of_forces
    
    def draw(self,draw):
        draw.line([self.__origin_entity.position.x, self.__origin_entity.position.y, self.__center_of_gravity.x, self.__center_of_gravity.y], (0, 255, 0))
        draw.ellipse([self.__center_of_gravity.x -5 , self.__center_of_gravity.y -5, self.__center_of_gravity.x + 5 , self.__center_of_gravity.y + 5], (0, 255, 0))    


class Alignment(SteeringBehavior):
    def __init__(self, target_entities:list[type[&#39;Entity&#39;]|type[&#39;Vect2D&#39;]], attraction_repulsion_force:int=50000):
        super().__init__(target_entities, attraction_repulsion_force)
        
        self.__origin_entity = None
        
        self.__sum_of_forces = Vect2D()
        
    def behave(self, origin_entity: type[&#39;Entity&#39;] = None) -&gt; Vect2D:
        if not self.__origin_entity:
            self.__origin_entity = origin_entity
            for target_entity in self.target_entities:
                if target_entity is not None:
                    if isinstance(target_entity, Entity):
                        self.__sum_of_forces += target_entity.speed
        self.__sum_of_forces /= len(self.target_entities)
        return  self.__sum_of_forces
    
    def draw(self, draw):
        draw.line([self.__origin_entity.position.x, self.__origin_entity.position.y, self.__origin_entity.position.x + self.__sum_of_forces.x, self.__origin_entity.position.y +  self.__sum_of_forces.y], (255, 255, 0))
        draw.ellipse([self.__origin_entity.position.x + self.__sum_of_forces.x -5 , self.__origin_entity.position.y + self.__sum_of_forces.y -5, self.__origin_entity.position.x + self.__sum_of_forces.x + 5 , self.__origin_entity.position.y + self.__sum_of_forces.y + 5], (255, 255, 0))


class Separation(SteeringBehavior):
    def __init__(self, target_entities:list[type[&#39;Entity&#39;]|type[&#39;Vect2D&#39;]], attraction_repulsion_force:int=50):
        super().__init__(target_entities, attraction_repulsion_force)
        
    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        sum_of_forces = Vect2D()
        for target_entity in self.target_entities:
            if target_entity is not None:
                if isinstance(target_entity, Entity):
                    behavior = EntityRepulsion([target_entity], self.attraction_repulsion_force)
                    sum_of_forces += behavior.behave(origin_entity)
        return sum_of_forces


# #  __  .__   __. .___________. _______ .______       _______    ___       ______  _______     _______.
# |  | |  \ |  | |           ||   ____||   _  \     |   ____|  /   \     /      ||   ____|   /       |
# |  | |   \|  | `---|  |----`|  |__   |  |_)  |    |  |__    /  ^  \   |  ,----&#39;|  |__     |   (----`
# |  | |  . `  |     |  |     |   __|  |      /     |   __|  /  /_\  \  |  |     |   __|     \   \    
# |  | |  |\   |     |  |     |  |____ |  |\  \----.|  |    /  _____  \ |  `----.|  |____.----)   |   
# |__| |__| \__|     |__|     |_______|| _| `._____||__|   /__/     \__\ \______||_______|_______/   
class Drawable():
    def __init__(self, border_color, border_width, fill_color, position:Vect2D, size:Vect2D):
        self.__border_color = border_color
        self.__border_width = border_width
        self.__fill_color = fill_color
        self.__position = position
        self.__size = size

    @abstractmethod
    def draw(self):
        pass

    @property
    def size(self):
        return self.__size

    @property
    def width(self):
        return self.__size.x

    @property
    def height(self):
        return self.__size.y
    
    @property
    def fill_color(self):
        return self.__fill_color.rgba

    @property
    def border_color(self):
        return self.__border_color.rgba

    @property
    def border_width(self):
        return self.__border_width
    
    @property
    def position(self):
        return self.__position

    @property
    def pos_x(self):
        return self.__position.x

    @property
    def pos_y(self):
        return self.__position.y

    @pos_x.setter
    def pos_x(self, pos_x):
        self.__position.x = pos_x

    @pos_y.setter
    def pos_y(self, pos_y):
        self.__position.y = pos_y

    @position.setter
    def position(self, position):
        self.__position = position

    @fill_color.setter
    def fill_color(self, fill_color):
        self.__fill_color = fill_color


class Movable():
    def __init__(self, acceleration, max_speed, speed):
        self.__acceleration = acceleration
        self.__speed = speed
        self.__max_speed = max_speed
        self.__original_max_speed = max_speed

    def move(self, time):
        self.position.set(self.position.x + self.speed.x * time + self.acceleration.x * 0.5 ** 2 * time, self.position.y + self.speed.y * time + self.acceleration.y * 0.5 ** 2 * time)
        self.speed.set(self.speed.x + self.steering_force.x, self.speed.y + self.steering_force.y)
        
        self.speed.clamp_x(-self.max_speed, self.max_speed)
        self.speed.clamp_y(-self.max_speed, self.max_speed)

    @property
    def max_speed(self):
        return self.__max_speed

    @max_speed.setter
    def max_speed(self, max_speed):
        self.__max_speed = max_speed

    @property
    def original_max_speed(self):
        return self.__original_max_speed

    @property
    def speed(self):
        return self.__speed

    @property
    def acceleration(self):
        return self.__acceleration

    @speed.setter
    def speed(self, speed):
        self.__speed = speed


class Piloted():
    def __init__(self, max_steering_force:int, steering_force:Vect2D, steering_behaviors:list[SteeringBehavior]):
        self.__max_steering_force = max_steering_force
        self.steering_force = steering_force
        self.__steering_behaviors = steering_behaviors

    def steer(self):
        if self.__steering_behaviors is not None:
            for steering_behavior in self.__steering_behaviors:
                self.steering_force.set(self.steering_force.x + steering_behavior.behave(origin_entity=self).x, self.steering_force.y + steering_behavior.behave(origin_entity=self).y)
        self.steering_force.set_polar(length= Utils.clamp_max(self.steering_force.length, self.__max_steering_force), orientation=self.steering_force.orientation)

    @property
    def max_steering_force(self):
        return self.__max_steering_force

    @property
    def steering_force(self):
        return self.__steering_force
    
    @property
    def steering_behaviors(self):
        return self.__steering_behaviors

    @steering_force.setter
    def steering_force(self, steering_force):
        self.__steering_force = steering_force


class Updatable():
    def __init__(self):
        pass

    @abstractmethod
    def tick(self):
        pass


#   ______   ______   .___  ___. .______     ______   .__   __.  _______ .__   __. .___________.    _______.
#  /      | /  __  \  |   \/   | |   _  \   /  __  \  |  \ |  | |   ____||  \ |  | |           |   /       |
# |  ,----&#39;|  |  |  | |  \  /  | |  |_)  | |  |  |  | |   \|  | |  |__   |   \|  | `---|  |----`  |   (----`
# |  |     |  |  |  | |  |\/|  | |   ___/  |  |  |  | |  . `  | |   __|  |  . `  |     |  |        \   \    
# |  `----.|  `--&#39;  | |  |  |  | |  |      |  `--&#39;  | |  |\   | |  |____ |  |\   |     |  |    .----)   |   
#  \______| \______/  |__|  |__| | _|       \______/  |__| \__| |_______||__| \__|     |__|    |_______/    
class Brain():
    def __init__(self, owner, environment, behavior_patterns=None):
        self.__owner = owner
        self.__environment = environment
        if behavior_patterns is None:
            self.__behavior_patterns = {    &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; }, 
                                            &#34;SentientCircle&#34;: { &#34;Behavior&#34;: Cohesion, &#34;Target_type&#34; : &#34;grouping&#34; },
                                            &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                            &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                            &#34;No_target&#34;: { &#34;Behavior&#34;: Wander, &#34;Target_type&#34; : &#34;none&#34; }
                                        }
        else: self.__behavior_patterns = behavior_patterns
        self.__permanent_patterns = [BorderRepulsion(sim_dim=environment.size)]


        self.__seen_entities = []
        self.__active_behaviors = self.__permanent_patterns

    def process(self):
        self.__seen_entities = []
        self.__active_behaviors = []
        self.__active_behaviors.extend(self.__permanent_patterns)
        for eye in self.__owner.eyes:
            self.__seen_entities = eye.look(self.__environment)

        if self.__seen_entities:
            for key in self.__behavior_patterns:
                values = self.__behavior_patterns[key]
                if values[&#34;Target_type&#34;] == &#34;single&#34;:
                    for seen_entity in self.__seen_entities:
                        if seen_entity.__class__.__name__ == key:
                            behavior = self.__behavior_patterns[seen_entity.__class__.__name__][&#34;Behavior&#34;]
                            self.__active_behaviors.append(behavior([seen_entity]))
                elif values[&#34;Target_type&#34;] == &#34;grouping&#34;:
                    target_group = []
                    behavior = values[&#34;Behavior&#34;]
                    for seen_entity in self.__seen_entities:
                        if seen_entity.__class__.__name__ == key:
                            target_group.append(seen_entity)
                    if target_group:
                        self.__active_behaviors.append(behavior(target_group))
        else: 
            behavior = self.__behavior_patterns[&#34;No_target&#34;][&#34;Behavior&#34;]
            self.__active_behaviors.append(behavior())
        self.behave()

    def draw_line_to_seen_entities(self, draw) -&gt; None:
        halo_radius = self.__owner.radius * 1.25
        for seen_entity in self.__seen_entities:
            draw.ellipse([self.__owner.position.x - halo_radius, self.__owner.position.y -  halo_radius, self.__owner.position.x +  halo_radius, self.__owner.position.y +  halo_radius], fill=&#34;cyan&#34;)
            draw.line([self.__owner.position.x, self.__owner.position.y, seen_entity.position.x, seen_entity.position.y], fill=&#34;cyan&#34;, width=5)
            
    def behave(self) -&gt; None:
        for behavior in self.__active_behaviors:
                self.__owner.steering_force.set(self.__owner.steering_force.x + behavior.behave(origin_entity=self.__owner).x, self.__owner.steering_force.y + behavior.behave(origin_entity=self.__owner).y)

        self.__owner.steering_force.set_polar(length= Utils.clamp_max(self.__owner.steering_force.length, self.__owner.max_steering_force), orientation=self.__owner.steering_force.orientation)     

    @property
    def active_behaviors(self):
        return self.__active_behaviors
    
    @property
    def seen_entities(self):
        return self.__seen_entities

    @property
    def behavior_patterns(self):
        return self.__behavior_patterns

    @behavior_patterns.setter
    def behavior_patterns(self, value):
        self.__behavior_patterns = value


class Eye(Drawable):
    def __init__(self, owner:type[&#39;Entity&#39;], fov:float=45, range:float=150, vector:Vect2D=None):
        self.__owner = owner
        Drawable.__init__(self, border_color=RGBAColor(), border_width=1, fill_color=None, position=self.__owner.position, size=Vect2D(range, range))
        self.__fov = fov
        self.__range = range
        if vector is None:
            self.__vector = owner.speed

    def look(self, simulation):
        seen_sprites = []
        for sprite in simulation.sprites:
            if sprite is not self.__owner and self.sees(sprite):
                seen_sprites.append(sprite)
        return seen_sprites

    def is_in_range(self, target:Vect2D)-&gt;bool:
        return self.__owner.position.distance_from(target.position) - target.radius &lt;= self.__range

    def is_in_fov(self, target:Vect2D)-&gt;bool:
        distance_to_target = target.position - self.__owner.position
        if distance_to_target.is_defined:
            return self.__vector.angle_between_degrees(distance_to_target) &lt;= self.__fov
        else:
            return True
        
    def sees(self, target:type[&#39;Entity&#39;])-&gt;bool:
        return self.is_in_range(target) and self.is_in_fov(target)

    def draw(self, draw):
        draw.pieslice(
                [self.__owner.position.x - self.__range,
                self.__owner.position.y - self.__range,
                self.__owner.position.x + self.__range,
                self.__owner.position.y + self.__range],
                start=self.__vector.orientation_degrees - self.__fov,
                end=self.__vector.orientation_degrees + self.__fov,
                width=self.border_width,
                outline=self.border_color)

    @property
    def fov(self):
        return self.__fov

    @property
    def range(self):
        return self.__range

    @property
    def position(self):
        return self.__position

    @property
    def orientation(self):
        return self.__orientation

    @fov.setter
    def fov(self, fov):
        self.__fov = fov

    @range.setter
    def range(self, range):
        self.__range = range

    @position.setter
    def position(self, position):
        self.__position = position

    @orientation.setter
    def orientation(self, orientation):
            self.__orientation = orientation


# .___  ___.   ______    _______   _______  __      
# |   \/   |  /  __  \  |       \ |   ____||  |     
# |  \  /  | |  |  |  | |  .--.  ||  |__   |  |     
# |  |\/|  | |  |  |  | |  |  |  ||   __|  |  |     
# |  |  |  | |  `--&#39;  | |  &#39;--&#39;  ||  |____ |  `----.
# |__|  |__|  \______/  |_______/ |_______||_______|  
class Entity(Drawable, Updatable):
    def __init__(self, border_color, border_width, fill_color, position, size):
        Drawable.__init__(self, border_color, border_width, fill_color, position, size)
        Updatable.__init__(self)
        
        self.__available_names = [&#34;William&#34;, &#34;Logan&#34;, &#34;Liam&#34;, &#34;Noah&#34;, &#34;Jacob&#34;, &#34;Thomas&#34;, 
                                &#34;Raphael&#34;, &#34;Nathan&#34;, &#34;Leo&#34;, &#34;Alexis&#34;, &#34;Emile&#34;, &#34;Edouard&#34;,
                                &#34;Felix&#34;, &#34;Samuel&#34;, &#34;Olivier&#34;, &#34;Gabriel&#34;, &#34;Charles&#34;, &#34;Antoine&#34;,
                                &#34;Adam&#34;, &#34;Victor&#34;, &#34;Benjamin&#34;, &#34;Elliot&#34;, &#34;Jayden&#34;, &#34;Arthur&#34;,
                                &#34;James&#34;, &#34;Louis&#34;, &#34;Theo&#34;, &#34;Xavier&#34;, &#34;Zack&#34;, &#34;Arnaud&#34;,
                                &#34;Lucas&#34;, &#34;Ethan&#34;, &#34;Nolan&#34;, &#34;Henri&#34;, &#34;Loic&#34;, &#34;Milan&#34;, &#34;Mathis&#34;,
                                &#34;Zachary&#34;, &#34;Dylan&#34;, &#34;Alexandre&#34;, &#34;Tristan&#34;, &#34;Laurent&#34;, &#34;Eli&#34;,
                                &#34;Mayson&#34;, &#34;Justin&#34;, &#34;Anthony&#34;, &#34;Ryan&#34;, &#34;Isaac&#34;, &#34;Jules&#34;, &#34;Jackson&#34;,
                                &#34;Eliott&#34;, &#34;Evan&#34;, &#34;Leonard&#34;, &#34;Philippe&#34;, &#34;Caleb&#34;, &#34;Nicolas&#34;,
                                &#34;Damien&#34;, &#34;Jake&#34;, &#34;Theodore&#34;, &#34;Eliot&#34;, &#34;Eloi&#34;, &#34;Ludovic&#34;,
                                &#34;Malik&#34;, &#34;Matheo&#34;, &#34;Louka&#34;, &#34;Alex&#34;, &#34;Hayden&#34;, &#34;Zackary&#34;,
                                &#34;Hugo&#34;, &#34;Rafael&#34;, &#34;Matteo&#34;, &#34;David&#34;, &#34;Hubert&#34;, &#34;Derek&#34;,
                                &#34;Etienne&#34;, &#34;Vincent&#34;, &#34;Rayan&#34;, &#34;Axel&#34;, &#34;Leon&#34;, &#34;Tyler&#34;,
                                &#34;Mathias&#34;, &#34;Albert&#34;, &#34;Maxime&#34;, &#34;Enzo&#34;, &#34;Jordan&#34;, &#34;Julien&#34;,
                                &#34;Simon&#34;, &#34;Loik&#34;, &#34;Michael&#34;, &#34;Ayden&#34;, &#34;Daniel&#34;, &#34;Tom&#34;, &#34;Jack&#34;,
                                &#34;Joshua&#34;, &#34;Maverick&#34;, &#34;Adrien&#34;, &#34;Lyam&#34;, &#34;Mateo&#34;, &#34;Remi&#34;, &#34;Elias&#34;,
                                &#34;Gertrude&#34;, &#34;Denis&#34;, &#34;Donald&#34;, &#34;Jonathan&#34;, &#34;Andrzej&#34;, &#34;Marius&#34;,
                                &#34;Marek&#34;, &#34;Marcin&#34;, &#34;Maciej&#34;, &#34;Piotr&#34;, &#34;Pawel&#34;, &#34;Piotrek&#34;, &#34;Pawel&#34;,
                                &#34;Julie&#34;, &#34;Juliette&#34;, &#34;Juliet&#34;, &#34;Julia&#34;, &#34;Juliana&#34;, &#34;June&#34;, &#34;Valerie&#34;,
                                &#34;Valeria&#34;, &#34;Zoe&#34;, &#34;Chanel&#34;, &#34;Chloe&#34;, &#34;Charlotte&#34;, &#34;Celine&#34;, &#34;Cecile&#34;,
                                &#34;Martha&#34;, &#34;Marie&#34;, &#34;Marion&#34;, &#34;Marina&#34;, &#34;Marine&#34;, &#34;Maria&#34;, &#34;Marianne&#34;,
                                &#34;Diana&#34;, &#34;Diane&#34;, &#34;Gertrude&#34;, &#34;Geraldine&#34;, &#34;Alexandra&#34;, &#34;Alexandria&#34;,
                                &#34;Alexandrine&#34;, &#34;Alexia&#34;, &#34;Huguette&#34;, &#34;Marguerite&#34;, &#34;Margot&#34;, &#34;Molly&#34;]
        
        #get a random name from the list
        self.__name = random.choice(self.__available_names)

    @abstractmethod
    def draw(self):
        pass

    @abstractmethod
    def tick(self):
        pass
    
    @property
    def name(self):
        return self.__name


class Circle(Entity):
    def __init__(self, border_color = RGBAColor(randomize=True), border_width = 5, fill_color = RGBAColor(0,0,0,255),  position=Vect2D(random.randrange(0,1000),random.randrange(0,500)), radius:int=50):
        Entity.__init__(self, border_color=border_color, border_width=border_width, fill_color=fill_color, position=position, size=Vect2D(radius*2, radius*2))
        self.__radius = radius

    @property
    def radius(self):
        return self.__radius

    @radius.setter
    def radius(self, radius):
        self.__radius = radius

    def draw(self, draw):
        self.fill_color
        draw.ellipse(
                [self.position.x - self.__radius,
                self.position.y - self.__radius,
                self.position.x + self.__radius,
                self.position.y + self.__radius],
                fill=self.fill_color,
                width=self.border_width,
                outline=self.border_color)

    @abstractmethod
    def tick(self, time):
        pass


class DynamicCircle(Circle, Movable, Piloted):
    def __init__(   self,
                    border_color=RGBAColor(randomize=True),
                    border_width=5,
                    fill_color=RGBAColor(randomize=True),
                    position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                    radius=random.randint(10, 50),
                    acceleration=Vect2D(0,0),
                    speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                    max_speed= 100,
                    max_steering_force=50,
                    steering_force=Vect2D(0,0),
                    steering_behaviors=None,
                ):
    
        Circle.__init__(self, border_color, border_width, fill_color, position, radius)
        Movable.__init__(self, acceleration, max_speed, speed)
        Piloted.__init__(self, max_steering_force, steering_force, steering_behaviors)
        
    def draw(self, draw):
        Circle.draw(self, draw)

    def draw_circle_speed(self, draw):
        draw.line([self.position.x, self.position.y, self.position.x + self.speed.x, self.position.y + self.speed.y], fill=&#34;red&#34;, width=5)
        
    def draw_circle_steering_force(self, draw):
        draw.line([self.position.x, self.position.y, self.position.x + self.steering_force.x * 10, self.position.y + self.steering_force.y * 10], fill=&#34;darkgoldenrod&#34;, width=5)
        for steering_behavior in self.steering_behaviors:
            if hasattr(steering_behavior, &#34;draw&#34;):
                    steering_behavior.draw(draw)
            
    def move(self, time):
        Movable.move(self, time)

    def tick(self, time):
        self.steer()
        self.move(time)


class SentientCircle(DynamicCircle):
    def __init__(self, border_color=RGBAColor(randomize=True), border_width=5, fill_color=RGBAColor(randomize=True), position=Vect2D(random.randrange(0,1000),random.randrange(0,500)), radius=random.randint(10, 50), acceleration=Vect2D(0,0), speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)), max_speed= 100, max_steering_force=5, steering_force=Vect2D(0,0), steering_behaviors=None, environment=None, brain=None, eyes=None):
        DynamicCircle.__init__(self, border_color, border_width, fill_color, position, radius, acceleration, speed, max_speed, max_steering_force, steering_force, steering_behaviors)

        self.__brain = brain if brain else Brain(self, environment)
        
        self.__eyes = eyes if eyes else [Eye(self)]

    def tick(self, time):
        DynamicCircle.tick(self, time)
        self.__brain.process()

    def draw_fov(self, draw):
        for eye in self.__eyes:
            eye.draw(draw)    
        self.__brain.draw_line_to_seen_entities(draw)

    def draw_circle_steering_force(self, draw):
        draw.line([self.position.x, self.position.y, self.position.x + self.steering_force.x * 10, self.position.y + self.steering_force.y * 10], fill=&#34;darkgoldenrod&#34;, width=5)
        for steering_behavior in self.__brain.active_behaviors:
            if hasattr(steering_behavior, &#34;draw&#34;):
                    steering_behavior.draw(draw)
                    
    @property
    def eyes(self):
        return self.__eyes
    
    @property
    def brain(self):
        return self.__brain
    
    @eyes.setter
    def eyes(self, eyes):
        self.__eyes = eyes
        
    @brain.setter
    def brain(self, brain):
        self.__brain = brain


class PredatorCircle(SentientCircle):
    def __init__(self, border_color=RGBAColor(randomize=True), border_width=5, fill_color=RGBAColor(randomize=True), position=Vect2D(random.randrange(0,1000),random.randrange(0,500)), radius=random.randint(10, 50), acceleration=Vect2D(0,0), speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)), max_speed= 100, max_steering_force=5, steering_force=Vect2D(0,0), steering_behaviors=None, fov=math.pi/2, range=100, environment=None):
        SentientCircle.__init__(self, border_color, border_width, fill_color, position, radius, acceleration, speed, max_speed, max_steering_force, steering_force, steering_behaviors, fov, range, environment)

        predator_dict = {                   &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Pursuit, &#34;Target_type&#34; : &#34;single&#34; }, 
                                            &#34;SentientCircle&#34;: { &#34;Behavior&#34;: Pursuit, &#34;Target_type&#34; : &#34;grouping&#34; },
                                            &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                            &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                            &#34;PredatorCircle&#34;: { &#34;Behavior&#34;: Alignment, &#34;Target_type&#34; : &#34;grouping&#34; },
                                            &#34;PreyCircle&#34;: { &#34;Behavior&#34;: Seek, &#34;Target_type&#34; : &#34;single&#34; },
                                            &#34;No_target&#34;: { &#34;Behavior&#34;: PseudoWander, &#34;Target_type&#34; : &#34;none&#34; }
                        }

        self.brain = Brain(self, environment, predator_dict)    
        self.eyes = [Eye(self, fov = 20, range = 400)]
        

class PreyCircle(SentientCircle):
    def __init__(self, border_color=RGBAColor(randomize=True), border_width=5, fill_color=RGBAColor(randomize=True), position=Vect2D(random.randrange(0,1000),random.randrange(0,500)), radius=random.randint(10, 50), acceleration=Vect2D(0,0), speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)), max_speed= 100, max_steering_force=5, steering_force=Vect2D(0,0), steering_behaviors=None, fov=math.pi/2, range=100, environment=None):
        SentientCircle.__init__(self, border_color, border_width, fill_color, position, radius, acceleration, speed, max_speed, max_steering_force, steering_force, steering_behaviors, fov, range, environment)

        prey_dict = {                   &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; }, 
                                        &#34;SentientCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;grouping&#34; },
                                        &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;PredatorCircle&#34;: { &#34;Behavior&#34;: Flee, &#34;Target_type&#34; : &#34;grouping&#34; },
                                        &#34;PreyCircle&#34;: { &#34;Behavior&#34;: Cohesion, &#34;Target_type&#34; : &#34;grouping&#34; },    
                                        &#34;No_target&#34;: { &#34;Behavior&#34;: Wander, &#34;Target_type&#34; : &#34;none&#34; }
                        }
        self.brain = Brain(self, environment, prey_dict)    
        self.eyes = [Eye(self, fov = 95, range = 100)]


class Simulation(Updatable):
    &#34;&#34;&#34; La classe Simulation correspond à la simulation elle-même. 
        Elle contient les sprites, la taille de l&#39;image, la position de la souris, et la boucle de jeu qui bouge les Entities.
        Elle contient aussi les fonctions de dessin, qui sont appelées par la fonction draw() de la classe Window.
       
        Args:
            - :param size: Vect2D, la taille de la fenêtre
            - :param sprites: list, la liste des sprites
            - :param mouse_pos: Vect2D, la position de la souris
            - :param is_running: bool, True si la simulation est en cours, False sinon
            - :param seed: int, le seed pour la génération aléatoire
            - :param selected_entity: Entity, l&#39;entité sélectionnée par le click de la souris
        
        Exemples: Créé une simulation et l&#39;initialise un scénario
        &gt;&gt;&gt; sim = Simulation()
        &gt;&gt;&gt; sim.initialize_scenario(key=&#34;Seek, Flee or Wander&#34;)
        &gt;&gt;&gt; print(len(sim.sprites))
        250
    &#34;&#34;&#34;
    def __init__(self, size=Vect2D(100,100)):
        self.__size = size
        self.__sprites = []
        self.__mouse_pos = Vect2D(-1, -1)
        self.__is_running = True
        self.__seed = 0
        self.__selected_entity = None
        
        self.initialize_scenario()

    def initialize_scenario(self, key:str=&#34;Red chasing Green&#34;): 
        key = key.replace(&#34;\n&#34;, &#34;&#34;)
        nb_balls = 0
                
        match key:
            case &#39;Seek, Flee or Wander&#39;:
                nb_balls = 250
                for i in range(nb_balls):
                    self.__sprites.append(DynamicCircle(    border_color=RGBAColor(randomize=True),
                                                            border_width=5,
                                                            fill_color=RGBAColor(randomize=True),
                                                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                            radius=random.randint(10, 50),
                                                            acceleration=Vect2D(0,0),
                                                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                            max_speed= 100,
                                                            max_steering_force=5,
                                                            steering_force=Vect2D(0,0),
                                                            steering_behaviors=[BorderRepulsion(sim_dim=self.__size)]))

                for sprite in self.__sprites:
                    random_sprite = random.choice(self.__sprites)
                    while random_sprite == sprite:
                        random_sprite = random.choice(self.__sprites)

                    random_steering_behavior = random.choice([Seek([random_sprite]), Flee([random_sprite]), Wander()])
                    sprite.steering_behaviors.append(random_steering_behavior)
                    sprite.fill_color = RGBAColor(0, 128, 0, 255) if type(random_steering_behavior) is Flee else RGBAColor(128, 0, 0, 255) if type(random_steering_behavior) is Seek else RGBAColor(0, 0, 128, 255)

            case &#39;Seek or Flee Mouse&#39;:
                nb_balls = 20
                for i in range(nb_balls):
                    random_steering_behavior = random.choice([Seek([self.__mouse_pos]), Flee([self.__mouse_pos])])

                    self.__sprites.append(DynamicCircle(    border_color=RGBAColor(randomize=True),
                                                            border_width=5,
                                                            fill_color = RGBAColor(0, 128, 0, 255) if type(random_steering_behavior) is Flee else RGBAColor(128, 0, 0, 255) if type(random_steering_behavior) is Seek else RGBAColor(0, 0, 128, 255),
                                                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                            radius=random.randint(10, 50),
                                                            acceleration=Vect2D(0,0),
                                                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                            max_speed= 100,
                                                            max_steering_force=5,
                                                            steering_force=Vect2D(0,0),
                                                            steering_behaviors=[Wander(), random_steering_behavior, BorderRepulsion(sim_dim=self.__size)]))

            case &#39;Follow the leader&#39;:
                nb_balls = 20
                for i in range(nb_balls):
                    self.__sprites.append(DynamicCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                        speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                        fill_color = RGBAColor(128, 0, 128, 255)  if len(self.__sprites) == nb_balls-1 else RGBAColor(128, 128, 0, 255),
                                                        border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        radius=random.randint(10, 50),
                                                        acceleration=Vect2D(0,0),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        steering_behaviors=[Wander(), BorderRepulsion(sim_dim=self.__size)] if i == nb_balls-1 else [BorderRepulsion(sim_dim=self.__size)]))

                for i, sprite in enumerate(self.__sprites):
                    if i != len(self.__sprites)-1:
                        sprite.steering_behaviors.append(Pursuit([self.__sprites[i-1]]))
                        sprite.radius = (nb_balls - i - 1) * 2
                    else: sprite.radius = nb_balls * 2
                    
            case &#39;Cohesion&#39;:
                nb_balls = 50
                for i in range(nb_balls):
                                self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                                                            border_width=5,
                                                            fill_color=RGBAColor(randomize=True),
                                                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                            radius=random.randint(5, 10),
                                                            acceleration=Vect2D(0,0),
                                                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                            max_speed= 100,
                                                            max_steering_force=5,
                                                            steering_force=Vect2D(0,0),
                                                            environment=self
                                                            ))
        
            case &#39;Alignment&#39;:
                nb_balls = 50

                behavior_patterns =  {  &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; }, 
                                        &#34;SentientCircle&#34;: { &#34;Behavior&#34;: Alignment, &#34;Target_type&#34; : &#34;grouping&#34; },
                                        &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;No_target&#34;: { &#34;Behavior&#34;: Wander, &#34;Target_type&#34; : &#34;none&#34; }
                                    }

                for i in range(nb_balls):
                                self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                                                            border_width=5,
                                                            fill_color=RGBAColor(randomize=True),
                                                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                            radius=random.randint(5, 10),
                                                            acceleration=Vect2D(0,0),
                                                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                            max_speed= 100,
                                                            max_steering_force=5,
                                                            steering_force=Vect2D(0,0),
                                                            environment=self
                                                            ))
                for sprite in self.__sprites:
                    sprite.brain.behavior_patterns = behavior_patterns


            case &#39;Follow Biggest Boid Seen&#39;:
                nb_balls = 50

                behavior_patterns =  {  &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; }, 
                                        &#34;SentientCircle&#34;: { &#34;Behavior&#34;: FollowBiggestBoidSeen, &#34;Target_type&#34; : &#34;grouping&#34; },
                                        &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;No_target&#34;: { &#34;Behavior&#34;: Wander, &#34;Target_type&#34; : &#34;none&#34; }
                                    }
                eye_fov = 500
                eye_range = 150

                for i in range(nb_balls):
                                self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                                                            border_width=5,
                                                            fill_color=RGBAColor(randomize=True),
                                                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                            radius=random.randint(5, 50),
                                                            acceleration=Vect2D(0,0),
                                                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                            max_speed= 100,
                                                            max_steering_force=5,
                                                            steering_force=Vect2D(0,0),
                                                            environment=self
                                                            ))

                for sprite in self.__sprites:
                    sprite.brain.behavior_patterns = behavior_patterns
                    sprite.eye.fov = eye_fov
                    sprite.eye.range = eye_range

            case &#34;Rise of Sentience&#34;:
                nb_sentients = 10
                nb_dumbs = 10
                for i in range(nb_sentients):
                    self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                            border_width=5,
                            radius=10,
                            fill_color=RGBAColor(randomize=True),
                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                            acceleration=Vect2D(0,0),
                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                            max_speed= 100,
                            max_steering_force=5,
                            steering_force=Vect2D(0,0),
                            environment=self
                            ))

                for i in range(nb_dumbs):
                    self.__sprites.append(DynamicCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                        speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                        border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        radius=25,
                                                        fill_color= RGBAColor(33,33,33,255),
                                                        acceleration=Vect2D(0,0),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        steering_behaviors=[Wander(), BorderRepulsion(sim_dim=self.__size)]))


            case &#39;Predator Chasing Prey&#39;: # Default
                nb_obstacles = 5
                nb_predators = 2
                nb_preys = 10
                for _ in range(nb_predators):
                    self.__sprites.append(PredatorCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                        speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                        border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        acceleration=Vect2D(0,0),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        environment=self,
                                                        fill_color=RGBAColor(255,0,0,255)
                                                       ))
                for _ in range(nb_preys):
                    self.__sprites.append(PreyCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                        speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                        border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        acceleration=Vect2D(0,0),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        environment=self,
                                                        fill_color=RGBAColor(0,255,0,255)
                                                       ))
                for _ in range(nb_obstacles):
                    self.__sprites.append(Circle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height)))))
            
            case &#39;Avoid Obstacles&#39;:
                nb_obstacles = 20
                nb_sentient_circles = 10
                        
                for _ in range(nb_obstacles):
                    self.__sprites.append(Circle(   position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                    radius=25))

                for _ in range(nb_sentient_circles):
                    self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                    border_width=5,
                    radius=10,
                    fill_color=RGBAColor(randomize=True),
                    position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                    acceleration=Vect2D(0,0),
                    speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                    max_speed= 100,
                    max_steering_force=5,
                    steering_force=Vect2D(0,0),
                    environment=self
                    ))


            case &#39;Red chasing Green&#39;: # Default
                nb_balls = 6
                for i in range(nb_balls):
                    self.__sprites.append(DynamicCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                        speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                        border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        acceleration=Vect2D(0,0),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        steering_behaviors=[Wander(), BorderRepulsion(sim_dim=self.__size)] if i%2 == 0 else [Pursuit([self.sprites[i-1]]), BorderRepulsion(sim_dim=self.__size)]))

                for i, sprite in enumerate(self.__sprites):
                    sprite.fill_color = RGBAColor(128, 0, 0, 255) if type(sprite.steering_behaviors[0]) is Pursuit else RGBAColor(0, 128, 0, 255)
                    sprite.radius = 60 if type(sprite.steering_behaviors[0]) is Pursuit else 30
                    if i%2 == 0 and i != len(self.__sprites) - 1:
                        self.__sprites[i].steering_behaviors.append(Evade([self.__sprites[i+1]]))

    def tick(self, time):
        &#34;&#34;&#34;Fait bouger les Entities, est appelée par la fonction update() de la classe App&#34;&#34;&#34;
        if self.__sprites:
            for sprite in self.__sprites:
                sprite.tick(time)

    def reset(self, key:str=&#34;Red chasing Green&#34;):
        &#34;&#34;&#34;Remet la simulation à zéro&#34;&#34;&#34;
        self.__is_running = True
        self.__sprites = []
        self.initialize_scenario(key)

    def move_mouse(self, event):
        &#34;&#34;&#34;Met à jour la position de la souris&#34;&#34;&#34;
        self.__mouse_pos.set(event.x, event.y)
        
    def mouse_left(self, event):
        &#34;&#34;&#34;Gère la sortie de la souris de la fenêtre&#34;&#34;&#34;
        self.__mouse_pos.set(-1, -1)
        
        for sprite in self.__sprites:
            sprite.steering_force = Vect2D(0,0)

    def mouse_entered(self, event):
        &#34;&#34;&#34;Gère l&#39;entrée de la souris dans la fenêtre&#34;&#34;&#34;
        self.__mouse_pos.set(event.x, event.y)
        
    def toggle_running(self, event):
        &#34;&#34;&#34;Met en pause ou en reprend la simulation&#34;&#34;&#34;
        self.__is_running = not self.__is_running
        
    def check_entity_clicked(self, event):
        &#34;&#34;&#34;Vérifie si une entité a été cliquée avec un offset de 20 pixels pour le miss click&#34;&#34;&#34;
        radius_offset = 20
        for sprite in reversed(self.__sprites):
            if sprite.position.x - (sprite.radius + radius_offset) &lt; event.x &lt; sprite.position.x + (sprite.radius + radius_offset) and sprite.position.y - (sprite.radius + radius_offset) &lt; event.y &lt; sprite.position.y + (sprite.radius + radius_offset):
                return sprite

    @property
    def selected_entity(self):
        &#34;&#34;&#34;Retourne l&#39;entité sélectionnée&#34;&#34;&#34;
        return self.__selected_entity
    
    @selected_entity.setter
    def selected_entity(self, value):
        &#34;&#34;&#34;Définit l&#39;entité sélectionnée&#34;&#34;&#34;
        self.__selected_entity = value

    @property
    def sprites(self):
        &#34;&#34;&#34;Retourne la liste des sprites&#34;&#34;&#34;
        return self.__sprites
    
    @property
    def mouse_pos(self):
        &#34;&#34;&#34;Retourne la position de la souris&#34;&#34;&#34;
        return self.__mouse_pos
    
    @property
    def size(self):
        &#34;&#34;&#34;Retourne la taille de la fenêtre&#34;&#34;&#34;
        return self.__size

    @property
    def width(self):
        &#34;&#34;&#34;Retourne la largeur de la fenêtre&#34;&#34;&#34;
        return self.__size.x

    @property
    def height(self):
        &#34;&#34;&#34;Retourne la hauteur de la fenêtre&#34;&#34;&#34;
        return self.__size.y
    
    @property
    def is_running(self):
        &#34;&#34;&#34;Retourne True si la simulation est en cours, False sinon&#34;&#34;&#34;
        return self.__is_running


#   _______  __    __   __ 
#  /  _____||  |  |  | |  |
# |  |  __  |  |  |  | |  |
# |  | |_ | |  |  |  | |  |
# |  |__| | |  `--&#39;  | |  |
#  \______|  \______/  |__|

class GUI(ttk.Frame, Drawable):
    def __init__(self, border_color=None, border_width=None, fill_color=None, position=None, size:Vect2D=None):
        ttk.Frame.__init__(self, root=None, text=None)
        Drawable.__init__(self, border_color,  border_width, fill_color, position, size)
        self.__main_panel = ControlBar()
        self.__view_window = ViewWindow(size=Vect2D(size.x, size.y), fill_color=fill_color)
        self.__main_panel.grid(row=0, column=1)
        self.__view_window.grid(row=0, column=1, rowspan=4, sticky=&#34;ns&#34;)

    @property
    def main_panel(self):
        return self.__main_panel

    @property
    def view_window(self):
        return self.__view_window

class ControlBar(ttk.Frame):
    def __init__(self):
        ttk.Frame.__init__(self)
        self.__control_panel = StartStopPanel(&#34;Controls&#34;)
        self.__param_panel = ParamPanel(&#34;Scenarios&#34;)
        self.__visual_param_panel = VisualParamPanel(&#34;Visual Parameters&#34;)
        self.__Info_panel = InfoPanel(&#34;Selected Entity Informations&#34;)
        self.__control_panel.grid(row=0, column=0, sticky=&#34;N&#34;)
        self.__param_panel.grid(row=1, column=0, sticky=&#34;N&#34;)
        self.__visual_param_panel.grid(row=2, column=0, sticky=&#34;N&#34;)
        self.__Info_panel.grid(row=3, column=0, sticky=&#34;N&#34;)

    @property
    def param_panel(self):
        return self.__param_panel
    
    @property
    def control_panel(self):
        return self.__control_panel
    
    @property
    def visual_param_panel(self):
        return self.__visual_param_panel
    
    @property
    def info_panel(self):
        return self.__Info_panel

class StartStopPanel(ttk.LabelFrame):
    def __init__(self, text): 
        ttk.LabelFrame.__init__(self, root=None, text=text)
        self.__start_stop_button = ttk.Button(self, text=&#34;Stop&#34;, width = 40)
        self.__next_button = ttk.Button(self, text=&#34;Next Step&#34;, state=&#34;disabled&#34;, width = 40)
        self.__reset_button = ttk.Button(self, text=&#34;Reset&#34;, width = 40)
        self.__start_stop_button.grid(row=0, column=0)
        self.__next_button.grid(row=1, column=0)
        self.__reset_button.grid(row=2, column=0)
        
    @property
    def start_stop_button(self):
        return self.__start_stop_button
    
    @property
    def next_button(self):
        return self.__next_button
    
    @property
    def reset_button(self):
        return self.__reset_button


class InfoPanel(ttk.LabelFrame):
    def __init__(self, text):
        ttk.LabelFrame.__init__(self, root=None, text=text)
        self.__info_label = tk.Text(self, width=30, height=20)
        self.__set_text(&#34;Click on a boid to show the infomations about it&#34;)
        self.__info_label.grid(row=0, column=0)
        
        self.__info_entity = None
        self.__info_string = &#34;&#34;

    @property
    def info_label(self):
        return self.__info_label
    
    def __set_text(self, text):
        self.__info_label.config(state=tk.NORMAL)
        self.__info_label.delete(1.0, tk.END)
        self.__info_label.insert(tk.END, text)
        self.__info_label.config(state=tk.DISABLED)
        
    @property
    def info_entity(self):
        return self.__info_entity
    
    @property
    def info_string(self):
        return self.__info_string

    def update(self):
        if self.__info_entity is not None:
            self.__info_string = &#34;Name: &#34; + self.__info_entity.name + &#34;\n&#34;
            self.__info_string += &#34;Position: ({}, {})&#34;.format(math.trunc(self.__info_entity.position.x), math.trunc(self.__info_entity.position.y)) + &#34;\n&#34;
            self.__info_string += &#34;Speed: ({}, {})&#34;.format(math.trunc(self.__info_entity.speed.x), math.trunc(self.__info_entity.speed.y)) + &#34;\n&#34;
            self.__info_string += &#34;Steering force: ({}, {})&#34;.format(math.trunc(self.__info_entity.steering_force.x), math.trunc(self.__info_entity.steering_force.y)) + &#34;\n&#34;
            if isinstance(self.__info_entity, Circle):
                self.__info_string += &#34;Radius: {}&#34;.format(self.__info_entity.radius) + &#34;\n&#34;
            self.__info_string += &#34;Steering forces: &#34; + &#34;\n&#34;
            if self.__info_entity.steering_behaviors is not None:
                for steering_behavior in self.__info_entity.steering_behaviors:
                    self.__info_string += &#34;    &#34; + steering_behavior.__class__.__name__ + &#34;\n&#34;
                    if steering_behavior.target_entities is not None:
                        for target_entity in steering_behavior.target_entities:
                            if isinstance(target_entity, Entity):
                                self.__info_string += &#34;        &#34; + target_entity.name + &#34;\n&#34;
            elif hasattr(self.__info_entity, &#39;brain&#39;) and self.__info_entity.brain is not None and self.__info_entity.brain.active_behaviors is not None and hasattr(self.__info_entity.brain, &#39;active_behaviors&#39;):
                for steering_behavior in self.__info_entity.brain.active_behaviors:
                    self.__info_string += &#34;    &#34; + steering_behavior.__class__.__name__ + &#34;\n&#34;
                    if steering_behavior.target_entities is not None:
                        for target_entity in steering_behavior.target_entities:
                            if isinstance(target_entity, Entity):
                                self.__info_string += &#34;        &#34; + target_entity.name + &#34;\n&#34;
                
            else:
                self.__info_string += &#34;    None\n&#34;
            
            if hasattr(self.__info_entity, &#39;eyes&#39;) and hasattr(self.__info_entity, &#39;brain&#39;) and self.__info_entity.eyes is not None:
                self.__info_string += &#34;Eyes: &#34; + &#34;\n&#34;
                for eye in self.__info_entity.eyes:
                    self.__info_string += &#34;    &#34; + str(self.__info_entity.eyes.index(eye)) +&#34; (FOV: &#34; + str(math.trunc(eye.fov)) + &#34;, Range: &#34; + str(eye.range) + &#34;): &#34; + &#34;\n&#34;
                    for seen_entity in self.__info_entity.brain.seen_entities:
                        self.__info_string += &#34;        &#34; + seen_entity.name + &#34;:&#34; + seen_entity.__class__.__name__ + &#34;\n&#34;

            self.__info_string += &#34;\nClick again to hide info.&#34;
            
            self.__set_text(self.__info_string)
        else:
            self.__set_text(&#34;Click on an entity to show it&#39;s informations&#34;)
    
    @info_entity.setter
    def info_entity(self, entity):
        self.__info_entity = entity
        self.update()


class ViewWindow(ttk.Label, Drawable):
    def __init__(self, border_color=None, border_width=None, fill_color=None, position=None, size=None):
        ttk.Label.__init__(self, root=None, text=None, width=size.x)
        Drawable.__init__(self, border_color, border_width, fill_color, position, size)
        self.__background = Image.open(&#34;tropicalforest.jpg&#34;)
        self.sizex = size.x
        self.sizey = size.y
        self.__resized = self.__background.resize((int(size.x), int(size.y)))
        self.__image_draw = ImageDraw.Draw(self.__resized)
        self.__image_tk = ImageTk.PhotoImage(self.__resized)
        self.__image_label = ttk.Label(self, image=self.__image_tk)
        self.__image_label.grid(row=0, column=0, sticky=&#39;ns&#39;)
        self.__image_label.columnconfigure(0, minsize=600, weight=1)
        self.__speed_is_drawn = False
        self.__steering_force_is_drawn = False
        self.__circle_is_drawn = True
        self.__fov_is_drawn = False
        self.__crazy_mode = False
        self.__jungle_background = False

    def update_view(self, simulation):
            if self.__crazy_mode:
                i = self.__resized
                draw = ImageDraw.Draw(i)
            else:
                if self.__jungle_background:
                    self.__newbackground = Image.open(&#34;tropicalforest.jpg&#34;)
                else :
                    self.__newbackground = Image.new(&#39;RGBA&#39;, (int(self.sizex), int(self.sizey)), (0, 0, 0))
                i = self.__newbackground.resize((int(self.sizex), int(self.sizey)))
                draw = ImageDraw.Draw(i)
            
            if self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)                     
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
                        sprite.draw_circle_steering_force(draw)
                   
            elif self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
                        sprite.draw_circle_steering_force(draw)
            elif self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)   
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
                        sprite.draw_circle_steering_force(draw)                 
            elif self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
                        sprite.draw_circle_steering_force(draw)
            elif self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)                         
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
            elif self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
            elif self.__speed_is_drawn and not self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
            elif self.__speed_is_drawn and not self.__steering_force_is_drawn and not self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
            elif not self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_steering_force(draw)
            elif not self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_steering_force(draw)
            elif not self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw) 
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):                   
                        sprite.draw_circle_steering_force(draw)
            elif not self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_steering_force(draw)
            elif not self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)
                    sprite.draw(draw)
            elif not self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    sprite.draw(draw)
            elif not self.__speed_is_drawn and not self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)   
                        
            if simulation.selected_entity:
                simulation.selected_entity.draw(draw)
                if hasattr(simulation.selected_entity, &#34;draw_circle_speed&#34;):
                    simulation.selected_entity.draw_circle_speed(draw)                
                    simulation.selected_entity.draw_circle_steering_force(draw)    
                if hasattr(simulation.selected_entity, &#39;draw_fov&#39;):
                    simulation.selected_entity.draw_fov(draw)
        
            self.__image_tk = ImageTk.PhotoImage(i)
            self.__image_label[&#34;image&#34;] = self.__image_tk 
            
    def toggle_draw_fov(self, event):
        self.__fov_is_drawn = not self.__fov_is_drawn
    
    def toggle_draw_circle(self, event):
        self.__circle_is_drawn = not self.__circle_is_drawn
            
    def toggle_draw_steering_force(self, event):
        self.__steering_force_is_drawn = not self.__steering_force_is_drawn

    def toggle_draw_speed(self, event):
        self.__speed_is_drawn = not self.__speed_is_drawn

    def toggle_crazy_mode(self, event):
        self.__crazy_mode = not self.__crazy_mode

    def toggle_jungle_background(self, event):
        self.__jungle_background = not self.__jungle_background

    @property
    def canvas(self):
        return self.__canvas

    @property
    def image_draw(self):
        return self.__image_draw     

    @property
    def image_label(self):
        return self.__image_label    

    @canvas.setter
    def canvas(self, canvas):
        self.__canvas = canvas


class ParamPanel(ttk.LabelFrame):
    def __init__(self, title):
        ttk.LabelFrame.__init__(self, root=None, text=title)
        self.__param_selected = tk.StringVar()
        self.__param_selected.set(&#34;Red chasing Green&#34;)
        self.__options_list = Utils.readfile(&#34;scenarios.txt&#34;)
        self.__combobox = ttk.Combobox(self, values=self.__options_list, textvariable=self.__param_selected, cursor=&#34;hand2&#34;, style=&#34;TCombobox&#34;,state=&#34;readonly&#34;, width=37)
    
        self.__combobox.pack()
        
    @property
    def param_selected(self):
        return self.__param_selected.get()
        
    @property
    def combobox(self):
        return self.__combobox


class VisualParamPanel(ttk.LabelFrame):
    def __init__(self, title):
        ttk.LabelFrame.__init__(self, root=None, text=title)
        self.__width_var = 28
        self.__speed_var = tk.IntVar()
        self.__speed_checkbutton = ttk.Checkbutton(self, text=&#34;Show Speed&#34;, variable=self.__speed_var, onvalue=1, offvalue=0, width=self.__width_var)
        self.__speed_checkbutton.pack(padx=(50, 0))
        self.__steering_force_var = tk.IntVar()
        self.__steering_force_checkbutton = ttk.Checkbutton(self, text=&#34;Show Steers&#34;, variable=self.__steering_force_var, onvalue=1, offvalue=0, width=self.__width_var)
        self.__steering_force_checkbutton.pack(padx=(50, 0))
        self.__show_circle_var = tk.IntVar()
        self.__show_circle_checkbutton = ttk.Checkbutton(self, text=&#34;Show Circles&#34;, variable=self.__show_circle_var, onvalue=0, offvalue=1, width=self.__width_var)  
        self.__show_circle_checkbutton.pack(padx=(50, 0))
        self.__show_fov_var = tk.IntVar()
        self.__show_fov_checkbutton = ttk.Checkbutton(self, text=&#34;Show F-o-V&#34;, variable=self.__show_fov_var, onvalue=1, offvalue=0, width=self.__width_var)
        self.__show_fov_checkbutton.pack(padx=(50, 0))
        self.__jungle_background_var = tk.IntVar()
        self.__jungle_background_checkbutton = ttk.Checkbutton(self, text=&#34;Jungle background&#34;, variable=self.__jungle_background_var, onvalue=1, offvalue=0, width=self.__width_var)
        self.__jungle_background_checkbutton.pack(padx=(50, 0))
        self.__crazy_mode_var = tk.IntVar()
        self.__crazy_mode_checkbutton = ttk.Checkbutton(self, text=&#34;Crazy Mode&#34;, variable=self.__crazy_mode_var, onvalue=1, offvalue=0, width=self.__width_var)
        self.__crazy_mode_checkbutton.pack(padx=(50, 0))

    @property
    def show_fov_checkbutton(self):
        return self.__show_fov_checkbutton

    @property
    def show_circle_checkbutton(self):
        return self.__show_circle_checkbutton

    @property
    def steering_force_checkbutton(self):
        return self.__steering_force_checkbutton
    
    @property
    def speed_checkbutton(self):
        return self.__speed_checkbutton

    @property
    def crazy_mode_checkbutton(self):
        return self.__crazy_mode_checkbutton

    @property
    def jungle_background_checkbutton(self):
        return self.__jungle_background_checkbutton


class SimParamPanel(ParamPanel):
    def __init__(self):
        pass    
    
#  __________   ___  _______   ______  __    __  .___________. __    ______   .__   __.
# |   ____\  \ /  / |   ____| /      ||  |  |  | |           ||  |  /  __  \  |  \ |  |
# |  |__   \  V  /  |  |__   |  ,----&#39;|  |  |  | `---|  |----`|  | |  |  |  | |   \|  |
# |   __|   &gt;   &lt;   |   __|  |  |     |  |  |  |     |  |     |  | |  |  |  | |  . `  |
# |  |____ /  .  \  |  |____ |  `----.|  `--&#39;  |     |  |     |  | |  `--&#39;  | |  |\   |
# |_______/__/ \__\ |_______| \______| \______/      |__|     |__|  \______/  |__| \__|
class App(Tk, Updatable):
    def __init__(self):
        Tk.__init__(self)
        self.__size = Vect2D(Tk.winfo_screenwidth(self) * 0.8, Tk.winfo_screenheight(self) * 0.8)
        self.__gui = GUI(size=Vect2D(self.__size.x, self.__size.y), fill_color=RGBAColor(0 ,0, 0)) 
        self.title(&#39;Boids&#39;)
        self.geometry(&#34;{}x{}+{}+{}&#34;.format(int(self.width), (int(self.height)), int(Tk.winfo_screenwidth(self) * 0.5 - self.width * 0.5), 0 + int(Tk.winfo_screenwidth(self) * 0.50 - self.height)))
        self.geometry()
        self.iconbitmap(&#39;boids.ico&#39;)
        self.__simulation = Simulation(size=Vect2D(self.__gui.view_window.width, self.__gui.view_window.height))
        
        self.__gui.main_panel.visual_param_panel.speed_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_draw_speed)
        self.__gui.main_panel.visual_param_panel.steering_force_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_draw_steering_force)
        self.__gui.main_panel.visual_param_panel.show_circle_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_draw_circle)
        self.__gui.main_panel.visual_param_panel.show_fov_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_draw_fov)
        self.__gui.main_panel.visual_param_panel.crazy_mode_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_crazy_mode)
        self.__gui.main_panel.visual_param_panel.jungle_background_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_jungle_background)
        self.__gui.view_window.image_label.bind(&#39;&lt;Enter&gt;&#39;, self.__simulation.mouse_entered)
        self.__gui.view_window.image_label.bind(&#39;&lt;Motion&gt;&#39;, self.__simulation.move_mouse)
        self.__gui.view_window.image_label.bind(&#39;&lt;Leave&gt;&#39;, self.__simulation.mouse_left)
        self.__gui.main_panel.control_panel.start_stop_button.bind(&#39;&lt;Button-1&gt;&#39;, self.toggle_simulation)
        self.__gui.main_panel.control_panel.next_button.bind(&#39;&lt;Button-1&gt;&#39;, self.tick_simulation)
        self.__gui.main_panel.control_panel.next_button.bind(&#39;&lt;space&gt;&#39;, self.tick_simulation)
        self.__gui.main_panel.control_panel.reset_button.bind(&#39;&lt;Button-1&gt;&#39;, self.reset_simulation)
        self.__gui.main_panel.param_panel.combobox.bind(&#39;&lt;&lt;ComboboxSelected&gt;&gt;&#39;, self.param_changed)
        self.__gui.view_window.image_label.bind(&#39;&lt;Button-1&gt;&#39;, self.mouse_clicked_on_image)

        self.tick()
                
        self.mainloop()

    def param_changed(self, event):
        self.reset_simulation()

    @property
    def size(self):
        return self.__size
    
    def mouse_clicked_on_image(self, event):
        clicked_entity = self.__simulation.check_entity_clicked(event)
        if clicked_entity is not None:
            if clicked_entity is self.__gui.main_panel.info_panel.info_entity:
                self.__gui.main_panel.info_panel.info_entity = None
                self.__simulation.selected_entity = None
            else:
                self.__gui.main_panel.info_panel.info_entity = clicked_entity
                self.__simulation.selected_entity = clicked_entity

    def tick_simulation(self, event=None):
        self.__simulation.tick(time=0.1)
        
    def reset_simulation(self, event=None) -&gt; None:
        key = self.__gui.main_panel.param_panel.param_selected
        self.__gui.main_panel.control_panel.start_stop_button.config(text=&#34;Stop&#34;)
        self.__gui.main_panel.control_panel.next_button.config(state=&#34;disabled&#34;)
        self.__simulation.reset(key)
        self.__simulation.selected_entity = None
        self.__gui.main_panel.info_panel.info_entity = None

    def update_info_panel(self):
        self.__gui.main_panel.info_panel.set_text(self.__info_string)

    def tick(self):
        if self.__simulation.is_running:
            self.tick_simulation()
        self.__gui.main_panel.info_panel.update()
        self.__gui.view_window.update_view(self.__simulation)
        self.after(10, self.tick)
        
    def toggle_simulation(self, event):
        self.__simulation.toggle_running(event)
        if self.__simulation.is_running:
            self.__gui.main_panel.control_panel.start_stop_button.config(text=&#34;Stop&#34;)
            self.__gui.main_panel.control_panel.next_button.config(state=&#34;disabled&#34;)
        else:
            self.__gui.main_panel.control_panel.start_stop_button.config(text=&#34;Start&#34;)
            self.__gui.main_panel.control_panel.next_button.config(state=&#34;normal&#34;)
             
    @property
    def width(self):
        return self.__size.x

    @property
    def height(self):
        return self.__size.y

def main():
    App()


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="boids.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    App()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="boids.Alignment"><code class="flex name class">
<span>class <span class="ident">Alignment</span></span>
<span>(</span><span>target_entities: list[type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'] | type['Vect2D']], attraction_repulsion_force: int = 50000)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a steering behavior object that can be used to steer an entity.
It is an abstract class. It contains a abstract method called behave() that is used to steer an entity (dynamicCircles).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Alignment(SteeringBehavior):
    def __init__(self, target_entities:list[type[&#39;Entity&#39;]|type[&#39;Vect2D&#39;]], attraction_repulsion_force:int=50000):
        super().__init__(target_entities, attraction_repulsion_force)
        
        self.__origin_entity = None
        
        self.__sum_of_forces = Vect2D()
        
    def behave(self, origin_entity: type[&#39;Entity&#39;] = None) -&gt; Vect2D:
        if not self.__origin_entity:
            self.__origin_entity = origin_entity
            for target_entity in self.target_entities:
                if target_entity is not None:
                    if isinstance(target_entity, Entity):
                        self.__sum_of_forces += target_entity.speed
        self.__sum_of_forces /= len(self.target_entities)
        return  self.__sum_of_forces
    
    def draw(self, draw):
        draw.line([self.__origin_entity.position.x, self.__origin_entity.position.y, self.__origin_entity.position.x + self.__sum_of_forces.x, self.__origin_entity.position.y +  self.__sum_of_forces.y], (255, 255, 0))
        draw.ellipse([self.__origin_entity.position.x + self.__sum_of_forces.x -5 , self.__origin_entity.position.y + self.__sum_of_forces.y -5, self.__origin_entity.position.x + self.__sum_of_forces.x + 5 , self.__origin_entity.position.y + self.__sum_of_forces.y + 5], (255, 255, 0))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.Alignment.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'] = None) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity: type[&#39;Entity&#39;] = None) -&gt; Vect2D:
    if not self.__origin_entity:
        self.__origin_entity = origin_entity
        for target_entity in self.target_entities:
            if target_entity is not None:
                if isinstance(target_entity, Entity):
                    self.__sum_of_forces += target_entity.speed
    self.__sum_of_forces /= len(self.target_entities)
    return  self.__sum_of_forces</code></pre>
</details>
</dd>
<dt id="boids.Alignment.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, draw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, draw):
    draw.line([self.__origin_entity.position.x, self.__origin_entity.position.y, self.__origin_entity.position.x + self.__sum_of_forces.x, self.__origin_entity.position.y +  self.__sum_of_forces.y], (255, 255, 0))
    draw.ellipse([self.__origin_entity.position.x + self.__sum_of_forces.x -5 , self.__origin_entity.position.y + self.__sum_of_forces.y -5, self.__origin_entity.position.x + self.__sum_of_forces.x + 5 , self.__origin_entity.position.y + self.__sum_of_forces.y + 5], (255, 255, 0))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.App"><code class="flex name class">
<span>class <span class="ident">App</span></span>
</code></dt>
<dd>
<div class="desc"><p>Toplevel widget of Tk which represents mostly the main window
of an application. It has an associated Tcl interpreter.</p>
<p>Return a new Toplevel widget on screen SCREENNAME. A new Tcl interpreter will
be created. BASENAME will be used for the identification of the profile file (see
readprofile).
It is constructed from sys.argv[0] without extensions if None is given. CLASSNAME
is the name of the widget class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class App(Tk, Updatable):
    def __init__(self):
        Tk.__init__(self)
        self.__size = Vect2D(Tk.winfo_screenwidth(self) * 0.8, Tk.winfo_screenheight(self) * 0.8)
        self.__gui = GUI(size=Vect2D(self.__size.x, self.__size.y), fill_color=RGBAColor(0 ,0, 0)) 
        self.title(&#39;Boids&#39;)
        self.geometry(&#34;{}x{}+{}+{}&#34;.format(int(self.width), (int(self.height)), int(Tk.winfo_screenwidth(self) * 0.5 - self.width * 0.5), 0 + int(Tk.winfo_screenwidth(self) * 0.50 - self.height)))
        self.geometry()
        self.iconbitmap(&#39;boids.ico&#39;)
        self.__simulation = Simulation(size=Vect2D(self.__gui.view_window.width, self.__gui.view_window.height))
        
        self.__gui.main_panel.visual_param_panel.speed_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_draw_speed)
        self.__gui.main_panel.visual_param_panel.steering_force_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_draw_steering_force)
        self.__gui.main_panel.visual_param_panel.show_circle_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_draw_circle)
        self.__gui.main_panel.visual_param_panel.show_fov_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_draw_fov)
        self.__gui.main_panel.visual_param_panel.crazy_mode_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_crazy_mode)
        self.__gui.main_panel.visual_param_panel.jungle_background_checkbutton.bind(&#39;&lt;Button-1&gt;&#39;, self.__gui.view_window.toggle_jungle_background)
        self.__gui.view_window.image_label.bind(&#39;&lt;Enter&gt;&#39;, self.__simulation.mouse_entered)
        self.__gui.view_window.image_label.bind(&#39;&lt;Motion&gt;&#39;, self.__simulation.move_mouse)
        self.__gui.view_window.image_label.bind(&#39;&lt;Leave&gt;&#39;, self.__simulation.mouse_left)
        self.__gui.main_panel.control_panel.start_stop_button.bind(&#39;&lt;Button-1&gt;&#39;, self.toggle_simulation)
        self.__gui.main_panel.control_panel.next_button.bind(&#39;&lt;Button-1&gt;&#39;, self.tick_simulation)
        self.__gui.main_panel.control_panel.next_button.bind(&#39;&lt;space&gt;&#39;, self.tick_simulation)
        self.__gui.main_panel.control_panel.reset_button.bind(&#39;&lt;Button-1&gt;&#39;, self.reset_simulation)
        self.__gui.main_panel.param_panel.combobox.bind(&#39;&lt;&lt;ComboboxSelected&gt;&gt;&#39;, self.param_changed)
        self.__gui.view_window.image_label.bind(&#39;&lt;Button-1&gt;&#39;, self.mouse_clicked_on_image)

        self.tick()
                
        self.mainloop()

    def param_changed(self, event):
        self.reset_simulation()

    @property
    def size(self):
        return self.__size
    
    def mouse_clicked_on_image(self, event):
        clicked_entity = self.__simulation.check_entity_clicked(event)
        if clicked_entity is not None:
            if clicked_entity is self.__gui.main_panel.info_panel.info_entity:
                self.__gui.main_panel.info_panel.info_entity = None
                self.__simulation.selected_entity = None
            else:
                self.__gui.main_panel.info_panel.info_entity = clicked_entity
                self.__simulation.selected_entity = clicked_entity

    def tick_simulation(self, event=None):
        self.__simulation.tick(time=0.1)
        
    def reset_simulation(self, event=None) -&gt; None:
        key = self.__gui.main_panel.param_panel.param_selected
        self.__gui.main_panel.control_panel.start_stop_button.config(text=&#34;Stop&#34;)
        self.__gui.main_panel.control_panel.next_button.config(state=&#34;disabled&#34;)
        self.__simulation.reset(key)
        self.__simulation.selected_entity = None
        self.__gui.main_panel.info_panel.info_entity = None

    def update_info_panel(self):
        self.__gui.main_panel.info_panel.set_text(self.__info_string)

    def tick(self):
        if self.__simulation.is_running:
            self.tick_simulation()
        self.__gui.main_panel.info_panel.update()
        self.__gui.view_window.update_view(self.__simulation)
        self.after(10, self.tick)
        
    def toggle_simulation(self, event):
        self.__simulation.toggle_running(event)
        if self.__simulation.is_running:
            self.__gui.main_panel.control_panel.start_stop_button.config(text=&#34;Stop&#34;)
            self.__gui.main_panel.control_panel.next_button.config(state=&#34;disabled&#34;)
        else:
            self.__gui.main_panel.control_panel.start_stop_button.config(text=&#34;Start&#34;)
            self.__gui.main_panel.control_panel.next_button.config(state=&#34;normal&#34;)
             
    @property
    def width(self):
        return self.__size.x

    @property
    def height(self):
        return self.__size.y</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Tk</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
<li><a title="boids.Updatable" href="#boids.Updatable">Updatable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.App.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self):
    return self.__size.y</code></pre>
</details>
</dd>
<dt id="boids.App.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>Return a tuple of the number of column and rows in the grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self.__size</code></pre>
</details>
</dd>
<dt id="boids.App.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self):
    return self.__size.x</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.App.mouse_clicked_on_image"><code class="name flex">
<span>def <span class="ident">mouse_clicked_on_image</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouse_clicked_on_image(self, event):
    clicked_entity = self.__simulation.check_entity_clicked(event)
    if clicked_entity is not None:
        if clicked_entity is self.__gui.main_panel.info_panel.info_entity:
            self.__gui.main_panel.info_panel.info_entity = None
            self.__simulation.selected_entity = None
        else:
            self.__gui.main_panel.info_panel.info_entity = clicked_entity
            self.__simulation.selected_entity = clicked_entity</code></pre>
</details>
</dd>
<dt id="boids.App.param_changed"><code class="name flex">
<span>def <span class="ident">param_changed</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_changed(self, event):
    self.reset_simulation()</code></pre>
</details>
</dd>
<dt id="boids.App.reset_simulation"><code class="name flex">
<span>def <span class="ident">reset_simulation</span></span>(<span>self, event=None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_simulation(self, event=None) -&gt; None:
    key = self.__gui.main_panel.param_panel.param_selected
    self.__gui.main_panel.control_panel.start_stop_button.config(text=&#34;Stop&#34;)
    self.__gui.main_panel.control_panel.next_button.config(state=&#34;disabled&#34;)
    self.__simulation.reset(key)
    self.__simulation.selected_entity = None
    self.__gui.main_panel.info_panel.info_entity = None</code></pre>
</details>
</dd>
<dt id="boids.App.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tick(self):
    if self.__simulation.is_running:
        self.tick_simulation()
    self.__gui.main_panel.info_panel.update()
    self.__gui.view_window.update_view(self.__simulation)
    self.after(10, self.tick)</code></pre>
</details>
</dd>
<dt id="boids.App.tick_simulation"><code class="name flex">
<span>def <span class="ident">tick_simulation</span></span>(<span>self, event=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tick_simulation(self, event=None):
    self.__simulation.tick(time=0.1)</code></pre>
</details>
</dd>
<dt id="boids.App.toggle_simulation"><code class="name flex">
<span>def <span class="ident">toggle_simulation</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_simulation(self, event):
    self.__simulation.toggle_running(event)
    if self.__simulation.is_running:
        self.__gui.main_panel.control_panel.start_stop_button.config(text=&#34;Stop&#34;)
        self.__gui.main_panel.control_panel.next_button.config(state=&#34;disabled&#34;)
    else:
        self.__gui.main_panel.control_panel.start_stop_button.config(text=&#34;Start&#34;)
        self.__gui.main_panel.control_panel.next_button.config(state=&#34;normal&#34;)</code></pre>
</details>
</dd>
<dt id="boids.App.update_info_panel"><code class="name flex">
<span>def <span class="ident">update_info_panel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_info_panel(self):
    self.__gui.main_panel.info_panel.set_text(self.__info_string)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.BorderRepulsion"><code class="flex name class">
<span>class <span class="ident">BorderRepulsion</span></span>
<span>(</span><span>attraction_repulsion_force=50000, sim_dim: vect2d.Vect2D = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a steering behavior object that can be used to steer an entity.
It is an abstract class. It contains a abstract method called behave() that is used to steer an entity (dynamicCircles).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BorderRepulsion(SteeringBehavior): 

    def __init__(self, attraction_repulsion_force=50000, sim_dim:Vect2D=None):       
        SteeringBehavior.__init__(self, attraction_repulsion_force=attraction_repulsion_force)
        self.__sim_dim = sim_dim

    def behave(self, origin_entity:type[&#39;Entity&#39;]) -&gt; Vect2D:
        force = self.attraction_repulsion_force

        distance_from_left = origin_entity.position.x - origin_entity.width / 2
        distance_from_right = self.__sim_dim.x - origin_entity.position.x - origin_entity.width / 2
        distance_from_top = origin_entity.position.y - origin_entity.height / 2
        distance_from_bottom = self.__sim_dim.y - origin_entity.position.y - origin_entity.height / 2

        repulsive_force_left = round((Vect2D(force, 0))/(distance_from_left) ** 2, 0) if distance_from_left &gt; 0 else Vect2D(force, 0)
        repulsive_force_right = round((Vect2D(-force, 0))/(distance_from_right) ** 2, 0) if distance_from_right &gt; 0 else Vect2D(-force, 0)
        repulsive_force_top = round((Vect2D(0, force))/(distance_from_top) ** 2, 2) if distance_from_top &gt; 0 else Vect2D(0, force)
        repulsive_force_bottom = round((Vect2D(0, -force))/(distance_from_bottom) ** 2, 0) if distance_from_bottom &gt; 0 else Vect2D(0, -force)
        
        return repulsive_force_left + repulsive_force_right + repulsive_force_top + repulsive_force_bottom</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.BorderRepulsion.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity:type[&#39;Entity&#39;]) -&gt; Vect2D:
    force = self.attraction_repulsion_force

    distance_from_left = origin_entity.position.x - origin_entity.width / 2
    distance_from_right = self.__sim_dim.x - origin_entity.position.x - origin_entity.width / 2
    distance_from_top = origin_entity.position.y - origin_entity.height / 2
    distance_from_bottom = self.__sim_dim.y - origin_entity.position.y - origin_entity.height / 2

    repulsive_force_left = round((Vect2D(force, 0))/(distance_from_left) ** 2, 0) if distance_from_left &gt; 0 else Vect2D(force, 0)
    repulsive_force_right = round((Vect2D(-force, 0))/(distance_from_right) ** 2, 0) if distance_from_right &gt; 0 else Vect2D(-force, 0)
    repulsive_force_top = round((Vect2D(0, force))/(distance_from_top) ** 2, 2) if distance_from_top &gt; 0 else Vect2D(0, force)
    repulsive_force_bottom = round((Vect2D(0, -force))/(distance_from_bottom) ** 2, 0) if distance_from_bottom &gt; 0 else Vect2D(0, -force)
    
    return repulsive_force_left + repulsive_force_right + repulsive_force_top + repulsive_force_bottom</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Brain"><code class="flex name class">
<span>class <span class="ident">Brain</span></span>
<span>(</span><span>owner, environment, behavior_patterns=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Brain():
    def __init__(self, owner, environment, behavior_patterns=None):
        self.__owner = owner
        self.__environment = environment
        if behavior_patterns is None:
            self.__behavior_patterns = {    &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; }, 
                                            &#34;SentientCircle&#34;: { &#34;Behavior&#34;: Cohesion, &#34;Target_type&#34; : &#34;grouping&#34; },
                                            &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                            &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                            &#34;No_target&#34;: { &#34;Behavior&#34;: Wander, &#34;Target_type&#34; : &#34;none&#34; }
                                        }
        else: self.__behavior_patterns = behavior_patterns
        self.__permanent_patterns = [BorderRepulsion(sim_dim=environment.size)]


        self.__seen_entities = []
        self.__active_behaviors = self.__permanent_patterns

    def process(self):
        self.__seen_entities = []
        self.__active_behaviors = []
        self.__active_behaviors.extend(self.__permanent_patterns)
        for eye in self.__owner.eyes:
            self.__seen_entities = eye.look(self.__environment)

        if self.__seen_entities:
            for key in self.__behavior_patterns:
                values = self.__behavior_patterns[key]
                if values[&#34;Target_type&#34;] == &#34;single&#34;:
                    for seen_entity in self.__seen_entities:
                        if seen_entity.__class__.__name__ == key:
                            behavior = self.__behavior_patterns[seen_entity.__class__.__name__][&#34;Behavior&#34;]
                            self.__active_behaviors.append(behavior([seen_entity]))
                elif values[&#34;Target_type&#34;] == &#34;grouping&#34;:
                    target_group = []
                    behavior = values[&#34;Behavior&#34;]
                    for seen_entity in self.__seen_entities:
                        if seen_entity.__class__.__name__ == key:
                            target_group.append(seen_entity)
                    if target_group:
                        self.__active_behaviors.append(behavior(target_group))
        else: 
            behavior = self.__behavior_patterns[&#34;No_target&#34;][&#34;Behavior&#34;]
            self.__active_behaviors.append(behavior())
        self.behave()

    def draw_line_to_seen_entities(self, draw) -&gt; None:
        halo_radius = self.__owner.radius * 1.25
        for seen_entity in self.__seen_entities:
            draw.ellipse([self.__owner.position.x - halo_radius, self.__owner.position.y -  halo_radius, self.__owner.position.x +  halo_radius, self.__owner.position.y +  halo_radius], fill=&#34;cyan&#34;)
            draw.line([self.__owner.position.x, self.__owner.position.y, seen_entity.position.x, seen_entity.position.y], fill=&#34;cyan&#34;, width=5)
            
    def behave(self) -&gt; None:
        for behavior in self.__active_behaviors:
                self.__owner.steering_force.set(self.__owner.steering_force.x + behavior.behave(origin_entity=self.__owner).x, self.__owner.steering_force.y + behavior.behave(origin_entity=self.__owner).y)

        self.__owner.steering_force.set_polar(length= Utils.clamp_max(self.__owner.steering_force.length, self.__owner.max_steering_force), orientation=self.__owner.steering_force.orientation)     

    @property
    def active_behaviors(self):
        return self.__active_behaviors
    
    @property
    def seen_entities(self):
        return self.__seen_entities

    @property
    def behavior_patterns(self):
        return self.__behavior_patterns

    @behavior_patterns.setter
    def behavior_patterns(self, value):
        self.__behavior_patterns = value</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="boids.Brain.active_behaviors"><code class="name">var <span class="ident">active_behaviors</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def active_behaviors(self):
    return self.__active_behaviors</code></pre>
</details>
</dd>
<dt id="boids.Brain.behavior_patterns"><code class="name">var <span class="ident">behavior_patterns</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def behavior_patterns(self):
    return self.__behavior_patterns</code></pre>
</details>
</dd>
<dt id="boids.Brain.seen_entities"><code class="name">var <span class="ident">seen_entities</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def seen_entities(self):
    return self.__seen_entities</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.Brain.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self) -&gt; None:
    for behavior in self.__active_behaviors:
            self.__owner.steering_force.set(self.__owner.steering_force.x + behavior.behave(origin_entity=self.__owner).x, self.__owner.steering_force.y + behavior.behave(origin_entity=self.__owner).y)

    self.__owner.steering_force.set_polar(length= Utils.clamp_max(self.__owner.steering_force.length, self.__owner.max_steering_force), orientation=self.__owner.steering_force.orientation)     </code></pre>
</details>
</dd>
<dt id="boids.Brain.draw_line_to_seen_entities"><code class="name flex">
<span>def <span class="ident">draw_line_to_seen_entities</span></span>(<span>self, draw) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_line_to_seen_entities(self, draw) -&gt; None:
    halo_radius = self.__owner.radius * 1.25
    for seen_entity in self.__seen_entities:
        draw.ellipse([self.__owner.position.x - halo_radius, self.__owner.position.y -  halo_radius, self.__owner.position.x +  halo_radius, self.__owner.position.y +  halo_radius], fill=&#34;cyan&#34;)
        draw.line([self.__owner.position.x, self.__owner.position.y, seen_entity.position.x, seen_entity.position.y], fill=&#34;cyan&#34;, width=5)</code></pre>
</details>
</dd>
<dt id="boids.Brain.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    self.__seen_entities = []
    self.__active_behaviors = []
    self.__active_behaviors.extend(self.__permanent_patterns)
    for eye in self.__owner.eyes:
        self.__seen_entities = eye.look(self.__environment)

    if self.__seen_entities:
        for key in self.__behavior_patterns:
            values = self.__behavior_patterns[key]
            if values[&#34;Target_type&#34;] == &#34;single&#34;:
                for seen_entity in self.__seen_entities:
                    if seen_entity.__class__.__name__ == key:
                        behavior = self.__behavior_patterns[seen_entity.__class__.__name__][&#34;Behavior&#34;]
                        self.__active_behaviors.append(behavior([seen_entity]))
            elif values[&#34;Target_type&#34;] == &#34;grouping&#34;:
                target_group = []
                behavior = values[&#34;Behavior&#34;]
                for seen_entity in self.__seen_entities:
                    if seen_entity.__class__.__name__ == key:
                        target_group.append(seen_entity)
                if target_group:
                    self.__active_behaviors.append(behavior(target_group))
    else: 
        behavior = self.__behavior_patterns[&#34;No_target&#34;][&#34;Behavior&#34;]
        self.__active_behaviors.append(behavior())
    self.behave()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Circle"><code class="flex name class">
<span>class <span class="ident">Circle</span></span>
<span>(</span><span>border_color=&lt;boids.RGBAColor object&gt;, border_width=5, fill_color=&lt;boids.RGBAColor object&gt;, position=vect2d.Vect2D(x=751.0, y=177.0), radius: int = 50)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Circle(Entity):
    def __init__(self, border_color = RGBAColor(randomize=True), border_width = 5, fill_color = RGBAColor(0,0,0,255),  position=Vect2D(random.randrange(0,1000),random.randrange(0,500)), radius:int=50):
        Entity.__init__(self, border_color=border_color, border_width=border_width, fill_color=fill_color, position=position, size=Vect2D(radius*2, radius*2))
        self.__radius = radius

    @property
    def radius(self):
        return self.__radius

    @radius.setter
    def radius(self, radius):
        self.__radius = radius

    def draw(self, draw):
        self.fill_color
        draw.ellipse(
                [self.position.x - self.__radius,
                self.position.y - self.__radius,
                self.position.x + self.__radius,
                self.position.y + self.__radius],
                fill=self.fill_color,
                width=self.border_width,
                outline=self.border_color)

    @abstractmethod
    def tick(self, time):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.Entity" href="#boids.Entity">Entity</a></li>
<li><a title="boids.Drawable" href="#boids.Drawable">Drawable</a></li>
<li><a title="boids.Updatable" href="#boids.Updatable">Updatable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.DynamicCircle" href="#boids.DynamicCircle">DynamicCircle</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.Circle.radius"><code class="name">var <span class="ident">radius</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def radius(self):
    return self.__radius</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.Circle.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, draw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, draw):
    self.fill_color
    draw.ellipse(
            [self.position.x - self.__radius,
            self.position.y - self.__radius,
            self.position.x + self.__radius,
            self.position.y + self.__radius],
            fill=self.fill_color,
            width=self.border_width,
            outline=self.border_color)</code></pre>
</details>
</dd>
<dt id="boids.Circle.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def tick(self, time):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Cohesion"><code class="flex name class">
<span>class <span class="ident">Cohesion</span></span>
<span>(</span><span>target_entities: list[type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'] | type['Vect2D']], attraction_repulsion_force: int = 50)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a steering behavior object that can be used to steer an entity.
It is an abstract class. It contains a abstract method called behave() that is used to steer an entity (dynamicCircles).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cohesion(SteeringBehavior):
    def __init__(self, target_entities:list[type[&#39;Entity&#39;]|type[&#39;Vect2D&#39;]], attraction_repulsion_force:int=50):
        super().__init__(target_entities, attraction_repulsion_force)

        self.__center_of_gravity = Vect2D()
        
        self.__origin_entity = None

    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        if not self.__origin_entity:
            self.__origin_entity = origin_entity
        sum_of_positions = Vect2D()
        for target_entity in self.target_entities:
            if target_entity is not None:
                if isinstance(target_entity, Entity):
                    sum_of_positions.set(sum_of_positions.x + target_entity.position.x, sum_of_positions.y + target_entity.position.y)
                else: 
                    sum_of_position += target_entity
        self.__center_of_gravity.set(sum_of_positions.x / len(self.target_entities), sum_of_positions.y / len(self.target_entities)) 
        desired_speed = (self.__center_of_gravity - origin_entity.position).normalized * origin_entity.max_speed
        sum_of_forces = (desired_speed - origin_entity.speed) * self.attraction_repulsion_force
        return sum_of_forces
    
    def draw(self,draw):
        draw.line([self.__origin_entity.position.x, self.__origin_entity.position.y, self.__center_of_gravity.x, self.__center_of_gravity.y], (0, 255, 0))
        draw.ellipse([self.__center_of_gravity.x -5 , self.__center_of_gravity.y -5, self.__center_of_gravity.x + 5 , self.__center_of_gravity.y + 5], (0, 255, 0))    </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.Cohesion.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
    if not self.__origin_entity:
        self.__origin_entity = origin_entity
    sum_of_positions = Vect2D()
    for target_entity in self.target_entities:
        if target_entity is not None:
            if isinstance(target_entity, Entity):
                sum_of_positions.set(sum_of_positions.x + target_entity.position.x, sum_of_positions.y + target_entity.position.y)
            else: 
                sum_of_position += target_entity
    self.__center_of_gravity.set(sum_of_positions.x / len(self.target_entities), sum_of_positions.y / len(self.target_entities)) 
    desired_speed = (self.__center_of_gravity - origin_entity.position).normalized * origin_entity.max_speed
    sum_of_forces = (desired_speed - origin_entity.speed) * self.attraction_repulsion_force
    return sum_of_forces</code></pre>
</details>
</dd>
<dt id="boids.Cohesion.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, draw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self,draw):
    draw.line([self.__origin_entity.position.x, self.__origin_entity.position.y, self.__center_of_gravity.x, self.__center_of_gravity.y], (0, 255, 0))
    draw.ellipse([self.__center_of_gravity.x -5 , self.__center_of_gravity.y -5, self.__center_of_gravity.x + 5 , self.__center_of_gravity.y + 5], (0, 255, 0))    </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.ControlBar"><code class="flex name class">
<span>class <span class="ident">ControlBar</span></span>
</code></dt>
<dd>
<div class="desc"><p>Ttk Frame widget is a container, used to group other widgets
together.</p>
<p>Construct a Ttk Frame with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS</p>
<pre><code>borderwidth, relief, padding, width, height
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ControlBar(ttk.Frame):
    def __init__(self):
        ttk.Frame.__init__(self)
        self.__control_panel = StartStopPanel(&#34;Controls&#34;)
        self.__param_panel = ParamPanel(&#34;Scenarios&#34;)
        self.__visual_param_panel = VisualParamPanel(&#34;Visual Parameters&#34;)
        self.__Info_panel = InfoPanel(&#34;Selected Entity Informations&#34;)
        self.__control_panel.grid(row=0, column=0, sticky=&#34;N&#34;)
        self.__param_panel.grid(row=1, column=0, sticky=&#34;N&#34;)
        self.__visual_param_panel.grid(row=2, column=0, sticky=&#34;N&#34;)
        self.__Info_panel.grid(row=3, column=0, sticky=&#34;N&#34;)

    @property
    def param_panel(self):
        return self.__param_panel
    
    @property
    def control_panel(self):
        return self.__control_panel
    
    @property
    def visual_param_panel(self):
        return self.__visual_param_panel
    
    @property
    def info_panel(self):
        return self.__Info_panel</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Frame</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.ControlBar.control_panel"><code class="name">var <span class="ident">control_panel</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def control_panel(self):
    return self.__control_panel</code></pre>
</details>
</dd>
<dt id="boids.ControlBar.info_panel"><code class="name">var <span class="ident">info_panel</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def info_panel(self):
    return self.__Info_panel</code></pre>
</details>
</dd>
<dt id="boids.ControlBar.param_panel"><code class="name">var <span class="ident">param_panel</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_panel(self):
    return self.__param_panel</code></pre>
</details>
</dd>
<dt id="boids.ControlBar.visual_param_panel"><code class="name">var <span class="ident">visual_param_panel</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def visual_param_panel(self):
    return self.__visual_param_panel</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Drawable"><code class="flex name class">
<span>class <span class="ident">Drawable</span></span>
<span>(</span><span>border_color, border_width, fill_color, position: vect2d.Vect2D, size: vect2d.Vect2D)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Drawable():
    def __init__(self, border_color, border_width, fill_color, position:Vect2D, size:Vect2D):
        self.__border_color = border_color
        self.__border_width = border_width
        self.__fill_color = fill_color
        self.__position = position
        self.__size = size

    @abstractmethod
    def draw(self):
        pass

    @property
    def size(self):
        return self.__size

    @property
    def width(self):
        return self.__size.x

    @property
    def height(self):
        return self.__size.y
    
    @property
    def fill_color(self):
        return self.__fill_color.rgba

    @property
    def border_color(self):
        return self.__border_color.rgba

    @property
    def border_width(self):
        return self.__border_width
    
    @property
    def position(self):
        return self.__position

    @property
    def pos_x(self):
        return self.__position.x

    @property
    def pos_y(self):
        return self.__position.y

    @pos_x.setter
    def pos_x(self, pos_x):
        self.__position.x = pos_x

    @pos_y.setter
    def pos_y(self, pos_y):
        self.__position.y = pos_y

    @position.setter
    def position(self, position):
        self.__position = position

    @fill_color.setter
    def fill_color(self, fill_color):
        self.__fill_color = fill_color</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.Entity" href="#boids.Entity">Entity</a></li>
<li><a title="boids.Eye" href="#boids.Eye">Eye</a></li>
<li><a title="boids.GUI" href="#boids.GUI">GUI</a></li>
<li><a title="boids.ViewWindow" href="#boids.ViewWindow">ViewWindow</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.Drawable.border_color"><code class="name">var <span class="ident">border_color</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def border_color(self):
    return self.__border_color.rgba</code></pre>
</details>
</dd>
<dt id="boids.Drawable.border_width"><code class="name">var <span class="ident">border_width</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def border_width(self):
    return self.__border_width</code></pre>
</details>
</dd>
<dt id="boids.Drawable.fill_color"><code class="name">var <span class="ident">fill_color</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fill_color(self):
    return self.__fill_color.rgba</code></pre>
</details>
</dd>
<dt id="boids.Drawable.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self):
    return self.__size.y</code></pre>
</details>
</dd>
<dt id="boids.Drawable.pos_x"><code class="name">var <span class="ident">pos_x</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pos_x(self):
    return self.__position.x</code></pre>
</details>
</dd>
<dt id="boids.Drawable.pos_y"><code class="name">var <span class="ident">pos_y</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pos_y(self):
    return self.__position.y</code></pre>
</details>
</dd>
<dt id="boids.Drawable.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def position(self):
    return self.__position</code></pre>
</details>
</dd>
<dt id="boids.Drawable.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self.__size</code></pre>
</details>
</dd>
<dt id="boids.Drawable.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self):
    return self.__size.x</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.Drawable.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def draw(self):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.DynamicCircle"><code class="flex name class">
<span>class <span class="ident">DynamicCircle</span></span>
<span>(</span><span>border_color=&lt;boids.RGBAColor object&gt;, border_width=5, fill_color=&lt;boids.RGBAColor object&gt;, position=vect2d.Vect2D(x=319.0, y=454.0), radius=23, acceleration=vect2d.Vect2D(x=0.0, y=0.0), speed=vect2d.Vect2D(x=-33.0, y=-15.0), max_speed=100, max_steering_force=50, steering_force=vect2d.Vect2D(x=0.0, y=0.0), steering_behaviors=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynamicCircle(Circle, Movable, Piloted):
    def __init__(   self,
                    border_color=RGBAColor(randomize=True),
                    border_width=5,
                    fill_color=RGBAColor(randomize=True),
                    position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                    radius=random.randint(10, 50),
                    acceleration=Vect2D(0,0),
                    speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                    max_speed= 100,
                    max_steering_force=50,
                    steering_force=Vect2D(0,0),
                    steering_behaviors=None,
                ):
    
        Circle.__init__(self, border_color, border_width, fill_color, position, radius)
        Movable.__init__(self, acceleration, max_speed, speed)
        Piloted.__init__(self, max_steering_force, steering_force, steering_behaviors)
        
    def draw(self, draw):
        Circle.draw(self, draw)

    def draw_circle_speed(self, draw):
        draw.line([self.position.x, self.position.y, self.position.x + self.speed.x, self.position.y + self.speed.y], fill=&#34;red&#34;, width=5)
        
    def draw_circle_steering_force(self, draw):
        draw.line([self.position.x, self.position.y, self.position.x + self.steering_force.x * 10, self.position.y + self.steering_force.y * 10], fill=&#34;darkgoldenrod&#34;, width=5)
        for steering_behavior in self.steering_behaviors:
            if hasattr(steering_behavior, &#34;draw&#34;):
                    steering_behavior.draw(draw)
            
    def move(self, time):
        Movable.move(self, time)

    def tick(self, time):
        self.steer()
        self.move(time)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.Circle" href="#boids.Circle">Circle</a></li>
<li><a title="boids.Entity" href="#boids.Entity">Entity</a></li>
<li><a title="boids.Drawable" href="#boids.Drawable">Drawable</a></li>
<li><a title="boids.Updatable" href="#boids.Updatable">Updatable</a></li>
<li><a title="boids.Movable" href="#boids.Movable">Movable</a></li>
<li><a title="boids.Piloted" href="#boids.Piloted">Piloted</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.SentientCircle" href="#boids.SentientCircle">SentientCircle</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.DynamicCircle.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, draw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, draw):
    Circle.draw(self, draw)</code></pre>
</details>
</dd>
<dt id="boids.DynamicCircle.draw_circle_speed"><code class="name flex">
<span>def <span class="ident">draw_circle_speed</span></span>(<span>self, draw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_circle_speed(self, draw):
    draw.line([self.position.x, self.position.y, self.position.x + self.speed.x, self.position.y + self.speed.y], fill=&#34;red&#34;, width=5)</code></pre>
</details>
</dd>
<dt id="boids.DynamicCircle.draw_circle_steering_force"><code class="name flex">
<span>def <span class="ident">draw_circle_steering_force</span></span>(<span>self, draw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_circle_steering_force(self, draw):
    draw.line([self.position.x, self.position.y, self.position.x + self.steering_force.x * 10, self.position.y + self.steering_force.y * 10], fill=&#34;darkgoldenrod&#34;, width=5)
    for steering_behavior in self.steering_behaviors:
        if hasattr(steering_behavior, &#34;draw&#34;):
                steering_behavior.draw(draw)</code></pre>
</details>
</dd>
<dt id="boids.DynamicCircle.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, time):
    Movable.move(self, time)</code></pre>
</details>
</dd>
<dt id="boids.DynamicCircle.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tick(self, time):
    self.steer()
    self.move(time)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Entity"><code class="flex name class">
<span>class <span class="ident">Entity</span></span>
<span>(</span><span>border_color, border_width, fill_color, position, size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Entity(Drawable, Updatable):
    def __init__(self, border_color, border_width, fill_color, position, size):
        Drawable.__init__(self, border_color, border_width, fill_color, position, size)
        Updatable.__init__(self)
        
        self.__available_names = [&#34;William&#34;, &#34;Logan&#34;, &#34;Liam&#34;, &#34;Noah&#34;, &#34;Jacob&#34;, &#34;Thomas&#34;, 
                                &#34;Raphael&#34;, &#34;Nathan&#34;, &#34;Leo&#34;, &#34;Alexis&#34;, &#34;Emile&#34;, &#34;Edouard&#34;,
                                &#34;Felix&#34;, &#34;Samuel&#34;, &#34;Olivier&#34;, &#34;Gabriel&#34;, &#34;Charles&#34;, &#34;Antoine&#34;,
                                &#34;Adam&#34;, &#34;Victor&#34;, &#34;Benjamin&#34;, &#34;Elliot&#34;, &#34;Jayden&#34;, &#34;Arthur&#34;,
                                &#34;James&#34;, &#34;Louis&#34;, &#34;Theo&#34;, &#34;Xavier&#34;, &#34;Zack&#34;, &#34;Arnaud&#34;,
                                &#34;Lucas&#34;, &#34;Ethan&#34;, &#34;Nolan&#34;, &#34;Henri&#34;, &#34;Loic&#34;, &#34;Milan&#34;, &#34;Mathis&#34;,
                                &#34;Zachary&#34;, &#34;Dylan&#34;, &#34;Alexandre&#34;, &#34;Tristan&#34;, &#34;Laurent&#34;, &#34;Eli&#34;,
                                &#34;Mayson&#34;, &#34;Justin&#34;, &#34;Anthony&#34;, &#34;Ryan&#34;, &#34;Isaac&#34;, &#34;Jules&#34;, &#34;Jackson&#34;,
                                &#34;Eliott&#34;, &#34;Evan&#34;, &#34;Leonard&#34;, &#34;Philippe&#34;, &#34;Caleb&#34;, &#34;Nicolas&#34;,
                                &#34;Damien&#34;, &#34;Jake&#34;, &#34;Theodore&#34;, &#34;Eliot&#34;, &#34;Eloi&#34;, &#34;Ludovic&#34;,
                                &#34;Malik&#34;, &#34;Matheo&#34;, &#34;Louka&#34;, &#34;Alex&#34;, &#34;Hayden&#34;, &#34;Zackary&#34;,
                                &#34;Hugo&#34;, &#34;Rafael&#34;, &#34;Matteo&#34;, &#34;David&#34;, &#34;Hubert&#34;, &#34;Derek&#34;,
                                &#34;Etienne&#34;, &#34;Vincent&#34;, &#34;Rayan&#34;, &#34;Axel&#34;, &#34;Leon&#34;, &#34;Tyler&#34;,
                                &#34;Mathias&#34;, &#34;Albert&#34;, &#34;Maxime&#34;, &#34;Enzo&#34;, &#34;Jordan&#34;, &#34;Julien&#34;,
                                &#34;Simon&#34;, &#34;Loik&#34;, &#34;Michael&#34;, &#34;Ayden&#34;, &#34;Daniel&#34;, &#34;Tom&#34;, &#34;Jack&#34;,
                                &#34;Joshua&#34;, &#34;Maverick&#34;, &#34;Adrien&#34;, &#34;Lyam&#34;, &#34;Mateo&#34;, &#34;Remi&#34;, &#34;Elias&#34;,
                                &#34;Gertrude&#34;, &#34;Denis&#34;, &#34;Donald&#34;, &#34;Jonathan&#34;, &#34;Andrzej&#34;, &#34;Marius&#34;,
                                &#34;Marek&#34;, &#34;Marcin&#34;, &#34;Maciej&#34;, &#34;Piotr&#34;, &#34;Pawel&#34;, &#34;Piotrek&#34;, &#34;Pawel&#34;,
                                &#34;Julie&#34;, &#34;Juliette&#34;, &#34;Juliet&#34;, &#34;Julia&#34;, &#34;Juliana&#34;, &#34;June&#34;, &#34;Valerie&#34;,
                                &#34;Valeria&#34;, &#34;Zoe&#34;, &#34;Chanel&#34;, &#34;Chloe&#34;, &#34;Charlotte&#34;, &#34;Celine&#34;, &#34;Cecile&#34;,
                                &#34;Martha&#34;, &#34;Marie&#34;, &#34;Marion&#34;, &#34;Marina&#34;, &#34;Marine&#34;, &#34;Maria&#34;, &#34;Marianne&#34;,
                                &#34;Diana&#34;, &#34;Diane&#34;, &#34;Gertrude&#34;, &#34;Geraldine&#34;, &#34;Alexandra&#34;, &#34;Alexandria&#34;,
                                &#34;Alexandrine&#34;, &#34;Alexia&#34;, &#34;Huguette&#34;, &#34;Marguerite&#34;, &#34;Margot&#34;, &#34;Molly&#34;]
        
        #get a random name from the list
        self.__name = random.choice(self.__available_names)

    @abstractmethod
    def draw(self):
        pass

    @abstractmethod
    def tick(self):
        pass
    
    @property
    def name(self):
        return self.__name</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.Drawable" href="#boids.Drawable">Drawable</a></li>
<li><a title="boids.Updatable" href="#boids.Updatable">Updatable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.Circle" href="#boids.Circle">Circle</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.Entity.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    return self.__name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.Entity.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def draw(self):
    pass</code></pre>
</details>
</dd>
<dt id="boids.Entity.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def tick(self):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.EntityRepulsion"><code class="flex name class">
<span>class <span class="ident">EntityRepulsion</span></span>
<span>(</span><span>target_entities: list[type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'] | type['Vect2D']], attraction_repulsion_force: int = 2000000000)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a steering behavior object that can be used to steer an entity.
It is an abstract class. It contains a abstract method called behave() that is used to steer an entity (dynamicCircles).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EntityRepulsion(SteeringBehavior):
    def __init__(self, target_entities:list[type[&#39;Entity&#39;]|type[&#39;Vect2D&#39;]], attraction_repulsion_force:int=2000000000):
        SteeringBehavior.__init__(self, attraction_repulsion_force=attraction_repulsion_force)
    
        self.__target_entities = target_entities

    def behave(self, origin_entity:type[&#39;Entity&#39;]) -&gt; Vect2D:
        force = self.attraction_repulsion_force
        for target_entity in self.__target_entities:
            if target_entity is not origin_entity:
                if isinstance(target_entity, Entity):
                    orientation = (origin_entity.position - target_entity.position).normalized
                    distance = (origin_entity.position - target_entity.position).length - origin_entity.radius - target_entity.radius
                elif isinstance(target_entity, Vect2D):
                    orientation = (origin_entity.position - target_entity).normalized
                    distance = (origin_entity.position - target_entity).length - origin_entity.radius
                
                self.resulting_direction += orientation/distance ** 2 * force
                
        return self.resulting_direction</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.EntityRepulsion.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity:type[&#39;Entity&#39;]) -&gt; Vect2D:
    force = self.attraction_repulsion_force
    for target_entity in self.__target_entities:
        if target_entity is not origin_entity:
            if isinstance(target_entity, Entity):
                orientation = (origin_entity.position - target_entity.position).normalized
                distance = (origin_entity.position - target_entity.position).length - origin_entity.radius - target_entity.radius
            elif isinstance(target_entity, Vect2D):
                orientation = (origin_entity.position - target_entity).normalized
                distance = (origin_entity.position - target_entity).length - origin_entity.radius
            
            self.resulting_direction += orientation/distance ** 2 * force
            
    return self.resulting_direction</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Evade"><code class="flex name class">
<span>class <span class="ident">Evade</span></span>
<span>(</span><span>target_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'] = None, ratio: int = 1, attraction_repulsion_force: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a steering behavior object that can be used to steer an entity.
It is an abstract class. It contains a abstract method called behave() that is used to steer an entity (dynamicCircles).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Evade(Pursuit):
    def __init__(self, target_entity:type[&#39;Entity&#39;]=None, ratio:int = 1, attraction_repulsion_force:int=1):
        super().__init__(target_entity, ratio, attraction_repulsion_force)
        
    def behave(self, origin_entity: type[&#39;Entity&#39;])-&gt; Vect2D:
        return super().behave(origin_entity) * - 1   </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.Pursuit" href="#boids.Pursuit">Pursuit</a></li>
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.Evade.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity: type[&#39;Entity&#39;])-&gt; Vect2D:
    return super().behave(origin_entity) * - 1   </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Eye"><code class="flex name class">
<span>class <span class="ident">Eye</span></span>
<span>(</span><span>owner: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'], fov: float = 45, range: float = 150, vector: vect2d.Vect2D = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Eye(Drawable):
    def __init__(self, owner:type[&#39;Entity&#39;], fov:float=45, range:float=150, vector:Vect2D=None):
        self.__owner = owner
        Drawable.__init__(self, border_color=RGBAColor(), border_width=1, fill_color=None, position=self.__owner.position, size=Vect2D(range, range))
        self.__fov = fov
        self.__range = range
        if vector is None:
            self.__vector = owner.speed

    def look(self, simulation):
        seen_sprites = []
        for sprite in simulation.sprites:
            if sprite is not self.__owner and self.sees(sprite):
                seen_sprites.append(sprite)
        return seen_sprites

    def is_in_range(self, target:Vect2D)-&gt;bool:
        return self.__owner.position.distance_from(target.position) - target.radius &lt;= self.__range

    def is_in_fov(self, target:Vect2D)-&gt;bool:
        distance_to_target = target.position - self.__owner.position
        if distance_to_target.is_defined:
            return self.__vector.angle_between_degrees(distance_to_target) &lt;= self.__fov
        else:
            return True
        
    def sees(self, target:type[&#39;Entity&#39;])-&gt;bool:
        return self.is_in_range(target) and self.is_in_fov(target)

    def draw(self, draw):
        draw.pieslice(
                [self.__owner.position.x - self.__range,
                self.__owner.position.y - self.__range,
                self.__owner.position.x + self.__range,
                self.__owner.position.y + self.__range],
                start=self.__vector.orientation_degrees - self.__fov,
                end=self.__vector.orientation_degrees + self.__fov,
                width=self.border_width,
                outline=self.border_color)

    @property
    def fov(self):
        return self.__fov

    @property
    def range(self):
        return self.__range

    @property
    def position(self):
        return self.__position

    @property
    def orientation(self):
        return self.__orientation

    @fov.setter
    def fov(self, fov):
        self.__fov = fov

    @range.setter
    def range(self, range):
        self.__range = range

    @position.setter
    def position(self, position):
        self.__position = position

    @orientation.setter
    def orientation(self, orientation):
            self.__orientation = orientation</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.Drawable" href="#boids.Drawable">Drawable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.Eye.fov"><code class="name">var <span class="ident">fov</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fov(self):
    return self.__fov</code></pre>
</details>
</dd>
<dt id="boids.Eye.orientation"><code class="name">var <span class="ident">orientation</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def orientation(self):
    return self.__orientation</code></pre>
</details>
</dd>
<dt id="boids.Eye.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def position(self):
    return self.__position</code></pre>
</details>
</dd>
<dt id="boids.Eye.range"><code class="name">var <span class="ident">range</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def range(self):
    return self.__range</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.Eye.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, draw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, draw):
    draw.pieslice(
            [self.__owner.position.x - self.__range,
            self.__owner.position.y - self.__range,
            self.__owner.position.x + self.__range,
            self.__owner.position.y + self.__range],
            start=self.__vector.orientation_degrees - self.__fov,
            end=self.__vector.orientation_degrees + self.__fov,
            width=self.border_width,
            outline=self.border_color)</code></pre>
</details>
</dd>
<dt id="boids.Eye.is_in_fov"><code class="name flex">
<span>def <span class="ident">is_in_fov</span></span>(<span>self, target: vect2d.Vect2D) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_in_fov(self, target:Vect2D)-&gt;bool:
    distance_to_target = target.position - self.__owner.position
    if distance_to_target.is_defined:
        return self.__vector.angle_between_degrees(distance_to_target) &lt;= self.__fov
    else:
        return True</code></pre>
</details>
</dd>
<dt id="boids.Eye.is_in_range"><code class="name flex">
<span>def <span class="ident">is_in_range</span></span>(<span>self, target: vect2d.Vect2D) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_in_range(self, target:Vect2D)-&gt;bool:
    return self.__owner.position.distance_from(target.position) - target.radius &lt;= self.__range</code></pre>
</details>
</dd>
<dt id="boids.Eye.look"><code class="name flex">
<span>def <span class="ident">look</span></span>(<span>self, simulation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def look(self, simulation):
    seen_sprites = []
    for sprite in simulation.sprites:
        if sprite is not self.__owner and self.sees(sprite):
            seen_sprites.append(sprite)
    return seen_sprites</code></pre>
</details>
</dd>
<dt id="boids.Eye.sees"><code class="name flex">
<span>def <span class="ident">sees</span></span>(<span>self, target: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sees(self, target:type[&#39;Entity&#39;])-&gt;bool:
    return self.is_in_range(target) and self.is_in_fov(target)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Flee"><code class="flex name class">
<span>class <span class="ident">Flee</span></span>
<span>(</span><span>target_entities: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'] = None, attraction_repulsion_force: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a seek steering behavior object.
It is a child class of the SteeringBehavior class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Flee(Seek):
    def __init__(self, target_entities:type[&#39;Entity&#39;]=None, attraction_repulsion_force:int=1):
        super().__init__(target_entities, attraction_repulsion_force)
        
    def behave(self, origin_entity: type[&#39;Entity&#39;])-&gt; Vect2D:
        return super().behave(origin_entity) * -1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.Seek" href="#boids.Seek">Seek</a></li>
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.Flee.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity: type[&#39;Entity&#39;])-&gt; Vect2D:
    return super().behave(origin_entity) * -1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.FollowBiggestBoidSeen"><code class="flex name class">
<span>class <span class="ident">FollowBiggestBoidSeen</span></span>
<span>(</span><span>target_entities: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'] = None, attraction_repulsion_force: int = 1, minimum_boids_radius: float = 5.0)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a follow biggest boid steering behavior object.
It is a child class of the SteeringBehavior class.
It will follow the biggest boid in the field of view or will not apply any force if the biggest boid is too small.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FollowBiggestBoidSeen(SteeringBehavior):
    &#34;&#34;&#34;
    This class is used to create a follow biggest boid steering behavior object.
    It is a child class of the SteeringBehavior class.
    It will follow the biggest boid in the field of view or will not apply any force if the biggest boid is too small.
    &#34;&#34;&#34;
    def __init__(self, target_entities:type[&#39;Entity&#39;]=None, attraction_repulsion_force:int=1, minimum_boids_radius:float=5.0): 
        SteeringBehavior.__init__(self, target_entities, attraction_repulsion_force)
        self.minimum_boids_radius = minimum_boids_radius

    &#34;&#34;&#34;
    This function is used to calculate the force to apply to the boid.
    It is a child function of the SteeringBehavior class.
    &#34;&#34;&#34;
    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        sum_of_forces = Vect2D(0, 0)
        biggest_boid = None
        for target_entity in self.target_entities:
            if target_entity is not None:
                if biggest_boid is None:
                    biggest_boid = target_entity
                elif biggest_boid.radius &lt; target_entity.radius:
                    biggest_boid = target_entity
        if biggest_boid is not None:
            if biggest_boid.radius &gt; self.minimum_boids_radius:
                target_position = biggest_boid.position - biggest_boid.speed.normalized * 1.5 * biggest_boid.radius
                distance = (target_position - origin_entity.position).length
                new_maximum_speed = biggest_boid.original_max_speed * (1 + min(100, distance) / 100.0 * 0.25)
                origin_entity.max_speed = new_maximum_speed
                desired_speed = (target_position - origin_entity.position).normalized * origin_entity.max_speed
                sum_of_forces += desired_speed - origin_entity.speed * self.attraction_repulsion_force
            else:
                origin_entity.max_speed = origin_entity.original_max_speed
        return sum_of_forces</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.FollowBiggestBoidSeen.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
    sum_of_forces = Vect2D(0, 0)
    biggest_boid = None
    for target_entity in self.target_entities:
        if target_entity is not None:
            if biggest_boid is None:
                biggest_boid = target_entity
            elif biggest_boid.radius &lt; target_entity.radius:
                biggest_boid = target_entity
    if biggest_boid is not None:
        if biggest_boid.radius &gt; self.minimum_boids_radius:
            target_position = biggest_boid.position - biggest_boid.speed.normalized * 1.5 * biggest_boid.radius
            distance = (target_position - origin_entity.position).length
            new_maximum_speed = biggest_boid.original_max_speed * (1 + min(100, distance) / 100.0 * 0.25)
            origin_entity.max_speed = new_maximum_speed
            desired_speed = (target_position - origin_entity.position).normalized * origin_entity.max_speed
            sum_of_forces += desired_speed - origin_entity.speed * self.attraction_repulsion_force
        else:
            origin_entity.max_speed = origin_entity.original_max_speed
    return sum_of_forces</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.GUI"><code class="flex name class">
<span>class <span class="ident">GUI</span></span>
<span>(</span><span>border_color=None, border_width=None, fill_color=None, position=None, size: vect2d.Vect2D = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Ttk Frame widget is a container, used to group other widgets
together.</p>
<p>Construct a Ttk Frame with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS</p>
<pre><code>borderwidth, relief, padding, width, height
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GUI(ttk.Frame, Drawable):
    def __init__(self, border_color=None, border_width=None, fill_color=None, position=None, size:Vect2D=None):
        ttk.Frame.__init__(self, root=None, text=None)
        Drawable.__init__(self, border_color,  border_width, fill_color, position, size)
        self.__main_panel = ControlBar()
        self.__view_window = ViewWindow(size=Vect2D(size.x, size.y), fill_color=fill_color)
        self.__main_panel.grid(row=0, column=1)
        self.__view_window.grid(row=0, column=1, rowspan=4, sticky=&#34;ns&#34;)

    @property
    def main_panel(self):
        return self.__main_panel

    @property
    def view_window(self):
        return self.__view_window</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Frame</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
<li><a title="boids.Drawable" href="#boids.Drawable">Drawable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.GUI.main_panel"><code class="name">var <span class="ident">main_panel</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def main_panel(self):
    return self.__main_panel</code></pre>
</details>
</dd>
<dt id="boids.GUI.view_window"><code class="name">var <span class="ident">view_window</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def view_window(self):
    return self.__view_window</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.InfoPanel"><code class="flex name class">
<span>class <span class="ident">InfoPanel</span></span>
<span>(</span><span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Ttk Labelframe widget is a container used to group other widgets
together. It has an optional label, which may be a plain text string
or another widget.</p>
<p>Construct a Ttk Labelframe with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS
labelanchor, text, underline, padding, labelwidget, width,
height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InfoPanel(ttk.LabelFrame):
    def __init__(self, text):
        ttk.LabelFrame.__init__(self, root=None, text=text)
        self.__info_label = tk.Text(self, width=30, height=20)
        self.__set_text(&#34;Click on a boid to show the infomations about it&#34;)
        self.__info_label.grid(row=0, column=0)
        
        self.__info_entity = None
        self.__info_string = &#34;&#34;

    @property
    def info_label(self):
        return self.__info_label
    
    def __set_text(self, text):
        self.__info_label.config(state=tk.NORMAL)
        self.__info_label.delete(1.0, tk.END)
        self.__info_label.insert(tk.END, text)
        self.__info_label.config(state=tk.DISABLED)
        
    @property
    def info_entity(self):
        return self.__info_entity
    
    @property
    def info_string(self):
        return self.__info_string

    def update(self):
        if self.__info_entity is not None:
            self.__info_string = &#34;Name: &#34; + self.__info_entity.name + &#34;\n&#34;
            self.__info_string += &#34;Position: ({}, {})&#34;.format(math.trunc(self.__info_entity.position.x), math.trunc(self.__info_entity.position.y)) + &#34;\n&#34;
            self.__info_string += &#34;Speed: ({}, {})&#34;.format(math.trunc(self.__info_entity.speed.x), math.trunc(self.__info_entity.speed.y)) + &#34;\n&#34;
            self.__info_string += &#34;Steering force: ({}, {})&#34;.format(math.trunc(self.__info_entity.steering_force.x), math.trunc(self.__info_entity.steering_force.y)) + &#34;\n&#34;
            if isinstance(self.__info_entity, Circle):
                self.__info_string += &#34;Radius: {}&#34;.format(self.__info_entity.radius) + &#34;\n&#34;
            self.__info_string += &#34;Steering forces: &#34; + &#34;\n&#34;
            if self.__info_entity.steering_behaviors is not None:
                for steering_behavior in self.__info_entity.steering_behaviors:
                    self.__info_string += &#34;    &#34; + steering_behavior.__class__.__name__ + &#34;\n&#34;
                    if steering_behavior.target_entities is not None:
                        for target_entity in steering_behavior.target_entities:
                            if isinstance(target_entity, Entity):
                                self.__info_string += &#34;        &#34; + target_entity.name + &#34;\n&#34;
            elif hasattr(self.__info_entity, &#39;brain&#39;) and self.__info_entity.brain is not None and self.__info_entity.brain.active_behaviors is not None and hasattr(self.__info_entity.brain, &#39;active_behaviors&#39;):
                for steering_behavior in self.__info_entity.brain.active_behaviors:
                    self.__info_string += &#34;    &#34; + steering_behavior.__class__.__name__ + &#34;\n&#34;
                    if steering_behavior.target_entities is not None:
                        for target_entity in steering_behavior.target_entities:
                            if isinstance(target_entity, Entity):
                                self.__info_string += &#34;        &#34; + target_entity.name + &#34;\n&#34;
                
            else:
                self.__info_string += &#34;    None\n&#34;
            
            if hasattr(self.__info_entity, &#39;eyes&#39;) and hasattr(self.__info_entity, &#39;brain&#39;) and self.__info_entity.eyes is not None:
                self.__info_string += &#34;Eyes: &#34; + &#34;\n&#34;
                for eye in self.__info_entity.eyes:
                    self.__info_string += &#34;    &#34; + str(self.__info_entity.eyes.index(eye)) +&#34; (FOV: &#34; + str(math.trunc(eye.fov)) + &#34;, Range: &#34; + str(eye.range) + &#34;): &#34; + &#34;\n&#34;
                    for seen_entity in self.__info_entity.brain.seen_entities:
                        self.__info_string += &#34;        &#34; + seen_entity.name + &#34;:&#34; + seen_entity.__class__.__name__ + &#34;\n&#34;

            self.__info_string += &#34;\nClick again to hide info.&#34;
            
            self.__set_text(self.__info_string)
        else:
            self.__set_text(&#34;Click on an entity to show it&#39;s informations&#34;)
    
    @info_entity.setter
    def info_entity(self, entity):
        self.__info_entity = entity
        self.update()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Labelframe</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.InfoPanel.info_entity"><code class="name">var <span class="ident">info_entity</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def info_entity(self):
    return self.__info_entity</code></pre>
</details>
</dd>
<dt id="boids.InfoPanel.info_label"><code class="name">var <span class="ident">info_label</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def info_label(self):
    return self.__info_label</code></pre>
</details>
</dd>
<dt id="boids.InfoPanel.info_string"><code class="name">var <span class="ident">info_string</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def info_string(self):
    return self.__info_string</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.InfoPanel.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enter event loop until all pending events have been processed by Tcl.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    if self.__info_entity is not None:
        self.__info_string = &#34;Name: &#34; + self.__info_entity.name + &#34;\n&#34;
        self.__info_string += &#34;Position: ({}, {})&#34;.format(math.trunc(self.__info_entity.position.x), math.trunc(self.__info_entity.position.y)) + &#34;\n&#34;
        self.__info_string += &#34;Speed: ({}, {})&#34;.format(math.trunc(self.__info_entity.speed.x), math.trunc(self.__info_entity.speed.y)) + &#34;\n&#34;
        self.__info_string += &#34;Steering force: ({}, {})&#34;.format(math.trunc(self.__info_entity.steering_force.x), math.trunc(self.__info_entity.steering_force.y)) + &#34;\n&#34;
        if isinstance(self.__info_entity, Circle):
            self.__info_string += &#34;Radius: {}&#34;.format(self.__info_entity.radius) + &#34;\n&#34;
        self.__info_string += &#34;Steering forces: &#34; + &#34;\n&#34;
        if self.__info_entity.steering_behaviors is not None:
            for steering_behavior in self.__info_entity.steering_behaviors:
                self.__info_string += &#34;    &#34; + steering_behavior.__class__.__name__ + &#34;\n&#34;
                if steering_behavior.target_entities is not None:
                    for target_entity in steering_behavior.target_entities:
                        if isinstance(target_entity, Entity):
                            self.__info_string += &#34;        &#34; + target_entity.name + &#34;\n&#34;
        elif hasattr(self.__info_entity, &#39;brain&#39;) and self.__info_entity.brain is not None and self.__info_entity.brain.active_behaviors is not None and hasattr(self.__info_entity.brain, &#39;active_behaviors&#39;):
            for steering_behavior in self.__info_entity.brain.active_behaviors:
                self.__info_string += &#34;    &#34; + steering_behavior.__class__.__name__ + &#34;\n&#34;
                if steering_behavior.target_entities is not None:
                    for target_entity in steering_behavior.target_entities:
                        if isinstance(target_entity, Entity):
                            self.__info_string += &#34;        &#34; + target_entity.name + &#34;\n&#34;
            
        else:
            self.__info_string += &#34;    None\n&#34;
        
        if hasattr(self.__info_entity, &#39;eyes&#39;) and hasattr(self.__info_entity, &#39;brain&#39;) and self.__info_entity.eyes is not None:
            self.__info_string += &#34;Eyes: &#34; + &#34;\n&#34;
            for eye in self.__info_entity.eyes:
                self.__info_string += &#34;    &#34; + str(self.__info_entity.eyes.index(eye)) +&#34; (FOV: &#34; + str(math.trunc(eye.fov)) + &#34;, Range: &#34; + str(eye.range) + &#34;): &#34; + &#34;\n&#34;
                for seen_entity in self.__info_entity.brain.seen_entities:
                    self.__info_string += &#34;        &#34; + seen_entity.name + &#34;:&#34; + seen_entity.__class__.__name__ + &#34;\n&#34;

        self.__info_string += &#34;\nClick again to hide info.&#34;
        
        self.__set_text(self.__info_string)
    else:
        self.__set_text(&#34;Click on an entity to show it&#39;s informations&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Movable"><code class="flex name class">
<span>class <span class="ident">Movable</span></span>
<span>(</span><span>acceleration, max_speed, speed)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Movable():
    def __init__(self, acceleration, max_speed, speed):
        self.__acceleration = acceleration
        self.__speed = speed
        self.__max_speed = max_speed
        self.__original_max_speed = max_speed

    def move(self, time):
        self.position.set(self.position.x + self.speed.x * time + self.acceleration.x * 0.5 ** 2 * time, self.position.y + self.speed.y * time + self.acceleration.y * 0.5 ** 2 * time)
        self.speed.set(self.speed.x + self.steering_force.x, self.speed.y + self.steering_force.y)
        
        self.speed.clamp_x(-self.max_speed, self.max_speed)
        self.speed.clamp_y(-self.max_speed, self.max_speed)

    @property
    def max_speed(self):
        return self.__max_speed

    @max_speed.setter
    def max_speed(self, max_speed):
        self.__max_speed = max_speed

    @property
    def original_max_speed(self):
        return self.__original_max_speed

    @property
    def speed(self):
        return self.__speed

    @property
    def acceleration(self):
        return self.__acceleration

    @speed.setter
    def speed(self, speed):
        self.__speed = speed</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.DynamicCircle" href="#boids.DynamicCircle">DynamicCircle</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.Movable.acceleration"><code class="name">var <span class="ident">acceleration</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def acceleration(self):
    return self.__acceleration</code></pre>
</details>
</dd>
<dt id="boids.Movable.max_speed"><code class="name">var <span class="ident">max_speed</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_speed(self):
    return self.__max_speed</code></pre>
</details>
</dd>
<dt id="boids.Movable.original_max_speed"><code class="name">var <span class="ident">original_max_speed</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def original_max_speed(self):
    return self.__original_max_speed</code></pre>
</details>
</dd>
<dt id="boids.Movable.speed"><code class="name">var <span class="ident">speed</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def speed(self):
    return self.__speed</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.Movable.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, time):
    self.position.set(self.position.x + self.speed.x * time + self.acceleration.x * 0.5 ** 2 * time, self.position.y + self.speed.y * time + self.acceleration.y * 0.5 ** 2 * time)
    self.speed.set(self.speed.x + self.steering_force.x, self.speed.y + self.steering_force.y)
    
    self.speed.clamp_x(-self.max_speed, self.max_speed)
    self.speed.clamp_y(-self.max_speed, self.max_speed)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.ParamPanel"><code class="flex name class">
<span>class <span class="ident">ParamPanel</span></span>
<span>(</span><span>title)</span>
</code></dt>
<dd>
<div class="desc"><p>Ttk Labelframe widget is a container used to group other widgets
together. It has an optional label, which may be a plain text string
or another widget.</p>
<p>Construct a Ttk Labelframe with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS
labelanchor, text, underline, padding, labelwidget, width,
height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParamPanel(ttk.LabelFrame):
    def __init__(self, title):
        ttk.LabelFrame.__init__(self, root=None, text=title)
        self.__param_selected = tk.StringVar()
        self.__param_selected.set(&#34;Red chasing Green&#34;)
        self.__options_list = Utils.readfile(&#34;scenarios.txt&#34;)
        self.__combobox = ttk.Combobox(self, values=self.__options_list, textvariable=self.__param_selected, cursor=&#34;hand2&#34;, style=&#34;TCombobox&#34;,state=&#34;readonly&#34;, width=37)
    
        self.__combobox.pack()
        
    @property
    def param_selected(self):
        return self.__param_selected.get()
        
    @property
    def combobox(self):
        return self.__combobox</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Labelframe</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.SimParamPanel" href="#boids.SimParamPanel">SimParamPanel</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.ParamPanel.combobox"><code class="name">var <span class="ident">combobox</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def combobox(self):
    return self.__combobox</code></pre>
</details>
</dd>
<dt id="boids.ParamPanel.param_selected"><code class="name">var <span class="ident">param_selected</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_selected(self):
    return self.__param_selected.get()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Piloted"><code class="flex name class">
<span>class <span class="ident">Piloted</span></span>
<span>(</span><span>max_steering_force: int, steering_force: vect2d.Vect2D, steering_behaviors: list[<a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Piloted():
    def __init__(self, max_steering_force:int, steering_force:Vect2D, steering_behaviors:list[SteeringBehavior]):
        self.__max_steering_force = max_steering_force
        self.steering_force = steering_force
        self.__steering_behaviors = steering_behaviors

    def steer(self):
        if self.__steering_behaviors is not None:
            for steering_behavior in self.__steering_behaviors:
                self.steering_force.set(self.steering_force.x + steering_behavior.behave(origin_entity=self).x, self.steering_force.y + steering_behavior.behave(origin_entity=self).y)
        self.steering_force.set_polar(length= Utils.clamp_max(self.steering_force.length, self.__max_steering_force), orientation=self.steering_force.orientation)

    @property
    def max_steering_force(self):
        return self.__max_steering_force

    @property
    def steering_force(self):
        return self.__steering_force
    
    @property
    def steering_behaviors(self):
        return self.__steering_behaviors

    @steering_force.setter
    def steering_force(self, steering_force):
        self.__steering_force = steering_force</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.DynamicCircle" href="#boids.DynamicCircle">DynamicCircle</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.Piloted.max_steering_force"><code class="name">var <span class="ident">max_steering_force</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_steering_force(self):
    return self.__max_steering_force</code></pre>
</details>
</dd>
<dt id="boids.Piloted.steering_behaviors"><code class="name">var <span class="ident">steering_behaviors</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def steering_behaviors(self):
    return self.__steering_behaviors</code></pre>
</details>
</dd>
<dt id="boids.Piloted.steering_force"><code class="name">var <span class="ident">steering_force</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def steering_force(self):
    return self.__steering_force</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.Piloted.steer"><code class="name flex">
<span>def <span class="ident">steer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def steer(self):
    if self.__steering_behaviors is not None:
        for steering_behavior in self.__steering_behaviors:
            self.steering_force.set(self.steering_force.x + steering_behavior.behave(origin_entity=self).x, self.steering_force.y + steering_behavior.behave(origin_entity=self).y)
    self.steering_force.set_polar(length= Utils.clamp_max(self.steering_force.length, self.__max_steering_force), orientation=self.steering_force.orientation)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.PredatorCircle"><code class="flex name class">
<span>class <span class="ident">PredatorCircle</span></span>
<span>(</span><span>border_color=&lt;boids.RGBAColor object&gt;, border_width=5, fill_color=&lt;boids.RGBAColor object&gt;, position=vect2d.Vect2D(x=480.0, y=223.0), radius=42, acceleration=vect2d.Vect2D(x=0.0, y=0.0), speed=vect2d.Vect2D(x=17.0, y=17.0), max_speed=100, max_steering_force=5, steering_force=vect2d.Vect2D(x=0.0, y=0.0), steering_behaviors=None, fov=1.5707963267948966, range=100, environment=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PredatorCircle(SentientCircle):
    def __init__(self, border_color=RGBAColor(randomize=True), border_width=5, fill_color=RGBAColor(randomize=True), position=Vect2D(random.randrange(0,1000),random.randrange(0,500)), radius=random.randint(10, 50), acceleration=Vect2D(0,0), speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)), max_speed= 100, max_steering_force=5, steering_force=Vect2D(0,0), steering_behaviors=None, fov=math.pi/2, range=100, environment=None):
        SentientCircle.__init__(self, border_color, border_width, fill_color, position, radius, acceleration, speed, max_speed, max_steering_force, steering_force, steering_behaviors, fov, range, environment)

        predator_dict = {                   &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Pursuit, &#34;Target_type&#34; : &#34;single&#34; }, 
                                            &#34;SentientCircle&#34;: { &#34;Behavior&#34;: Pursuit, &#34;Target_type&#34; : &#34;grouping&#34; },
                                            &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                            &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                            &#34;PredatorCircle&#34;: { &#34;Behavior&#34;: Alignment, &#34;Target_type&#34; : &#34;grouping&#34; },
                                            &#34;PreyCircle&#34;: { &#34;Behavior&#34;: Seek, &#34;Target_type&#34; : &#34;single&#34; },
                                            &#34;No_target&#34;: { &#34;Behavior&#34;: PseudoWander, &#34;Target_type&#34; : &#34;none&#34; }
                        }

        self.brain = Brain(self, environment, predator_dict)    
        self.eyes = [Eye(self, fov = 20, range = 400)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.SentientCircle" href="#boids.SentientCircle">SentientCircle</a></li>
<li><a title="boids.DynamicCircle" href="#boids.DynamicCircle">DynamicCircle</a></li>
<li><a title="boids.Circle" href="#boids.Circle">Circle</a></li>
<li><a title="boids.Entity" href="#boids.Entity">Entity</a></li>
<li><a title="boids.Drawable" href="#boids.Drawable">Drawable</a></li>
<li><a title="boids.Updatable" href="#boids.Updatable">Updatable</a></li>
<li><a title="boids.Movable" href="#boids.Movable">Movable</a></li>
<li><a title="boids.Piloted" href="#boids.Piloted">Piloted</a></li>
</ul>
</dd>
<dt id="boids.PreyCircle"><code class="flex name class">
<span>class <span class="ident">PreyCircle</span></span>
<span>(</span><span>border_color=&lt;boids.RGBAColor object&gt;, border_width=5, fill_color=&lt;boids.RGBAColor object&gt;, position=vect2d.Vect2D(x=588.0, y=123.0), radius=39, acceleration=vect2d.Vect2D(x=0.0, y=0.0), speed=vect2d.Vect2D(x=-5.0, y=-26.0), max_speed=100, max_steering_force=5, steering_force=vect2d.Vect2D(x=0.0, y=0.0), steering_behaviors=None, fov=1.5707963267948966, range=100, environment=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PreyCircle(SentientCircle):
    def __init__(self, border_color=RGBAColor(randomize=True), border_width=5, fill_color=RGBAColor(randomize=True), position=Vect2D(random.randrange(0,1000),random.randrange(0,500)), radius=random.randint(10, 50), acceleration=Vect2D(0,0), speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)), max_speed= 100, max_steering_force=5, steering_force=Vect2D(0,0), steering_behaviors=None, fov=math.pi/2, range=100, environment=None):
        SentientCircle.__init__(self, border_color, border_width, fill_color, position, radius, acceleration, speed, max_speed, max_steering_force, steering_force, steering_behaviors, fov, range, environment)

        prey_dict = {                   &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; }, 
                                        &#34;SentientCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;grouping&#34; },
                                        &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;PredatorCircle&#34;: { &#34;Behavior&#34;: Flee, &#34;Target_type&#34; : &#34;grouping&#34; },
                                        &#34;PreyCircle&#34;: { &#34;Behavior&#34;: Cohesion, &#34;Target_type&#34; : &#34;grouping&#34; },    
                                        &#34;No_target&#34;: { &#34;Behavior&#34;: Wander, &#34;Target_type&#34; : &#34;none&#34; }
                        }
        self.brain = Brain(self, environment, prey_dict)    
        self.eyes = [Eye(self, fov = 95, range = 100)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.SentientCircle" href="#boids.SentientCircle">SentientCircle</a></li>
<li><a title="boids.DynamicCircle" href="#boids.DynamicCircle">DynamicCircle</a></li>
<li><a title="boids.Circle" href="#boids.Circle">Circle</a></li>
<li><a title="boids.Entity" href="#boids.Entity">Entity</a></li>
<li><a title="boids.Drawable" href="#boids.Drawable">Drawable</a></li>
<li><a title="boids.Updatable" href="#boids.Updatable">Updatable</a></li>
<li><a title="boids.Movable" href="#boids.Movable">Movable</a></li>
<li><a title="boids.Piloted" href="#boids.Piloted">Piloted</a></li>
</ul>
</dd>
<dt id="boids.PseudoWander"><code class="flex name class">
<span>class <span class="ident">PseudoWander</span></span>
<span>(</span><span>radius: float = 100, circle_distance: float = 100, angle_change: float = 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a steering behavior object that can be used to steer an entity.
It is an abstract class. It contains a abstract method called behave() that is used to steer an entity (dynamicCircles).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PseudoWander(SteeringBehavior):
    def __init__(self, radius:float=100, circle_distance:float=100, angle_change:float=0.5):
        super().__init__()
        &#39;&#39;&#39;radius will increase the turning distance
        circle_distance will increase the distance before turning
        angle_change will increase the turning rate
        &#39;&#39;&#39;        
        self.__circle_distance = circle_distance
        self.__radius = radius
        self.__angle_change = angle_change
        self.__wander_angle = random.random() * 2 * math.pi
        
    def set_angle(self, vector:Vect2D, angle:float) -&gt; Vect2D:
        length = vector.length
        vector.x = math.cos(angle) * length
        vector.y = math.sin(angle) * length
        return vector
        
    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:     
        &#39;&#39;&#39;Retruns a vector that points in a random direction

        Args:
            origin_entity (Entity): the sprite that is wandering

        Returns:
            Vect2D: displacement vector
        &#39;&#39;&#39;        
        circle_center = origin_entity.speed.copy()
        circle_center.normalize()
        circle_center *= self.__circle_distance
        
        displacement = Vect2D.from_random_normalized()
        displacement *= self.__radius
        
        self.set_angle(displacement, self.__wander_angle)
        
        self.__wander_angle += (random.random() * self.__angle_change) - (self.__angle_change * .5)
        
        desired_speed = circle_center + displacement
        
        return desired_speed - origin_entity.speed</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.PseudoWander.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"><p>Retruns a vector that points in a random direction</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>origin_entity</code></strong> :&ensp;<code><a title="boids.Entity" href="#boids.Entity">Entity</a></code></dt>
<dd>the sprite that is wandering</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Vect2D</code></dt>
<dd>displacement vector</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:     
    &#39;&#39;&#39;Retruns a vector that points in a random direction

    Args:
        origin_entity (Entity): the sprite that is wandering

    Returns:
        Vect2D: displacement vector
    &#39;&#39;&#39;        
    circle_center = origin_entity.speed.copy()
    circle_center.normalize()
    circle_center *= self.__circle_distance
    
    displacement = Vect2D.from_random_normalized()
    displacement *= self.__radius
    
    self.set_angle(displacement, self.__wander_angle)
    
    self.__wander_angle += (random.random() * self.__angle_change) - (self.__angle_change * .5)
    
    desired_speed = circle_center + displacement
    
    return desired_speed - origin_entity.speed</code></pre>
</details>
</dd>
<dt id="boids.PseudoWander.set_angle"><code class="name flex">
<span>def <span class="ident">set_angle</span></span>(<span>self, vector: vect2d.Vect2D, angle: float) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_angle(self, vector:Vect2D, angle:float) -&gt; Vect2D:
    length = vector.length
    vector.x = math.cos(angle) * length
    vector.y = math.sin(angle) * length
    return vector</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Pursuit"><code class="flex name class">
<span>class <span class="ident">Pursuit</span></span>
<span>(</span><span>target_entities: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'] = None, ratio: int = 1, attraction_repulsion_force: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a steering behavior object that can be used to steer an entity.
It is an abstract class. It contains a abstract method called behave() that is used to steer an entity (dynamicCircles).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pursuit(SteeringBehavior):
    def __init__(self, target_entities:type[&#39;Entity&#39;]=None, ratio:int = 1, attraction_repulsion_force:int=1):
        super().__init__(target_entities, attraction_repulsion_force=attraction_repulsion_force)
        self.__ratio = ratio
        
    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        sum_of_forces = Vect2D(0, 0)
        for target_entity in self.target_entities:
            if target_entity is not None:
                estimated_position = target_entity.position + target_entity.speed  * self.__ratio 
                desired_speed = (estimated_position - origin_entity.position).normalized * origin_entity.max_speed
                sum_of_forces += (desired_speed - origin_entity.speed) * self.attraction_repulsion_force
        return sum_of_forces</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.Evade" href="#boids.Evade">Evade</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.Pursuit.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
    sum_of_forces = Vect2D(0, 0)
    for target_entity in self.target_entities:
        if target_entity is not None:
            estimated_position = target_entity.position + target_entity.speed  * self.__ratio 
            desired_speed = (estimated_position - origin_entity.position).normalized * origin_entity.max_speed
            sum_of_forces += (desired_speed - origin_entity.speed) * self.attraction_repulsion_force
    return sum_of_forces</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.RGBAColor"><code class="flex name class">
<span>class <span class="ident">RGBAColor</span></span>
<span>(</span><span>r: int = 255, g: int = 255, b: int = 255, a: int = 255, randomize: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a color object that can be used to draw shapes on the image.
It can be used to create a random color or a specific color. To create a random color, use the
randomize_color() method. To create a specific color, use the RGBAColor(r, g, b, a) constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RGBAColor():
    &#34;&#34;&#34;
    This class is used to create a color object that can be used to draw shapes on the image.
    It can be used to create a random color or a specific color. To create a random color, use the
    randomize_color() method. To create a specific color, use the RGBAColor(r, g, b, a) constructor.
    &#34;&#34;&#34;
    def __init__(self, r:int=255, g:int=255, b:int=255, a:int=255, randomize:bool=False):
        self.__r = r
        self.__g = g
        self.__b = b
        self.__a = a

        if randomize:
            self.randomize_color()
        
    @property
    def r(self):
        return self.__r
        
    @property
    def g(self):
        return self.__g
        
    @property
    def b(self):
        return self.__b
        
    @property
    def a(self):
        return self.__a
    
    @property
    def rgba(self):
        return (self.__r, self.__g, self.__b, self.__a)
    
    @rgba.setter
    def rgba(self, rgba):
        self.r = rgba[0]
        self.g = rgba[1]
        self.b = rgba[2]
        self.a = rgba[3]
        
    def randomize_color(self):
        self.__r = random.randint(0, 255)
        self.__g = random.randint(0, 255)
        self.__b = random.randint(0, 255)
        self.__a = random.randint(0, 255)
    &#34;&#34;&#34;randomize_color() returns None and randomizes the color values of the object.&#34;&#34;&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="boids.RGBAColor.a"><code class="name">var <span class="ident">a</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def a(self):
    return self.__a</code></pre>
</details>
</dd>
<dt id="boids.RGBAColor.b"><code class="name">var <span class="ident">b</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def b(self):
    return self.__b</code></pre>
</details>
</dd>
<dt id="boids.RGBAColor.g"><code class="name">var <span class="ident">g</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def g(self):
    return self.__g</code></pre>
</details>
</dd>
<dt id="boids.RGBAColor.r"><code class="name">var <span class="ident">r</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def r(self):
    return self.__r</code></pre>
</details>
</dd>
<dt id="boids.RGBAColor.rgba"><code class="name">var <span class="ident">rgba</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rgba(self):
    return (self.__r, self.__g, self.__b, self.__a)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.RGBAColor.randomize_color"><code class="name flex">
<span>def <span class="ident">randomize_color</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def randomize_color(self):
    self.__r = random.randint(0, 255)
    self.__g = random.randint(0, 255)
    self.__b = random.randint(0, 255)
    self.__a = random.randint(0, 255)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Seek"><code class="flex name class">
<span>class <span class="ident">Seek</span></span>
<span>(</span><span>target_entities: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'] = None, attraction_repulsion_force: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a seek steering behavior object.
It is a child class of the SteeringBehavior class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Seek(SteeringBehavior):
    &#34;&#34;&#34;
    This class is used to create a seek steering behavior object.
    It is a child class of the SteeringBehavior class.
    &#34;&#34;&#34;
    def __init__(self, target_entities:type[&#39;Entity&#39;]=None, attraction_repulsion_force:int=1): 
        SteeringBehavior.__init__(self, target_entities, attraction_repulsion_force)

    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        sum_of_forces = Vect2D(0, 0)
        for target_entity in self.target_entities:
            if target_entity is not None:
                if isinstance(target_entity, Entity):
                    desired_speed = (target_entity.position - origin_entity.position).normalized * origin_entity.max_speed
                    sum_of_forces += desired_speed - origin_entity.speed * self.attraction_repulsion_force
                elif isinstance(target_entity, Vect2D) and (target_entity.x != -1 and target_entity.y != -1):
                    desired_speed = (target_entity - origin_entity.position).normalized * origin_entity.max_speed
                    sum_of_forces += (desired_speed - origin_entity.speed) * self.attraction_repulsion_force
        return sum_of_forces</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.Flee" href="#boids.Flee">Flee</a></li>
<li><a title="boids.Wander" href="#boids.Wander">Wander</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.Seek.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
    sum_of_forces = Vect2D(0, 0)
    for target_entity in self.target_entities:
        if target_entity is not None:
            if isinstance(target_entity, Entity):
                desired_speed = (target_entity.position - origin_entity.position).normalized * origin_entity.max_speed
                sum_of_forces += desired_speed - origin_entity.speed * self.attraction_repulsion_force
            elif isinstance(target_entity, Vect2D) and (target_entity.x != -1 and target_entity.y != -1):
                desired_speed = (target_entity - origin_entity.position).normalized * origin_entity.max_speed
                sum_of_forces += (desired_speed - origin_entity.speed) * self.attraction_repulsion_force
    return sum_of_forces</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.SentientCircle"><code class="flex name class">
<span>class <span class="ident">SentientCircle</span></span>
<span>(</span><span>border_color=&lt;boids.RGBAColor object&gt;, border_width=5, fill_color=&lt;boids.RGBAColor object&gt;, position=vect2d.Vect2D(x=271.0, y=75.0), radius=27, acceleration=vect2d.Vect2D(x=0.0, y=0.0), speed=vect2d.Vect2D(x=-50.0, y=-9.0), max_speed=100, max_steering_force=5, steering_force=vect2d.Vect2D(x=0.0, y=0.0), steering_behaviors=None, environment=None, brain=None, eyes=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SentientCircle(DynamicCircle):
    def __init__(self, border_color=RGBAColor(randomize=True), border_width=5, fill_color=RGBAColor(randomize=True), position=Vect2D(random.randrange(0,1000),random.randrange(0,500)), radius=random.randint(10, 50), acceleration=Vect2D(0,0), speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)), max_speed= 100, max_steering_force=5, steering_force=Vect2D(0,0), steering_behaviors=None, environment=None, brain=None, eyes=None):
        DynamicCircle.__init__(self, border_color, border_width, fill_color, position, radius, acceleration, speed, max_speed, max_steering_force, steering_force, steering_behaviors)

        self.__brain = brain if brain else Brain(self, environment)
        
        self.__eyes = eyes if eyes else [Eye(self)]

    def tick(self, time):
        DynamicCircle.tick(self, time)
        self.__brain.process()

    def draw_fov(self, draw):
        for eye in self.__eyes:
            eye.draw(draw)    
        self.__brain.draw_line_to_seen_entities(draw)

    def draw_circle_steering_force(self, draw):
        draw.line([self.position.x, self.position.y, self.position.x + self.steering_force.x * 10, self.position.y + self.steering_force.y * 10], fill=&#34;darkgoldenrod&#34;, width=5)
        for steering_behavior in self.__brain.active_behaviors:
            if hasattr(steering_behavior, &#34;draw&#34;):
                    steering_behavior.draw(draw)
                    
    @property
    def eyes(self):
        return self.__eyes
    
    @property
    def brain(self):
        return self.__brain
    
    @eyes.setter
    def eyes(self, eyes):
        self.__eyes = eyes
        
    @brain.setter
    def brain(self, brain):
        self.__brain = brain</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.DynamicCircle" href="#boids.DynamicCircle">DynamicCircle</a></li>
<li><a title="boids.Circle" href="#boids.Circle">Circle</a></li>
<li><a title="boids.Entity" href="#boids.Entity">Entity</a></li>
<li><a title="boids.Drawable" href="#boids.Drawable">Drawable</a></li>
<li><a title="boids.Updatable" href="#boids.Updatable">Updatable</a></li>
<li><a title="boids.Movable" href="#boids.Movable">Movable</a></li>
<li><a title="boids.Piloted" href="#boids.Piloted">Piloted</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.PredatorCircle" href="#boids.PredatorCircle">PredatorCircle</a></li>
<li><a title="boids.PreyCircle" href="#boids.PreyCircle">PreyCircle</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.SentientCircle.brain"><code class="name">var <span class="ident">brain</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def brain(self):
    return self.__brain</code></pre>
</details>
</dd>
<dt id="boids.SentientCircle.eyes"><code class="name">var <span class="ident">eyes</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def eyes(self):
    return self.__eyes</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.SentientCircle.draw_circle_steering_force"><code class="name flex">
<span>def <span class="ident">draw_circle_steering_force</span></span>(<span>self, draw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_circle_steering_force(self, draw):
    draw.line([self.position.x, self.position.y, self.position.x + self.steering_force.x * 10, self.position.y + self.steering_force.y * 10], fill=&#34;darkgoldenrod&#34;, width=5)
    for steering_behavior in self.__brain.active_behaviors:
        if hasattr(steering_behavior, &#34;draw&#34;):
                steering_behavior.draw(draw)</code></pre>
</details>
</dd>
<dt id="boids.SentientCircle.draw_fov"><code class="name flex">
<span>def <span class="ident">draw_fov</span></span>(<span>self, draw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_fov(self, draw):
    for eye in self.__eyes:
        eye.draw(draw)    
    self.__brain.draw_line_to_seen_entities(draw)</code></pre>
</details>
</dd>
<dt id="boids.SentientCircle.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tick(self, time):
    DynamicCircle.tick(self, time)
    self.__brain.process()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Separation"><code class="flex name class">
<span>class <span class="ident">Separation</span></span>
<span>(</span><span>target_entities: list[type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'] | type['Vect2D']], attraction_repulsion_force: int = 50)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a steering behavior object that can be used to steer an entity.
It is an abstract class. It contains a abstract method called behave() that is used to steer an entity (dynamicCircles).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Separation(SteeringBehavior):
    def __init__(self, target_entities:list[type[&#39;Entity&#39;]|type[&#39;Vect2D&#39;]], attraction_repulsion_force:int=50):
        super().__init__(target_entities, attraction_repulsion_force)
        
    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        sum_of_forces = Vect2D()
        for target_entity in self.target_entities:
            if target_entity is not None:
                if isinstance(target_entity, Entity):
                    behavior = EntityRepulsion([target_entity], self.attraction_repulsion_force)
                    sum_of_forces += behavior.behave(origin_entity)
        return sum_of_forces</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.Separation.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
    sum_of_forces = Vect2D()
    for target_entity in self.target_entities:
        if target_entity is not None:
            if isinstance(target_entity, Entity):
                behavior = EntityRepulsion([target_entity], self.attraction_repulsion_force)
                sum_of_forces += behavior.behave(origin_entity)
    return sum_of_forces</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.SimParamPanel"><code class="flex name class">
<span>class <span class="ident">SimParamPanel</span></span>
</code></dt>
<dd>
<div class="desc"><p>Ttk Labelframe widget is a container used to group other widgets
together. It has an optional label, which may be a plain text string
or another widget.</p>
<p>Construct a Ttk Labelframe with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS
labelanchor, text, underline, padding, labelwidget, width,
height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimParamPanel(ParamPanel):
    def __init__(self):
        pass    </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.ParamPanel" href="#boids.ParamPanel">ParamPanel</a></li>
<li>tkinter.ttk.Labelframe</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
</dd>
<dt id="boids.Simulation"><code class="flex name class">
<span>class <span class="ident">Simulation</span></span>
<span>(</span><span>size=vect2d.Vect2D(x=100.0, y=100.0))</span>
</code></dt>
<dd>
<div class="desc"><p>La classe Simulation correspond à la simulation elle-même.
Elle contient les sprites, la taille de l'image, la position de la souris, et la boucle de jeu qui bouge les Entities.
Elle contient aussi les fonctions de dessin, qui sont appelées par la fonction draw() de la classe Window.</p>
<h2 id="args">Args</h2>
<ul>
<li>:param size: Vect2D, la taille de la fenêtre</li>
<li>:param sprites: list, la liste des sprites</li>
<li>:param mouse_pos: Vect2D, la position de la souris</li>
<li>:param is_running: bool, True si la simulation est en cours, False sinon</li>
<li>:param seed: int, le seed pour la génération aléatoire</li>
<li>:param selected_entity: Entity, l'entité sélectionnée par le click de la souris
Exemples: Créé une simulation et l'initialise un scénario</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; sim = Simulation()
&gt;&gt;&gt; sim.initialize_scenario(key=&quot;Seek, Flee or Wander&quot;)
&gt;&gt;&gt; print(len(sim.sprites))
250
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulation(Updatable):
    &#34;&#34;&#34; La classe Simulation correspond à la simulation elle-même. 
        Elle contient les sprites, la taille de l&#39;image, la position de la souris, et la boucle de jeu qui bouge les Entities.
        Elle contient aussi les fonctions de dessin, qui sont appelées par la fonction draw() de la classe Window.
       
        Args:
            - :param size: Vect2D, la taille de la fenêtre
            - :param sprites: list, la liste des sprites
            - :param mouse_pos: Vect2D, la position de la souris
            - :param is_running: bool, True si la simulation est en cours, False sinon
            - :param seed: int, le seed pour la génération aléatoire
            - :param selected_entity: Entity, l&#39;entité sélectionnée par le click de la souris
        
        Exemples: Créé une simulation et l&#39;initialise un scénario
        &gt;&gt;&gt; sim = Simulation()
        &gt;&gt;&gt; sim.initialize_scenario(key=&#34;Seek, Flee or Wander&#34;)
        &gt;&gt;&gt; print(len(sim.sprites))
        250
    &#34;&#34;&#34;
    def __init__(self, size=Vect2D(100,100)):
        self.__size = size
        self.__sprites = []
        self.__mouse_pos = Vect2D(-1, -1)
        self.__is_running = True
        self.__seed = 0
        self.__selected_entity = None
        
        self.initialize_scenario()

    def initialize_scenario(self, key:str=&#34;Red chasing Green&#34;): 
        key = key.replace(&#34;\n&#34;, &#34;&#34;)
        nb_balls = 0
                
        match key:
            case &#39;Seek, Flee or Wander&#39;:
                nb_balls = 250
                for i in range(nb_balls):
                    self.__sprites.append(DynamicCircle(    border_color=RGBAColor(randomize=True),
                                                            border_width=5,
                                                            fill_color=RGBAColor(randomize=True),
                                                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                            radius=random.randint(10, 50),
                                                            acceleration=Vect2D(0,0),
                                                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                            max_speed= 100,
                                                            max_steering_force=5,
                                                            steering_force=Vect2D(0,0),
                                                            steering_behaviors=[BorderRepulsion(sim_dim=self.__size)]))

                for sprite in self.__sprites:
                    random_sprite = random.choice(self.__sprites)
                    while random_sprite == sprite:
                        random_sprite = random.choice(self.__sprites)

                    random_steering_behavior = random.choice([Seek([random_sprite]), Flee([random_sprite]), Wander()])
                    sprite.steering_behaviors.append(random_steering_behavior)
                    sprite.fill_color = RGBAColor(0, 128, 0, 255) if type(random_steering_behavior) is Flee else RGBAColor(128, 0, 0, 255) if type(random_steering_behavior) is Seek else RGBAColor(0, 0, 128, 255)

            case &#39;Seek or Flee Mouse&#39;:
                nb_balls = 20
                for i in range(nb_balls):
                    random_steering_behavior = random.choice([Seek([self.__mouse_pos]), Flee([self.__mouse_pos])])

                    self.__sprites.append(DynamicCircle(    border_color=RGBAColor(randomize=True),
                                                            border_width=5,
                                                            fill_color = RGBAColor(0, 128, 0, 255) if type(random_steering_behavior) is Flee else RGBAColor(128, 0, 0, 255) if type(random_steering_behavior) is Seek else RGBAColor(0, 0, 128, 255),
                                                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                            radius=random.randint(10, 50),
                                                            acceleration=Vect2D(0,0),
                                                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                            max_speed= 100,
                                                            max_steering_force=5,
                                                            steering_force=Vect2D(0,0),
                                                            steering_behaviors=[Wander(), random_steering_behavior, BorderRepulsion(sim_dim=self.__size)]))

            case &#39;Follow the leader&#39;:
                nb_balls = 20
                for i in range(nb_balls):
                    self.__sprites.append(DynamicCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                        speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                        fill_color = RGBAColor(128, 0, 128, 255)  if len(self.__sprites) == nb_balls-1 else RGBAColor(128, 128, 0, 255),
                                                        border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        radius=random.randint(10, 50),
                                                        acceleration=Vect2D(0,0),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        steering_behaviors=[Wander(), BorderRepulsion(sim_dim=self.__size)] if i == nb_balls-1 else [BorderRepulsion(sim_dim=self.__size)]))

                for i, sprite in enumerate(self.__sprites):
                    if i != len(self.__sprites)-1:
                        sprite.steering_behaviors.append(Pursuit([self.__sprites[i-1]]))
                        sprite.radius = (nb_balls - i - 1) * 2
                    else: sprite.radius = nb_balls * 2
                    
            case &#39;Cohesion&#39;:
                nb_balls = 50
                for i in range(nb_balls):
                                self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                                                            border_width=5,
                                                            fill_color=RGBAColor(randomize=True),
                                                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                            radius=random.randint(5, 10),
                                                            acceleration=Vect2D(0,0),
                                                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                            max_speed= 100,
                                                            max_steering_force=5,
                                                            steering_force=Vect2D(0,0),
                                                            environment=self
                                                            ))
        
            case &#39;Alignment&#39;:
                nb_balls = 50

                behavior_patterns =  {  &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; }, 
                                        &#34;SentientCircle&#34;: { &#34;Behavior&#34;: Alignment, &#34;Target_type&#34; : &#34;grouping&#34; },
                                        &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;No_target&#34;: { &#34;Behavior&#34;: Wander, &#34;Target_type&#34; : &#34;none&#34; }
                                    }

                for i in range(nb_balls):
                                self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                                                            border_width=5,
                                                            fill_color=RGBAColor(randomize=True),
                                                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                            radius=random.randint(5, 10),
                                                            acceleration=Vect2D(0,0),
                                                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                            max_speed= 100,
                                                            max_steering_force=5,
                                                            steering_force=Vect2D(0,0),
                                                            environment=self
                                                            ))
                for sprite in self.__sprites:
                    sprite.brain.behavior_patterns = behavior_patterns


            case &#39;Follow Biggest Boid Seen&#39;:
                nb_balls = 50

                behavior_patterns =  {  &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; }, 
                                        &#34;SentientCircle&#34;: { &#34;Behavior&#34;: FollowBiggestBoidSeen, &#34;Target_type&#34; : &#34;grouping&#34; },
                                        &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                        &#34;No_target&#34;: { &#34;Behavior&#34;: Wander, &#34;Target_type&#34; : &#34;none&#34; }
                                    }
                eye_fov = 500
                eye_range = 150

                for i in range(nb_balls):
                                self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                                                            border_width=5,
                                                            fill_color=RGBAColor(randomize=True),
                                                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                            radius=random.randint(5, 50),
                                                            acceleration=Vect2D(0,0),
                                                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                            max_speed= 100,
                                                            max_steering_force=5,
                                                            steering_force=Vect2D(0,0),
                                                            environment=self
                                                            ))

                for sprite in self.__sprites:
                    sprite.brain.behavior_patterns = behavior_patterns
                    sprite.eye.fov = eye_fov
                    sprite.eye.range = eye_range

            case &#34;Rise of Sentience&#34;:
                nb_sentients = 10
                nb_dumbs = 10
                for i in range(nb_sentients):
                    self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                            border_width=5,
                            radius=10,
                            fill_color=RGBAColor(randomize=True),
                            position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                            acceleration=Vect2D(0,0),
                            speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                            max_speed= 100,
                            max_steering_force=5,
                            steering_force=Vect2D(0,0),
                            environment=self
                            ))

                for i in range(nb_dumbs):
                    self.__sprites.append(DynamicCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                        speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                        border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        radius=25,
                                                        fill_color= RGBAColor(33,33,33,255),
                                                        acceleration=Vect2D(0,0),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        steering_behaviors=[Wander(), BorderRepulsion(sim_dim=self.__size)]))


            case &#39;Predator Chasing Prey&#39;: # Default
                nb_obstacles = 5
                nb_predators = 2
                nb_preys = 10
                for _ in range(nb_predators):
                    self.__sprites.append(PredatorCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                        speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                        border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        acceleration=Vect2D(0,0),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        environment=self,
                                                        fill_color=RGBAColor(255,0,0,255)
                                                       ))
                for _ in range(nb_preys):
                    self.__sprites.append(PreyCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                        speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                        border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        acceleration=Vect2D(0,0),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        environment=self,
                                                        fill_color=RGBAColor(0,255,0,255)
                                                       ))
                for _ in range(nb_obstacles):
                    self.__sprites.append(Circle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height)))))
            
            case &#39;Avoid Obstacles&#39;:
                nb_obstacles = 20
                nb_sentient_circles = 10
                        
                for _ in range(nb_obstacles):
                    self.__sprites.append(Circle(   position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                    radius=25))

                for _ in range(nb_sentient_circles):
                    self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                    border_width=5,
                    radius=10,
                    fill_color=RGBAColor(randomize=True),
                    position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                    acceleration=Vect2D(0,0),
                    speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                    max_speed= 100,
                    max_steering_force=5,
                    steering_force=Vect2D(0,0),
                    environment=self
                    ))


            case &#39;Red chasing Green&#39;: # Default
                nb_balls = 6
                for i in range(nb_balls):
                    self.__sprites.append(DynamicCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                        speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                        border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        acceleration=Vect2D(0,0),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        steering_behaviors=[Wander(), BorderRepulsion(sim_dim=self.__size)] if i%2 == 0 else [Pursuit([self.sprites[i-1]]), BorderRepulsion(sim_dim=self.__size)]))

                for i, sprite in enumerate(self.__sprites):
                    sprite.fill_color = RGBAColor(128, 0, 0, 255) if type(sprite.steering_behaviors[0]) is Pursuit else RGBAColor(0, 128, 0, 255)
                    sprite.radius = 60 if type(sprite.steering_behaviors[0]) is Pursuit else 30
                    if i%2 == 0 and i != len(self.__sprites) - 1:
                        self.__sprites[i].steering_behaviors.append(Evade([self.__sprites[i+1]]))

    def tick(self, time):
        &#34;&#34;&#34;Fait bouger les Entities, est appelée par la fonction update() de la classe App&#34;&#34;&#34;
        if self.__sprites:
            for sprite in self.__sprites:
                sprite.tick(time)

    def reset(self, key:str=&#34;Red chasing Green&#34;):
        &#34;&#34;&#34;Remet la simulation à zéro&#34;&#34;&#34;
        self.__is_running = True
        self.__sprites = []
        self.initialize_scenario(key)

    def move_mouse(self, event):
        &#34;&#34;&#34;Met à jour la position de la souris&#34;&#34;&#34;
        self.__mouse_pos.set(event.x, event.y)
        
    def mouse_left(self, event):
        &#34;&#34;&#34;Gère la sortie de la souris de la fenêtre&#34;&#34;&#34;
        self.__mouse_pos.set(-1, -1)
        
        for sprite in self.__sprites:
            sprite.steering_force = Vect2D(0,0)

    def mouse_entered(self, event):
        &#34;&#34;&#34;Gère l&#39;entrée de la souris dans la fenêtre&#34;&#34;&#34;
        self.__mouse_pos.set(event.x, event.y)
        
    def toggle_running(self, event):
        &#34;&#34;&#34;Met en pause ou en reprend la simulation&#34;&#34;&#34;
        self.__is_running = not self.__is_running
        
    def check_entity_clicked(self, event):
        &#34;&#34;&#34;Vérifie si une entité a été cliquée avec un offset de 20 pixels pour le miss click&#34;&#34;&#34;
        radius_offset = 20
        for sprite in reversed(self.__sprites):
            if sprite.position.x - (sprite.radius + radius_offset) &lt; event.x &lt; sprite.position.x + (sprite.radius + radius_offset) and sprite.position.y - (sprite.radius + radius_offset) &lt; event.y &lt; sprite.position.y + (sprite.radius + radius_offset):
                return sprite

    @property
    def selected_entity(self):
        &#34;&#34;&#34;Retourne l&#39;entité sélectionnée&#34;&#34;&#34;
        return self.__selected_entity
    
    @selected_entity.setter
    def selected_entity(self, value):
        &#34;&#34;&#34;Définit l&#39;entité sélectionnée&#34;&#34;&#34;
        self.__selected_entity = value

    @property
    def sprites(self):
        &#34;&#34;&#34;Retourne la liste des sprites&#34;&#34;&#34;
        return self.__sprites
    
    @property
    def mouse_pos(self):
        &#34;&#34;&#34;Retourne la position de la souris&#34;&#34;&#34;
        return self.__mouse_pos
    
    @property
    def size(self):
        &#34;&#34;&#34;Retourne la taille de la fenêtre&#34;&#34;&#34;
        return self.__size

    @property
    def width(self):
        &#34;&#34;&#34;Retourne la largeur de la fenêtre&#34;&#34;&#34;
        return self.__size.x

    @property
    def height(self):
        &#34;&#34;&#34;Retourne la hauteur de la fenêtre&#34;&#34;&#34;
        return self.__size.y
    
    @property
    def is_running(self):
        &#34;&#34;&#34;Retourne True si la simulation est en cours, False sinon&#34;&#34;&#34;
        return self.__is_running</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.Updatable" href="#boids.Updatable">Updatable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.Simulation.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"><p>Retourne la hauteur de la fenêtre</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self):
    &#34;&#34;&#34;Retourne la hauteur de la fenêtre&#34;&#34;&#34;
    return self.__size.y</code></pre>
</details>
</dd>
<dt id="boids.Simulation.is_running"><code class="name">var <span class="ident">is_running</span></code></dt>
<dd>
<div class="desc"><p>Retourne True si la simulation est en cours, False sinon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_running(self):
    &#34;&#34;&#34;Retourne True si la simulation est en cours, False sinon&#34;&#34;&#34;
    return self.__is_running</code></pre>
</details>
</dd>
<dt id="boids.Simulation.mouse_pos"><code class="name">var <span class="ident">mouse_pos</span></code></dt>
<dd>
<div class="desc"><p>Retourne la position de la souris</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mouse_pos(self):
    &#34;&#34;&#34;Retourne la position de la souris&#34;&#34;&#34;
    return self.__mouse_pos</code></pre>
</details>
</dd>
<dt id="boids.Simulation.selected_entity"><code class="name">var <span class="ident">selected_entity</span></code></dt>
<dd>
<div class="desc"><p>Retourne l'entité sélectionnée</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def selected_entity(self):
    &#34;&#34;&#34;Retourne l&#39;entité sélectionnée&#34;&#34;&#34;
    return self.__selected_entity</code></pre>
</details>
</dd>
<dt id="boids.Simulation.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>Retourne la taille de la fenêtre</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    &#34;&#34;&#34;Retourne la taille de la fenêtre&#34;&#34;&#34;
    return self.__size</code></pre>
</details>
</dd>
<dt id="boids.Simulation.sprites"><code class="name">var <span class="ident">sprites</span></code></dt>
<dd>
<div class="desc"><p>Retourne la liste des sprites</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sprites(self):
    &#34;&#34;&#34;Retourne la liste des sprites&#34;&#34;&#34;
    return self.__sprites</code></pre>
</details>
</dd>
<dt id="boids.Simulation.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"><p>Retourne la largeur de la fenêtre</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self):
    &#34;&#34;&#34;Retourne la largeur de la fenêtre&#34;&#34;&#34;
    return self.__size.x</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.Simulation.check_entity_clicked"><code class="name flex">
<span>def <span class="ident">check_entity_clicked</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Vérifie si une entité a été cliquée avec un offset de 20 pixels pour le miss click</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_entity_clicked(self, event):
    &#34;&#34;&#34;Vérifie si une entité a été cliquée avec un offset de 20 pixels pour le miss click&#34;&#34;&#34;
    radius_offset = 20
    for sprite in reversed(self.__sprites):
        if sprite.position.x - (sprite.radius + radius_offset) &lt; event.x &lt; sprite.position.x + (sprite.radius + radius_offset) and sprite.position.y - (sprite.radius + radius_offset) &lt; event.y &lt; sprite.position.y + (sprite.radius + radius_offset):
            return sprite</code></pre>
</details>
</dd>
<dt id="boids.Simulation.initialize_scenario"><code class="name flex">
<span>def <span class="ident">initialize_scenario</span></span>(<span>self, key: str = 'Red chasing Green')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_scenario(self, key:str=&#34;Red chasing Green&#34;): 
    key = key.replace(&#34;\n&#34;, &#34;&#34;)
    nb_balls = 0
            
    match key:
        case &#39;Seek, Flee or Wander&#39;:
            nb_balls = 250
            for i in range(nb_balls):
                self.__sprites.append(DynamicCircle(    border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        fill_color=RGBAColor(randomize=True),
                                                        position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                        radius=random.randint(10, 50),
                                                        acceleration=Vect2D(0,0),
                                                        speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        steering_behaviors=[BorderRepulsion(sim_dim=self.__size)]))

            for sprite in self.__sprites:
                random_sprite = random.choice(self.__sprites)
                while random_sprite == sprite:
                    random_sprite = random.choice(self.__sprites)

                random_steering_behavior = random.choice([Seek([random_sprite]), Flee([random_sprite]), Wander()])
                sprite.steering_behaviors.append(random_steering_behavior)
                sprite.fill_color = RGBAColor(0, 128, 0, 255) if type(random_steering_behavior) is Flee else RGBAColor(128, 0, 0, 255) if type(random_steering_behavior) is Seek else RGBAColor(0, 0, 128, 255)

        case &#39;Seek or Flee Mouse&#39;:
            nb_balls = 20
            for i in range(nb_balls):
                random_steering_behavior = random.choice([Seek([self.__mouse_pos]), Flee([self.__mouse_pos])])

                self.__sprites.append(DynamicCircle(    border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        fill_color = RGBAColor(0, 128, 0, 255) if type(random_steering_behavior) is Flee else RGBAColor(128, 0, 0, 255) if type(random_steering_behavior) is Seek else RGBAColor(0, 0, 128, 255),
                                                        position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                        radius=random.randint(10, 50),
                                                        acceleration=Vect2D(0,0),
                                                        speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        steering_behaviors=[Wander(), random_steering_behavior, BorderRepulsion(sim_dim=self.__size)]))

        case &#39;Follow the leader&#39;:
            nb_balls = 20
            for i in range(nb_balls):
                self.__sprites.append(DynamicCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                    speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                    fill_color = RGBAColor(128, 0, 128, 255)  if len(self.__sprites) == nb_balls-1 else RGBAColor(128, 128, 0, 255),
                                                    border_color=RGBAColor(randomize=True),
                                                    border_width=5,
                                                    radius=random.randint(10, 50),
                                                    acceleration=Vect2D(0,0),
                                                    max_speed= 100,
                                                    max_steering_force=5,
                                                    steering_force=Vect2D(0,0),
                                                    steering_behaviors=[Wander(), BorderRepulsion(sim_dim=self.__size)] if i == nb_balls-1 else [BorderRepulsion(sim_dim=self.__size)]))

            for i, sprite in enumerate(self.__sprites):
                if i != len(self.__sprites)-1:
                    sprite.steering_behaviors.append(Pursuit([self.__sprites[i-1]]))
                    sprite.radius = (nb_balls - i - 1) * 2
                else: sprite.radius = nb_balls * 2
                
        case &#39;Cohesion&#39;:
            nb_balls = 50
            for i in range(nb_balls):
                            self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        fill_color=RGBAColor(randomize=True),
                                                        position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                        radius=random.randint(5, 10),
                                                        acceleration=Vect2D(0,0),
                                                        speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        environment=self
                                                        ))
    
        case &#39;Alignment&#39;:
            nb_balls = 50

            behavior_patterns =  {  &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; }, 
                                    &#34;SentientCircle&#34;: { &#34;Behavior&#34;: Alignment, &#34;Target_type&#34; : &#34;grouping&#34; },
                                    &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                    &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                    &#34;No_target&#34;: { &#34;Behavior&#34;: Wander, &#34;Target_type&#34; : &#34;none&#34; }
                                }

            for i in range(nb_balls):
                            self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        fill_color=RGBAColor(randomize=True),
                                                        position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                        radius=random.randint(5, 10),
                                                        acceleration=Vect2D(0,0),
                                                        speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        environment=self
                                                        ))
            for sprite in self.__sprites:
                sprite.brain.behavior_patterns = behavior_patterns


        case &#39;Follow Biggest Boid Seen&#39;:
            nb_balls = 50

            behavior_patterns =  {  &#34;DynamicCircle&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; }, 
                                    &#34;SentientCircle&#34;: { &#34;Behavior&#34;: FollowBiggestBoidSeen, &#34;Target_type&#34; : &#34;grouping&#34; },
                                    &#34;Circle&#34;: { &#34;Behavior&#34;: EntityRepulsion, &#34;Target_type&#34; : &#34;single&#34; },
                                    &#34;Unknown&#34;: { &#34;Behavior&#34;: Evade, &#34;Target_type&#34; : &#34;single&#34; },
                                    &#34;No_target&#34;: { &#34;Behavior&#34;: Wander, &#34;Target_type&#34; : &#34;none&#34; }
                                }
            eye_fov = 500
            eye_range = 150

            for i in range(nb_balls):
                            self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                                                        border_width=5,
                                                        fill_color=RGBAColor(randomize=True),
                                                        position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                                                        radius=random.randint(5, 50),
                                                        acceleration=Vect2D(0,0),
                                                        speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                                                        max_speed= 100,
                                                        max_steering_force=5,
                                                        steering_force=Vect2D(0,0),
                                                        environment=self
                                                        ))

            for sprite in self.__sprites:
                sprite.brain.behavior_patterns = behavior_patterns
                sprite.eye.fov = eye_fov
                sprite.eye.range = eye_range

        case &#34;Rise of Sentience&#34;:
            nb_sentients = 10
            nb_dumbs = 10
            for i in range(nb_sentients):
                self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                        border_width=5,
                        radius=10,
                        fill_color=RGBAColor(randomize=True),
                        position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                        acceleration=Vect2D(0,0),
                        speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                        max_speed= 100,
                        max_steering_force=5,
                        steering_force=Vect2D(0,0),
                        environment=self
                        ))

            for i in range(nb_dumbs):
                self.__sprites.append(DynamicCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                    speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                    border_color=RGBAColor(randomize=True),
                                                    border_width=5,
                                                    radius=25,
                                                    fill_color= RGBAColor(33,33,33,255),
                                                    acceleration=Vect2D(0,0),
                                                    max_speed= 100,
                                                    max_steering_force=5,
                                                    steering_force=Vect2D(0,0),
                                                    steering_behaviors=[Wander(), BorderRepulsion(sim_dim=self.__size)]))


        case &#39;Predator Chasing Prey&#39;: # Default
            nb_obstacles = 5
            nb_predators = 2
            nb_preys = 10
            for _ in range(nb_predators):
                self.__sprites.append(PredatorCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                    speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                    border_color=RGBAColor(randomize=True),
                                                    border_width=5,
                                                    acceleration=Vect2D(0,0),
                                                    max_speed= 100,
                                                    max_steering_force=5,
                                                    steering_force=Vect2D(0,0),
                                                    environment=self,
                                                    fill_color=RGBAColor(255,0,0,255)
                                                   ))
            for _ in range(nb_preys):
                self.__sprites.append(PreyCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                    speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                    border_color=RGBAColor(randomize=True),
                                                    border_width=5,
                                                    acceleration=Vect2D(0,0),
                                                    max_speed= 100,
                                                    max_steering_force=5,
                                                    steering_force=Vect2D(0,0),
                                                    environment=self,
                                                    fill_color=RGBAColor(0,255,0,255)
                                                   ))
            for _ in range(nb_obstacles):
                self.__sprites.append(Circle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height)))))
        
        case &#39;Avoid Obstacles&#39;:
            nb_obstacles = 20
            nb_sentient_circles = 10
                    
            for _ in range(nb_obstacles):
                self.__sprites.append(Circle(   position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                radius=25))

            for _ in range(nb_sentient_circles):
                self.__sprites.append(SentientCircle(border_color=RGBAColor(randomize=True),
                border_width=5,
                radius=10,
                fill_color=RGBAColor(randomize=True),
                position=Vect2D(random.randrange(0,1000),random.randrange(0,500)),
                acceleration=Vect2D(0,0),
                speed=Vect2D(random.randrange(-50,50), random.randrange(-50,50)),
                max_speed= 100,
                max_steering_force=5,
                steering_force=Vect2D(0,0),
                environment=self
                ))


        case &#39;Red chasing Green&#39;: # Default
            nb_balls = 6
            for i in range(nb_balls):
                self.__sprites.append(DynamicCircle(position=Vect2D(random.randrange(0, int(self.width)),random.randrange(0, int(self.height))),
                                                    speed=Vect2D(random.randrange(-50,50),random.randrange(-50,50)),
                                                    border_color=RGBAColor(randomize=True),
                                                    border_width=5,
                                                    acceleration=Vect2D(0,0),
                                                    max_speed= 100,
                                                    max_steering_force=5,
                                                    steering_force=Vect2D(0,0),
                                                    steering_behaviors=[Wander(), BorderRepulsion(sim_dim=self.__size)] if i%2 == 0 else [Pursuit([self.sprites[i-1]]), BorderRepulsion(sim_dim=self.__size)]))

            for i, sprite in enumerate(self.__sprites):
                sprite.fill_color = RGBAColor(128, 0, 0, 255) if type(sprite.steering_behaviors[0]) is Pursuit else RGBAColor(0, 128, 0, 255)
                sprite.radius = 60 if type(sprite.steering_behaviors[0]) is Pursuit else 30
                if i%2 == 0 and i != len(self.__sprites) - 1:
                    self.__sprites[i].steering_behaviors.append(Evade([self.__sprites[i+1]]))</code></pre>
</details>
</dd>
<dt id="boids.Simulation.mouse_entered"><code class="name flex">
<span>def <span class="ident">mouse_entered</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Gère l'entrée de la souris dans la fenêtre</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouse_entered(self, event):
    &#34;&#34;&#34;Gère l&#39;entrée de la souris dans la fenêtre&#34;&#34;&#34;
    self.__mouse_pos.set(event.x, event.y)</code></pre>
</details>
</dd>
<dt id="boids.Simulation.mouse_left"><code class="name flex">
<span>def <span class="ident">mouse_left</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Gère la sortie de la souris de la fenêtre</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouse_left(self, event):
    &#34;&#34;&#34;Gère la sortie de la souris de la fenêtre&#34;&#34;&#34;
    self.__mouse_pos.set(-1, -1)
    
    for sprite in self.__sprites:
        sprite.steering_force = Vect2D(0,0)</code></pre>
</details>
</dd>
<dt id="boids.Simulation.move_mouse"><code class="name flex">
<span>def <span class="ident">move_mouse</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Met à jour la position de la souris</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_mouse(self, event):
    &#34;&#34;&#34;Met à jour la position de la souris&#34;&#34;&#34;
    self.__mouse_pos.set(event.x, event.y)</code></pre>
</details>
</dd>
<dt id="boids.Simulation.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, key: str = 'Red chasing Green')</span>
</code></dt>
<dd>
<div class="desc"><p>Remet la simulation à zéro</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, key:str=&#34;Red chasing Green&#34;):
    &#34;&#34;&#34;Remet la simulation à zéro&#34;&#34;&#34;
    self.__is_running = True
    self.__sprites = []
    self.initialize_scenario(key)</code></pre>
</details>
</dd>
<dt id="boids.Simulation.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Fait bouger les Entities, est appelée par la fonction update() de la classe App</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tick(self, time):
    &#34;&#34;&#34;Fait bouger les Entities, est appelée par la fonction update() de la classe App&#34;&#34;&#34;
    if self.__sprites:
        for sprite in self.__sprites:
            sprite.tick(time)</code></pre>
</details>
</dd>
<dt id="boids.Simulation.toggle_running"><code class="name flex">
<span>def <span class="ident">toggle_running</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Met en pause ou en reprend la simulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_running(self, event):
    &#34;&#34;&#34;Met en pause ou en reprend la simulation&#34;&#34;&#34;
    self.__is_running = not self.__is_running</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.StartStopPanel"><code class="flex name class">
<span>class <span class="ident">StartStopPanel</span></span>
<span>(</span><span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Ttk Labelframe widget is a container used to group other widgets
together. It has an optional label, which may be a plain text string
or another widget.</p>
<p>Construct a Ttk Labelframe with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS
labelanchor, text, underline, padding, labelwidget, width,
height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StartStopPanel(ttk.LabelFrame):
    def __init__(self, text): 
        ttk.LabelFrame.__init__(self, root=None, text=text)
        self.__start_stop_button = ttk.Button(self, text=&#34;Stop&#34;, width = 40)
        self.__next_button = ttk.Button(self, text=&#34;Next Step&#34;, state=&#34;disabled&#34;, width = 40)
        self.__reset_button = ttk.Button(self, text=&#34;Reset&#34;, width = 40)
        self.__start_stop_button.grid(row=0, column=0)
        self.__next_button.grid(row=1, column=0)
        self.__reset_button.grid(row=2, column=0)
        
    @property
    def start_stop_button(self):
        return self.__start_stop_button
    
    @property
    def next_button(self):
        return self.__next_button
    
    @property
    def reset_button(self):
        return self.__reset_button</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Labelframe</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.StartStopPanel.next_button"><code class="name">var <span class="ident">next_button</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def next_button(self):
    return self.__next_button</code></pre>
</details>
</dd>
<dt id="boids.StartStopPanel.reset_button"><code class="name">var <span class="ident">reset_button</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reset_button(self):
    return self.__reset_button</code></pre>
</details>
</dd>
<dt id="boids.StartStopPanel.start_stop_button"><code class="name">var <span class="ident">start_stop_button</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start_stop_button(self):
    return self.__start_stop_button</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.SteeringBehavior"><code class="flex name class">
<span>class <span class="ident">SteeringBehavior</span></span>
<span>(</span><span>target_entities: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'] = None, attraction_repulsion_force: vect2d.Vect2D = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a steering behavior object that can be used to steer an entity.
It is an abstract class. It contains a abstract method called behave() that is used to steer an entity (dynamicCircles).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SteeringBehavior():
    &#34;&#34;&#34;
    This class is used to create a steering behavior object that can be used to steer an entity.
    It is an abstract class. It contains a abstract method called behave() that is used to steer an entity (dynamicCircles).
    &#34;&#34;&#34;
    def __init__(self, target_entities:type[&#39;Entity&#39;]=None, attraction_repulsion_force:Vect2D=None):
        self.__attraction_repulsion_force = attraction_repulsion_force
        self.__resulting_direction = Vect2D(0, 0)
        self.__target_entities = [] if target_entities is None else target_entities

    @abstractmethod    
    def behave(self, origin_entity:type[&#39;Entity&#39;]):
        pass  
    
    @property
    def attraction_repulsion_force(self):
        return self.__attraction_repulsion_force
    
    @property
    def resulting_direction(self):
        return self.__resulting_direction
    
    @resulting_direction.setter
    def resulting_direction(self, resulting_direction):
        self.__resulting_direction = resulting_direction

    @property
    def target_entities(self):
        return self.__target_entities
    
    @target_entities.setter
    def target_entities(self, target_entities):
        self.__target_entities = target_entities
        
    def add_target_entity(self, target_entity):
        self.__target_entities.append(target_entity)
        
    def remove_target_entity(self, target_entity):
        self.__target_entities.remove(target_entity)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.Alignment" href="#boids.Alignment">Alignment</a></li>
<li><a title="boids.BorderRepulsion" href="#boids.BorderRepulsion">BorderRepulsion</a></li>
<li><a title="boids.Cohesion" href="#boids.Cohesion">Cohesion</a></li>
<li><a title="boids.EntityRepulsion" href="#boids.EntityRepulsion">EntityRepulsion</a></li>
<li><a title="boids.FollowBiggestBoidSeen" href="#boids.FollowBiggestBoidSeen">FollowBiggestBoidSeen</a></li>
<li><a title="boids.PseudoWander" href="#boids.PseudoWander">PseudoWander</a></li>
<li><a title="boids.Pursuit" href="#boids.Pursuit">Pursuit</a></li>
<li><a title="boids.Seek" href="#boids.Seek">Seek</a></li>
<li><a title="boids.Separation" href="#boids.Separation">Separation</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.SteeringBehavior.attraction_repulsion_force"><code class="name">var <span class="ident">attraction_repulsion_force</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def attraction_repulsion_force(self):
    return self.__attraction_repulsion_force</code></pre>
</details>
</dd>
<dt id="boids.SteeringBehavior.resulting_direction"><code class="name">var <span class="ident">resulting_direction</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resulting_direction(self):
    return self.__resulting_direction</code></pre>
</details>
</dd>
<dt id="boids.SteeringBehavior.target_entities"><code class="name">var <span class="ident">target_entities</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def target_entities(self):
    return self.__target_entities</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.SteeringBehavior.add_target_entity"><code class="name flex">
<span>def <span class="ident">add_target_entity</span></span>(<span>self, target_entity)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_target_entity(self, target_entity):
    self.__target_entities.append(target_entity)</code></pre>
</details>
</dd>
<dt id="boids.SteeringBehavior.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>'])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod    
def behave(self, origin_entity:type[&#39;Entity&#39;]):
    pass  </code></pre>
</details>
</dd>
<dt id="boids.SteeringBehavior.remove_target_entity"><code class="name flex">
<span>def <span class="ident">remove_target_entity</span></span>(<span>self, target_entity)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_target_entity(self, target_entity):
    self.__target_entities.remove(target_entity)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Updatable"><code class="flex name class">
<span>class <span class="ident">Updatable</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Updatable():
    def __init__(self):
        pass

    @abstractmethod
    def tick(self):
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="boids.App" href="#boids.App">App</a></li>
<li><a title="boids.Entity" href="#boids.Entity">Entity</a></li>
<li><a title="boids.Simulation" href="#boids.Simulation">Simulation</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="boids.Updatable.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def tick(self):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Utils"><code class="flex name class">
<span>class <span class="ident">Utils</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class contains two static methods. One is used to clamp a value between a min and max value and
one
is used to reads a file and returns a list of strings to populate the scenario combobox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Utils():
    &#34;&#34;&#34;
    This class contains two static methods. One is used to clamp a value between a min and max value and
    one  is used to reads a file and returns a list of strings to populate the scenario combobox.
    &#34;&#34;&#34;          
    def clamp_max(value, max):
        return min(value, max)
    
    def readfile(filename:str)-&gt;list:
        data = []
        with open(filename, &#39;r&#39;) as file:
            for line in file:
                data.append(line)
        return data</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="boids.Utils.clamp_max"><code class="name flex">
<span>def <span class="ident">clamp_max</span></span>(<span>value, max)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clamp_max(value, max):
    return min(value, max)</code></pre>
</details>
</dd>
<dt id="boids.Utils.readfile"><code class="name flex">
<span>def <span class="ident">readfile</span></span>(<span>filename: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readfile(filename:str)-&gt;list:
    data = []
    with open(filename, &#39;r&#39;) as file:
        for line in file:
            data.append(line)
    return data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.ViewWindow"><code class="flex name class">
<span>class <span class="ident">ViewWindow</span></span>
<span>(</span><span>border_color=None, border_width=None, fill_color=None, position=None, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Ttk Label widget displays a textual label and/or image.</p>
<p>Construct a Ttk Label with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, compound, cursor, image, style, takefocus, text,
textvariable, underline, width
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS</p>
<pre><code>anchor, background, font, foreground, justify, padding,
relief, text, wraplength
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ViewWindow(ttk.Label, Drawable):
    def __init__(self, border_color=None, border_width=None, fill_color=None, position=None, size=None):
        ttk.Label.__init__(self, root=None, text=None, width=size.x)
        Drawable.__init__(self, border_color, border_width, fill_color, position, size)
        self.__background = Image.open(&#34;tropicalforest.jpg&#34;)
        self.sizex = size.x
        self.sizey = size.y
        self.__resized = self.__background.resize((int(size.x), int(size.y)))
        self.__image_draw = ImageDraw.Draw(self.__resized)
        self.__image_tk = ImageTk.PhotoImage(self.__resized)
        self.__image_label = ttk.Label(self, image=self.__image_tk)
        self.__image_label.grid(row=0, column=0, sticky=&#39;ns&#39;)
        self.__image_label.columnconfigure(0, minsize=600, weight=1)
        self.__speed_is_drawn = False
        self.__steering_force_is_drawn = False
        self.__circle_is_drawn = True
        self.__fov_is_drawn = False
        self.__crazy_mode = False
        self.__jungle_background = False

    def update_view(self, simulation):
            if self.__crazy_mode:
                i = self.__resized
                draw = ImageDraw.Draw(i)
            else:
                if self.__jungle_background:
                    self.__newbackground = Image.open(&#34;tropicalforest.jpg&#34;)
                else :
                    self.__newbackground = Image.new(&#39;RGBA&#39;, (int(self.sizex), int(self.sizey)), (0, 0, 0))
                i = self.__newbackground.resize((int(self.sizex), int(self.sizey)))
                draw = ImageDraw.Draw(i)
            
            if self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)                     
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
                        sprite.draw_circle_steering_force(draw)
                   
            elif self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
                        sprite.draw_circle_steering_force(draw)
            elif self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)   
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
                        sprite.draw_circle_steering_force(draw)                 
            elif self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
                        sprite.draw_circle_steering_force(draw)
            elif self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)                         
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
            elif self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
            elif self.__speed_is_drawn and not self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
            elif self.__speed_is_drawn and not self.__steering_force_is_drawn and not self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_speed(draw)
            elif not self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_steering_force(draw)
            elif not self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    sprite.draw(draw)
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_steering_force(draw)
            elif not self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw) 
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):                   
                        sprite.draw_circle_steering_force(draw)
            elif not self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#34;draw_circle_speed&#34;):
                        sprite.draw_circle_steering_force(draw)
            elif not self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)
                    sprite.draw(draw)
            elif not self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    sprite.draw(draw)
            elif not self.__speed_is_drawn and not self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
                for sprite in simulation.sprites:
                    if hasattr(sprite, &#39;draw_fov&#39;):
                        sprite.draw_fov(draw)   
                        
            if simulation.selected_entity:
                simulation.selected_entity.draw(draw)
                if hasattr(simulation.selected_entity, &#34;draw_circle_speed&#34;):
                    simulation.selected_entity.draw_circle_speed(draw)                
                    simulation.selected_entity.draw_circle_steering_force(draw)    
                if hasattr(simulation.selected_entity, &#39;draw_fov&#39;):
                    simulation.selected_entity.draw_fov(draw)
        
            self.__image_tk = ImageTk.PhotoImage(i)
            self.__image_label[&#34;image&#34;] = self.__image_tk 
            
    def toggle_draw_fov(self, event):
        self.__fov_is_drawn = not self.__fov_is_drawn
    
    def toggle_draw_circle(self, event):
        self.__circle_is_drawn = not self.__circle_is_drawn
            
    def toggle_draw_steering_force(self, event):
        self.__steering_force_is_drawn = not self.__steering_force_is_drawn

    def toggle_draw_speed(self, event):
        self.__speed_is_drawn = not self.__speed_is_drawn

    def toggle_crazy_mode(self, event):
        self.__crazy_mode = not self.__crazy_mode

    def toggle_jungle_background(self, event):
        self.__jungle_background = not self.__jungle_background

    @property
    def canvas(self):
        return self.__canvas

    @property
    def image_draw(self):
        return self.__image_draw     

    @property
    def image_label(self):
        return self.__image_label    

    @canvas.setter
    def canvas(self, canvas):
        self.__canvas = canvas</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Label</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
<li><a title="boids.Drawable" href="#boids.Drawable">Drawable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.ViewWindow.canvas"><code class="name">var <span class="ident">canvas</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def canvas(self):
    return self.__canvas</code></pre>
</details>
</dd>
<dt id="boids.ViewWindow.image_draw"><code class="name">var <span class="ident">image_draw</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def image_draw(self):
    return self.__image_draw     </code></pre>
</details>
</dd>
<dt id="boids.ViewWindow.image_label"><code class="name">var <span class="ident">image_label</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def image_label(self):
    return self.__image_label    </code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.ViewWindow.toggle_crazy_mode"><code class="name flex">
<span>def <span class="ident">toggle_crazy_mode</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_crazy_mode(self, event):
    self.__crazy_mode = not self.__crazy_mode</code></pre>
</details>
</dd>
<dt id="boids.ViewWindow.toggle_draw_circle"><code class="name flex">
<span>def <span class="ident">toggle_draw_circle</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_draw_circle(self, event):
    self.__circle_is_drawn = not self.__circle_is_drawn</code></pre>
</details>
</dd>
<dt id="boids.ViewWindow.toggle_draw_fov"><code class="name flex">
<span>def <span class="ident">toggle_draw_fov</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_draw_fov(self, event):
    self.__fov_is_drawn = not self.__fov_is_drawn</code></pre>
</details>
</dd>
<dt id="boids.ViewWindow.toggle_draw_speed"><code class="name flex">
<span>def <span class="ident">toggle_draw_speed</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_draw_speed(self, event):
    self.__speed_is_drawn = not self.__speed_is_drawn</code></pre>
</details>
</dd>
<dt id="boids.ViewWindow.toggle_draw_steering_force"><code class="name flex">
<span>def <span class="ident">toggle_draw_steering_force</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_draw_steering_force(self, event):
    self.__steering_force_is_drawn = not self.__steering_force_is_drawn</code></pre>
</details>
</dd>
<dt id="boids.ViewWindow.toggle_jungle_background"><code class="name flex">
<span>def <span class="ident">toggle_jungle_background</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_jungle_background(self, event):
    self.__jungle_background = not self.__jungle_background</code></pre>
</details>
</dd>
<dt id="boids.ViewWindow.update_view"><code class="name flex">
<span>def <span class="ident">update_view</span></span>(<span>self, simulation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_view(self, simulation):
        if self.__crazy_mode:
            i = self.__resized
            draw = ImageDraw.Draw(i)
        else:
            if self.__jungle_background:
                self.__newbackground = Image.open(&#34;tropicalforest.jpg&#34;)
            else :
                self.__newbackground = Image.new(&#39;RGBA&#39;, (int(self.sizex), int(self.sizey)), (0, 0, 0))
            i = self.__newbackground.resize((int(self.sizex), int(self.sizey)))
            draw = ImageDraw.Draw(i)
        
        if self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
            for sprite in simulation.sprites:
                if hasattr(sprite, &#39;draw_fov&#39;):
                    sprite.draw_fov(draw)                     
                sprite.draw(draw)
                if hasattr(sprite, &#34;draw_circle_speed&#34;):
                    sprite.draw_circle_speed(draw)
                    sprite.draw_circle_steering_force(draw)
               
        elif self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
            for sprite in simulation.sprites:
                sprite.draw(draw)
                if hasattr(sprite, &#34;draw_circle_speed&#34;):
                    sprite.draw_circle_speed(draw)
                    sprite.draw_circle_steering_force(draw)
        elif self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
            for sprite in simulation.sprites:
                if hasattr(sprite, &#39;draw_fov&#39;):
                    sprite.draw_fov(draw)   
                if hasattr(sprite, &#34;draw_circle_speed&#34;):
                    sprite.draw_circle_speed(draw)
                    sprite.draw_circle_steering_force(draw)                 
        elif self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and not self.__fov_is_drawn:
            for sprite in simulation.sprites:
                if hasattr(sprite, &#34;draw_circle_speed&#34;):
                    sprite.draw_circle_speed(draw)
                    sprite.draw_circle_steering_force(draw)
        elif self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
            for sprite in simulation.sprites:
                if hasattr(sprite, &#39;draw_fov&#39;):
                    sprite.draw_fov(draw)                         
                sprite.draw(draw)
                if hasattr(sprite, &#34;draw_circle_speed&#34;):
                    sprite.draw_circle_speed(draw)
        elif self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
            for sprite in simulation.sprites:
                sprite.draw(draw)
                if hasattr(sprite, &#34;draw_circle_speed&#34;):
                    sprite.draw_circle_speed(draw)
        elif self.__speed_is_drawn and not self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
            for sprite in simulation.sprites:
                if hasattr(sprite, &#39;draw_fov&#39;):
                    sprite.draw_fov(draw)
                if hasattr(sprite, &#34;draw_circle_speed&#34;):
                    sprite.draw_circle_speed(draw)
        elif self.__speed_is_drawn and not self.__steering_force_is_drawn and not self.__circle_is_drawn and not self.__fov_is_drawn:
            for sprite in simulation.sprites:
                if hasattr(sprite, &#34;draw_circle_speed&#34;):
                    sprite.draw_circle_speed(draw)
        elif not self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
            for sprite in simulation.sprites:
                if hasattr(sprite, &#39;draw_fov&#39;):
                    sprite.draw_fov(draw)
                sprite.draw(draw)
                if hasattr(sprite, &#34;draw_circle_speed&#34;):
                    sprite.draw_circle_steering_force(draw)
        elif not self.__speed_is_drawn and self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
            for sprite in simulation.sprites:
                sprite.draw(draw)
                if hasattr(sprite, &#34;draw_circle_speed&#34;):
                    sprite.draw_circle_steering_force(draw)
        elif not self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
            for sprite in simulation.sprites:
                if hasattr(sprite, &#39;draw_fov&#39;):
                    sprite.draw_fov(draw) 
                if hasattr(sprite, &#34;draw_circle_speed&#34;):                   
                    sprite.draw_circle_steering_force(draw)
        elif not self.__speed_is_drawn and self.__steering_force_is_drawn and not self.__circle_is_drawn and not self.__fov_is_drawn:
            for sprite in simulation.sprites:
                if hasattr(sprite, &#34;draw_circle_speed&#34;):
                    sprite.draw_circle_steering_force(draw)
        elif not self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and self.__fov_is_drawn:
            for sprite in simulation.sprites:
                if hasattr(sprite, &#39;draw_fov&#39;):
                    sprite.draw_fov(draw)
                sprite.draw(draw)
        elif not self.__speed_is_drawn and not self.__steering_force_is_drawn and self.__circle_is_drawn and not self.__fov_is_drawn:
            for sprite in simulation.sprites:
                sprite.draw(draw)
        elif not self.__speed_is_drawn and not self.__steering_force_is_drawn and not self.__circle_is_drawn and self.__fov_is_drawn:
            for sprite in simulation.sprites:
                if hasattr(sprite, &#39;draw_fov&#39;):
                    sprite.draw_fov(draw)   
                    
        if simulation.selected_entity:
            simulation.selected_entity.draw(draw)
            if hasattr(simulation.selected_entity, &#34;draw_circle_speed&#34;):
                simulation.selected_entity.draw_circle_speed(draw)                
                simulation.selected_entity.draw_circle_steering_force(draw)    
            if hasattr(simulation.selected_entity, &#39;draw_fov&#39;):
                simulation.selected_entity.draw_fov(draw)
    
        self.__image_tk = ImageTk.PhotoImage(i)
        self.__image_label[&#34;image&#34;] = self.__image_tk </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.VisualParamPanel"><code class="flex name class">
<span>class <span class="ident">VisualParamPanel</span></span>
<span>(</span><span>title)</span>
</code></dt>
<dd>
<div class="desc"><p>Ttk Labelframe widget is a container used to group other widgets
together. It has an optional label, which may be a plain text string
or another widget.</p>
<p>Construct a Ttk Labelframe with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS
labelanchor, text, underline, padding, labelwidget, width,
height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VisualParamPanel(ttk.LabelFrame):
    def __init__(self, title):
        ttk.LabelFrame.__init__(self, root=None, text=title)
        self.__width_var = 28
        self.__speed_var = tk.IntVar()
        self.__speed_checkbutton = ttk.Checkbutton(self, text=&#34;Show Speed&#34;, variable=self.__speed_var, onvalue=1, offvalue=0, width=self.__width_var)
        self.__speed_checkbutton.pack(padx=(50, 0))
        self.__steering_force_var = tk.IntVar()
        self.__steering_force_checkbutton = ttk.Checkbutton(self, text=&#34;Show Steers&#34;, variable=self.__steering_force_var, onvalue=1, offvalue=0, width=self.__width_var)
        self.__steering_force_checkbutton.pack(padx=(50, 0))
        self.__show_circle_var = tk.IntVar()
        self.__show_circle_checkbutton = ttk.Checkbutton(self, text=&#34;Show Circles&#34;, variable=self.__show_circle_var, onvalue=0, offvalue=1, width=self.__width_var)  
        self.__show_circle_checkbutton.pack(padx=(50, 0))
        self.__show_fov_var = tk.IntVar()
        self.__show_fov_checkbutton = ttk.Checkbutton(self, text=&#34;Show F-o-V&#34;, variable=self.__show_fov_var, onvalue=1, offvalue=0, width=self.__width_var)
        self.__show_fov_checkbutton.pack(padx=(50, 0))
        self.__jungle_background_var = tk.IntVar()
        self.__jungle_background_checkbutton = ttk.Checkbutton(self, text=&#34;Jungle background&#34;, variable=self.__jungle_background_var, onvalue=1, offvalue=0, width=self.__width_var)
        self.__jungle_background_checkbutton.pack(padx=(50, 0))
        self.__crazy_mode_var = tk.IntVar()
        self.__crazy_mode_checkbutton = ttk.Checkbutton(self, text=&#34;Crazy Mode&#34;, variable=self.__crazy_mode_var, onvalue=1, offvalue=0, width=self.__width_var)
        self.__crazy_mode_checkbutton.pack(padx=(50, 0))

    @property
    def show_fov_checkbutton(self):
        return self.__show_fov_checkbutton

    @property
    def show_circle_checkbutton(self):
        return self.__show_circle_checkbutton

    @property
    def steering_force_checkbutton(self):
        return self.__steering_force_checkbutton
    
    @property
    def speed_checkbutton(self):
        return self.__speed_checkbutton

    @property
    def crazy_mode_checkbutton(self):
        return self.__crazy_mode_checkbutton

    @property
    def jungle_background_checkbutton(self):
        return self.__jungle_background_checkbutton</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Labelframe</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.VisualParamPanel.crazy_mode_checkbutton"><code class="name">var <span class="ident">crazy_mode_checkbutton</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def crazy_mode_checkbutton(self):
    return self.__crazy_mode_checkbutton</code></pre>
</details>
</dd>
<dt id="boids.VisualParamPanel.jungle_background_checkbutton"><code class="name">var <span class="ident">jungle_background_checkbutton</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def jungle_background_checkbutton(self):
    return self.__jungle_background_checkbutton</code></pre>
</details>
</dd>
<dt id="boids.VisualParamPanel.show_circle_checkbutton"><code class="name">var <span class="ident">show_circle_checkbutton</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def show_circle_checkbutton(self):
    return self.__show_circle_checkbutton</code></pre>
</details>
</dd>
<dt id="boids.VisualParamPanel.show_fov_checkbutton"><code class="name">var <span class="ident">show_fov_checkbutton</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def show_fov_checkbutton(self):
    return self.__show_fov_checkbutton</code></pre>
</details>
</dd>
<dt id="boids.VisualParamPanel.speed_checkbutton"><code class="name">var <span class="ident">speed_checkbutton</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def speed_checkbutton(self):
    return self.__speed_checkbutton</code></pre>
</details>
</dd>
<dt id="boids.VisualParamPanel.steering_force_checkbutton"><code class="name">var <span class="ident">steering_force_checkbutton</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def steering_force_checkbutton(self):
    return self.__steering_force_checkbutton</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boids.Wander"><code class="flex name class">
<span>class <span class="ident">Wander</span></span>
<span>(</span><span>radius: float = 50, circle_distance: float = 100, is_in: bool = True, attraction_repulsion_force: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a seek steering behavior object.
It is a child class of the SteeringBehavior class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Wander(Seek):
    def __init__(self, radius:float=50, circle_distance:float=100, is_in:bool=True, attraction_repulsion_force:int=1):
        super().__init__(attraction_repulsion_force=attraction_repulsion_force)
        &#39;&#39;&#39;radius will increase the turning distance
        circle_distance will increase the distance before turning
        &#39;&#39;&#39;        
        self.__circle_distance = circle_distance
        self.__radius = radius
        self.__is_in = is_in
        self.__circle_center = None
   
    def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
        &#39;&#39;&#39;Returns a vector that points in a random direction

        Args:
            origin_entity (Entity): the sprite that is wandering

        Returns:
            Vect2D: displacement vector
        &#39;&#39;&#39;        
        circle_center_sprite_relative = origin_entity.speed.normalized * self.__circle_distance
        self.__circle_center = origin_entity.position + circle_center_sprite_relative
        displacement = Vect2D.from_random_normalized()
        
        if self.__is_in:
            displacement *= random.random() * self.__radius
        else:
            displacement *= self.__radius
        
        self.target_entities = []
        self.target_entities.append(self.__circle_center + displacement)
        
        return super().behave(origin_entity)
        
    def draw(self, draw):
        for target_entity in self.target_entities:
            draw.ellipse([self.__circle_center.x - self.radius, self.__circle_center.y - self.radius, self.__circle_center.x + self.radius, self.__circle_center.y  + self.radius], outline=&#34;blue&#34;)
            draw.ellipse([target_entity.x - 5, target_entity.y - 5, target_entity.x + 5, target_entity.y + 5], fill=&#34;cyan&#34;)
        
    @property
    def circle_distance(self):
        return self.__circle_distance
    
    @property
    def radius(self):
        return self.__radius</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="boids.Seek" href="#boids.Seek">Seek</a></li>
<li><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="boids.Wander.circle_distance"><code class="name">var <span class="ident">circle_distance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def circle_distance(self):
    return self.__circle_distance</code></pre>
</details>
</dd>
<dt id="boids.Wander.radius"><code class="name">var <span class="ident">radius</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def radius(self):
    return self.__radius</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="boids.Wander.behave"><code class="name flex">
<span>def <span class="ident">behave</span></span>(<span>self, origin_entity: type['<a title="boids.Entity" href="#boids.Entity">Entity</a>']) ‑> vect2d.Vect2D</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a vector that points in a random direction</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>origin_entity</code></strong> :&ensp;<code><a title="boids.Entity" href="#boids.Entity">Entity</a></code></dt>
<dd>the sprite that is wandering</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Vect2D</code></dt>
<dd>displacement vector</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def behave(self, origin_entity: type[&#39;Entity&#39;]) -&gt; Vect2D:
    &#39;&#39;&#39;Returns a vector that points in a random direction

    Args:
        origin_entity (Entity): the sprite that is wandering

    Returns:
        Vect2D: displacement vector
    &#39;&#39;&#39;        
    circle_center_sprite_relative = origin_entity.speed.normalized * self.__circle_distance
    self.__circle_center = origin_entity.position + circle_center_sprite_relative
    displacement = Vect2D.from_random_normalized()
    
    if self.__is_in:
        displacement *= random.random() * self.__radius
    else:
        displacement *= self.__radius
    
    self.target_entities = []
    self.target_entities.append(self.__circle_center + displacement)
    
    return super().behave(origin_entity)</code></pre>
</details>
</dd>
<dt id="boids.Wander.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, draw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, draw):
    for target_entity in self.target_entities:
        draw.ellipse([self.__circle_center.x - self.radius, self.__circle_center.y - self.radius, self.__circle_center.x + self.radius, self.__circle_center.y  + self.radius], outline=&#34;blue&#34;)
        draw.ellipse([target_entity.x - 5, target_entity.y - 5, target_entity.x + 5, target_entity.y + 5], fill=&#34;cyan&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="boids.main" href="#boids.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="boids.Alignment" href="#boids.Alignment">Alignment</a></code></h4>
<ul class="">
<li><code><a title="boids.Alignment.behave" href="#boids.Alignment.behave">behave</a></code></li>
<li><code><a title="boids.Alignment.draw" href="#boids.Alignment.draw">draw</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.App" href="#boids.App">App</a></code></h4>
<ul class="">
<li><code><a title="boids.App.height" href="#boids.App.height">height</a></code></li>
<li><code><a title="boids.App.mouse_clicked_on_image" href="#boids.App.mouse_clicked_on_image">mouse_clicked_on_image</a></code></li>
<li><code><a title="boids.App.param_changed" href="#boids.App.param_changed">param_changed</a></code></li>
<li><code><a title="boids.App.reset_simulation" href="#boids.App.reset_simulation">reset_simulation</a></code></li>
<li><code><a title="boids.App.size" href="#boids.App.size">size</a></code></li>
<li><code><a title="boids.App.tick" href="#boids.App.tick">tick</a></code></li>
<li><code><a title="boids.App.tick_simulation" href="#boids.App.tick_simulation">tick_simulation</a></code></li>
<li><code><a title="boids.App.toggle_simulation" href="#boids.App.toggle_simulation">toggle_simulation</a></code></li>
<li><code><a title="boids.App.update_info_panel" href="#boids.App.update_info_panel">update_info_panel</a></code></li>
<li><code><a title="boids.App.width" href="#boids.App.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.BorderRepulsion" href="#boids.BorderRepulsion">BorderRepulsion</a></code></h4>
<ul class="">
<li><code><a title="boids.BorderRepulsion.behave" href="#boids.BorderRepulsion.behave">behave</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Brain" href="#boids.Brain">Brain</a></code></h4>
<ul class="">
<li><code><a title="boids.Brain.active_behaviors" href="#boids.Brain.active_behaviors">active_behaviors</a></code></li>
<li><code><a title="boids.Brain.behave" href="#boids.Brain.behave">behave</a></code></li>
<li><code><a title="boids.Brain.behavior_patterns" href="#boids.Brain.behavior_patterns">behavior_patterns</a></code></li>
<li><code><a title="boids.Brain.draw_line_to_seen_entities" href="#boids.Brain.draw_line_to_seen_entities">draw_line_to_seen_entities</a></code></li>
<li><code><a title="boids.Brain.process" href="#boids.Brain.process">process</a></code></li>
<li><code><a title="boids.Brain.seen_entities" href="#boids.Brain.seen_entities">seen_entities</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Circle" href="#boids.Circle">Circle</a></code></h4>
<ul class="">
<li><code><a title="boids.Circle.draw" href="#boids.Circle.draw">draw</a></code></li>
<li><code><a title="boids.Circle.radius" href="#boids.Circle.radius">radius</a></code></li>
<li><code><a title="boids.Circle.tick" href="#boids.Circle.tick">tick</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Cohesion" href="#boids.Cohesion">Cohesion</a></code></h4>
<ul class="">
<li><code><a title="boids.Cohesion.behave" href="#boids.Cohesion.behave">behave</a></code></li>
<li><code><a title="boids.Cohesion.draw" href="#boids.Cohesion.draw">draw</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.ControlBar" href="#boids.ControlBar">ControlBar</a></code></h4>
<ul class="">
<li><code><a title="boids.ControlBar.control_panel" href="#boids.ControlBar.control_panel">control_panel</a></code></li>
<li><code><a title="boids.ControlBar.info_panel" href="#boids.ControlBar.info_panel">info_panel</a></code></li>
<li><code><a title="boids.ControlBar.param_panel" href="#boids.ControlBar.param_panel">param_panel</a></code></li>
<li><code><a title="boids.ControlBar.visual_param_panel" href="#boids.ControlBar.visual_param_panel">visual_param_panel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Drawable" href="#boids.Drawable">Drawable</a></code></h4>
<ul class="two-column">
<li><code><a title="boids.Drawable.border_color" href="#boids.Drawable.border_color">border_color</a></code></li>
<li><code><a title="boids.Drawable.border_width" href="#boids.Drawable.border_width">border_width</a></code></li>
<li><code><a title="boids.Drawable.draw" href="#boids.Drawable.draw">draw</a></code></li>
<li><code><a title="boids.Drawable.fill_color" href="#boids.Drawable.fill_color">fill_color</a></code></li>
<li><code><a title="boids.Drawable.height" href="#boids.Drawable.height">height</a></code></li>
<li><code><a title="boids.Drawable.pos_x" href="#boids.Drawable.pos_x">pos_x</a></code></li>
<li><code><a title="boids.Drawable.pos_y" href="#boids.Drawable.pos_y">pos_y</a></code></li>
<li><code><a title="boids.Drawable.position" href="#boids.Drawable.position">position</a></code></li>
<li><code><a title="boids.Drawable.size" href="#boids.Drawable.size">size</a></code></li>
<li><code><a title="boids.Drawable.width" href="#boids.Drawable.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.DynamicCircle" href="#boids.DynamicCircle">DynamicCircle</a></code></h4>
<ul class="">
<li><code><a title="boids.DynamicCircle.draw" href="#boids.DynamicCircle.draw">draw</a></code></li>
<li><code><a title="boids.DynamicCircle.draw_circle_speed" href="#boids.DynamicCircle.draw_circle_speed">draw_circle_speed</a></code></li>
<li><code><a title="boids.DynamicCircle.draw_circle_steering_force" href="#boids.DynamicCircle.draw_circle_steering_force">draw_circle_steering_force</a></code></li>
<li><code><a title="boids.DynamicCircle.move" href="#boids.DynamicCircle.move">move</a></code></li>
<li><code><a title="boids.DynamicCircle.tick" href="#boids.DynamicCircle.tick">tick</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Entity" href="#boids.Entity">Entity</a></code></h4>
<ul class="">
<li><code><a title="boids.Entity.draw" href="#boids.Entity.draw">draw</a></code></li>
<li><code><a title="boids.Entity.name" href="#boids.Entity.name">name</a></code></li>
<li><code><a title="boids.Entity.tick" href="#boids.Entity.tick">tick</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.EntityRepulsion" href="#boids.EntityRepulsion">EntityRepulsion</a></code></h4>
<ul class="">
<li><code><a title="boids.EntityRepulsion.behave" href="#boids.EntityRepulsion.behave">behave</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Evade" href="#boids.Evade">Evade</a></code></h4>
<ul class="">
<li><code><a title="boids.Evade.behave" href="#boids.Evade.behave">behave</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Eye" href="#boids.Eye">Eye</a></code></h4>
<ul class="two-column">
<li><code><a title="boids.Eye.draw" href="#boids.Eye.draw">draw</a></code></li>
<li><code><a title="boids.Eye.fov" href="#boids.Eye.fov">fov</a></code></li>
<li><code><a title="boids.Eye.is_in_fov" href="#boids.Eye.is_in_fov">is_in_fov</a></code></li>
<li><code><a title="boids.Eye.is_in_range" href="#boids.Eye.is_in_range">is_in_range</a></code></li>
<li><code><a title="boids.Eye.look" href="#boids.Eye.look">look</a></code></li>
<li><code><a title="boids.Eye.orientation" href="#boids.Eye.orientation">orientation</a></code></li>
<li><code><a title="boids.Eye.position" href="#boids.Eye.position">position</a></code></li>
<li><code><a title="boids.Eye.range" href="#boids.Eye.range">range</a></code></li>
<li><code><a title="boids.Eye.sees" href="#boids.Eye.sees">sees</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Flee" href="#boids.Flee">Flee</a></code></h4>
<ul class="">
<li><code><a title="boids.Flee.behave" href="#boids.Flee.behave">behave</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.FollowBiggestBoidSeen" href="#boids.FollowBiggestBoidSeen">FollowBiggestBoidSeen</a></code></h4>
<ul class="">
<li><code><a title="boids.FollowBiggestBoidSeen.behave" href="#boids.FollowBiggestBoidSeen.behave">behave</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.GUI" href="#boids.GUI">GUI</a></code></h4>
<ul class="">
<li><code><a title="boids.GUI.main_panel" href="#boids.GUI.main_panel">main_panel</a></code></li>
<li><code><a title="boids.GUI.view_window" href="#boids.GUI.view_window">view_window</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.InfoPanel" href="#boids.InfoPanel">InfoPanel</a></code></h4>
<ul class="">
<li><code><a title="boids.InfoPanel.info_entity" href="#boids.InfoPanel.info_entity">info_entity</a></code></li>
<li><code><a title="boids.InfoPanel.info_label" href="#boids.InfoPanel.info_label">info_label</a></code></li>
<li><code><a title="boids.InfoPanel.info_string" href="#boids.InfoPanel.info_string">info_string</a></code></li>
<li><code><a title="boids.InfoPanel.update" href="#boids.InfoPanel.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Movable" href="#boids.Movable">Movable</a></code></h4>
<ul class="">
<li><code><a title="boids.Movable.acceleration" href="#boids.Movable.acceleration">acceleration</a></code></li>
<li><code><a title="boids.Movable.max_speed" href="#boids.Movable.max_speed">max_speed</a></code></li>
<li><code><a title="boids.Movable.move" href="#boids.Movable.move">move</a></code></li>
<li><code><a title="boids.Movable.original_max_speed" href="#boids.Movable.original_max_speed">original_max_speed</a></code></li>
<li><code><a title="boids.Movable.speed" href="#boids.Movable.speed">speed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.ParamPanel" href="#boids.ParamPanel">ParamPanel</a></code></h4>
<ul class="">
<li><code><a title="boids.ParamPanel.combobox" href="#boids.ParamPanel.combobox">combobox</a></code></li>
<li><code><a title="boids.ParamPanel.param_selected" href="#boids.ParamPanel.param_selected">param_selected</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Piloted" href="#boids.Piloted">Piloted</a></code></h4>
<ul class="">
<li><code><a title="boids.Piloted.max_steering_force" href="#boids.Piloted.max_steering_force">max_steering_force</a></code></li>
<li><code><a title="boids.Piloted.steer" href="#boids.Piloted.steer">steer</a></code></li>
<li><code><a title="boids.Piloted.steering_behaviors" href="#boids.Piloted.steering_behaviors">steering_behaviors</a></code></li>
<li><code><a title="boids.Piloted.steering_force" href="#boids.Piloted.steering_force">steering_force</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.PredatorCircle" href="#boids.PredatorCircle">PredatorCircle</a></code></h4>
</li>
<li>
<h4><code><a title="boids.PreyCircle" href="#boids.PreyCircle">PreyCircle</a></code></h4>
</li>
<li>
<h4><code><a title="boids.PseudoWander" href="#boids.PseudoWander">PseudoWander</a></code></h4>
<ul class="">
<li><code><a title="boids.PseudoWander.behave" href="#boids.PseudoWander.behave">behave</a></code></li>
<li><code><a title="boids.PseudoWander.set_angle" href="#boids.PseudoWander.set_angle">set_angle</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Pursuit" href="#boids.Pursuit">Pursuit</a></code></h4>
<ul class="">
<li><code><a title="boids.Pursuit.behave" href="#boids.Pursuit.behave">behave</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.RGBAColor" href="#boids.RGBAColor">RGBAColor</a></code></h4>
<ul class="two-column">
<li><code><a title="boids.RGBAColor.a" href="#boids.RGBAColor.a">a</a></code></li>
<li><code><a title="boids.RGBAColor.b" href="#boids.RGBAColor.b">b</a></code></li>
<li><code><a title="boids.RGBAColor.g" href="#boids.RGBAColor.g">g</a></code></li>
<li><code><a title="boids.RGBAColor.r" href="#boids.RGBAColor.r">r</a></code></li>
<li><code><a title="boids.RGBAColor.randomize_color" href="#boids.RGBAColor.randomize_color">randomize_color</a></code></li>
<li><code><a title="boids.RGBAColor.rgba" href="#boids.RGBAColor.rgba">rgba</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Seek" href="#boids.Seek">Seek</a></code></h4>
<ul class="">
<li><code><a title="boids.Seek.behave" href="#boids.Seek.behave">behave</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.SentientCircle" href="#boids.SentientCircle">SentientCircle</a></code></h4>
<ul class="">
<li><code><a title="boids.SentientCircle.brain" href="#boids.SentientCircle.brain">brain</a></code></li>
<li><code><a title="boids.SentientCircle.draw_circle_steering_force" href="#boids.SentientCircle.draw_circle_steering_force">draw_circle_steering_force</a></code></li>
<li><code><a title="boids.SentientCircle.draw_fov" href="#boids.SentientCircle.draw_fov">draw_fov</a></code></li>
<li><code><a title="boids.SentientCircle.eyes" href="#boids.SentientCircle.eyes">eyes</a></code></li>
<li><code><a title="boids.SentientCircle.tick" href="#boids.SentientCircle.tick">tick</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Separation" href="#boids.Separation">Separation</a></code></h4>
<ul class="">
<li><code><a title="boids.Separation.behave" href="#boids.Separation.behave">behave</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.SimParamPanel" href="#boids.SimParamPanel">SimParamPanel</a></code></h4>
</li>
<li>
<h4><code><a title="boids.Simulation" href="#boids.Simulation">Simulation</a></code></h4>
<ul class="">
<li><code><a title="boids.Simulation.check_entity_clicked" href="#boids.Simulation.check_entity_clicked">check_entity_clicked</a></code></li>
<li><code><a title="boids.Simulation.height" href="#boids.Simulation.height">height</a></code></li>
<li><code><a title="boids.Simulation.initialize_scenario" href="#boids.Simulation.initialize_scenario">initialize_scenario</a></code></li>
<li><code><a title="boids.Simulation.is_running" href="#boids.Simulation.is_running">is_running</a></code></li>
<li><code><a title="boids.Simulation.mouse_entered" href="#boids.Simulation.mouse_entered">mouse_entered</a></code></li>
<li><code><a title="boids.Simulation.mouse_left" href="#boids.Simulation.mouse_left">mouse_left</a></code></li>
<li><code><a title="boids.Simulation.mouse_pos" href="#boids.Simulation.mouse_pos">mouse_pos</a></code></li>
<li><code><a title="boids.Simulation.move_mouse" href="#boids.Simulation.move_mouse">move_mouse</a></code></li>
<li><code><a title="boids.Simulation.reset" href="#boids.Simulation.reset">reset</a></code></li>
<li><code><a title="boids.Simulation.selected_entity" href="#boids.Simulation.selected_entity">selected_entity</a></code></li>
<li><code><a title="boids.Simulation.size" href="#boids.Simulation.size">size</a></code></li>
<li><code><a title="boids.Simulation.sprites" href="#boids.Simulation.sprites">sprites</a></code></li>
<li><code><a title="boids.Simulation.tick" href="#boids.Simulation.tick">tick</a></code></li>
<li><code><a title="boids.Simulation.toggle_running" href="#boids.Simulation.toggle_running">toggle_running</a></code></li>
<li><code><a title="boids.Simulation.width" href="#boids.Simulation.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.StartStopPanel" href="#boids.StartStopPanel">StartStopPanel</a></code></h4>
<ul class="">
<li><code><a title="boids.StartStopPanel.next_button" href="#boids.StartStopPanel.next_button">next_button</a></code></li>
<li><code><a title="boids.StartStopPanel.reset_button" href="#boids.StartStopPanel.reset_button">reset_button</a></code></li>
<li><code><a title="boids.StartStopPanel.start_stop_button" href="#boids.StartStopPanel.start_stop_button">start_stop_button</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.SteeringBehavior" href="#boids.SteeringBehavior">SteeringBehavior</a></code></h4>
<ul class="">
<li><code><a title="boids.SteeringBehavior.add_target_entity" href="#boids.SteeringBehavior.add_target_entity">add_target_entity</a></code></li>
<li><code><a title="boids.SteeringBehavior.attraction_repulsion_force" href="#boids.SteeringBehavior.attraction_repulsion_force">attraction_repulsion_force</a></code></li>
<li><code><a title="boids.SteeringBehavior.behave" href="#boids.SteeringBehavior.behave">behave</a></code></li>
<li><code><a title="boids.SteeringBehavior.remove_target_entity" href="#boids.SteeringBehavior.remove_target_entity">remove_target_entity</a></code></li>
<li><code><a title="boids.SteeringBehavior.resulting_direction" href="#boids.SteeringBehavior.resulting_direction">resulting_direction</a></code></li>
<li><code><a title="boids.SteeringBehavior.target_entities" href="#boids.SteeringBehavior.target_entities">target_entities</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Updatable" href="#boids.Updatable">Updatable</a></code></h4>
<ul class="">
<li><code><a title="boids.Updatable.tick" href="#boids.Updatable.tick">tick</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Utils" href="#boids.Utils">Utils</a></code></h4>
<ul class="">
<li><code><a title="boids.Utils.clamp_max" href="#boids.Utils.clamp_max">clamp_max</a></code></li>
<li><code><a title="boids.Utils.readfile" href="#boids.Utils.readfile">readfile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.ViewWindow" href="#boids.ViewWindow">ViewWindow</a></code></h4>
<ul class="">
<li><code><a title="boids.ViewWindow.canvas" href="#boids.ViewWindow.canvas">canvas</a></code></li>
<li><code><a title="boids.ViewWindow.image_draw" href="#boids.ViewWindow.image_draw">image_draw</a></code></li>
<li><code><a title="boids.ViewWindow.image_label" href="#boids.ViewWindow.image_label">image_label</a></code></li>
<li><code><a title="boids.ViewWindow.toggle_crazy_mode" href="#boids.ViewWindow.toggle_crazy_mode">toggle_crazy_mode</a></code></li>
<li><code><a title="boids.ViewWindow.toggle_draw_circle" href="#boids.ViewWindow.toggle_draw_circle">toggle_draw_circle</a></code></li>
<li><code><a title="boids.ViewWindow.toggle_draw_fov" href="#boids.ViewWindow.toggle_draw_fov">toggle_draw_fov</a></code></li>
<li><code><a title="boids.ViewWindow.toggle_draw_speed" href="#boids.ViewWindow.toggle_draw_speed">toggle_draw_speed</a></code></li>
<li><code><a title="boids.ViewWindow.toggle_draw_steering_force" href="#boids.ViewWindow.toggle_draw_steering_force">toggle_draw_steering_force</a></code></li>
<li><code><a title="boids.ViewWindow.toggle_jungle_background" href="#boids.ViewWindow.toggle_jungle_background">toggle_jungle_background</a></code></li>
<li><code><a title="boids.ViewWindow.update_view" href="#boids.ViewWindow.update_view">update_view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.VisualParamPanel" href="#boids.VisualParamPanel">VisualParamPanel</a></code></h4>
<ul class="">
<li><code><a title="boids.VisualParamPanel.crazy_mode_checkbutton" href="#boids.VisualParamPanel.crazy_mode_checkbutton">crazy_mode_checkbutton</a></code></li>
<li><code><a title="boids.VisualParamPanel.jungle_background_checkbutton" href="#boids.VisualParamPanel.jungle_background_checkbutton">jungle_background_checkbutton</a></code></li>
<li><code><a title="boids.VisualParamPanel.show_circle_checkbutton" href="#boids.VisualParamPanel.show_circle_checkbutton">show_circle_checkbutton</a></code></li>
<li><code><a title="boids.VisualParamPanel.show_fov_checkbutton" href="#boids.VisualParamPanel.show_fov_checkbutton">show_fov_checkbutton</a></code></li>
<li><code><a title="boids.VisualParamPanel.speed_checkbutton" href="#boids.VisualParamPanel.speed_checkbutton">speed_checkbutton</a></code></li>
<li><code><a title="boids.VisualParamPanel.steering_force_checkbutton" href="#boids.VisualParamPanel.steering_force_checkbutton">steering_force_checkbutton</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boids.Wander" href="#boids.Wander">Wander</a></code></h4>
<ul class="">
<li><code><a title="boids.Wander.behave" href="#boids.Wander.behave">behave</a></code></li>
<li><code><a title="boids.Wander.circle_distance" href="#boids.Wander.circle_distance">circle_distance</a></code></li>
<li><code><a title="boids.Wander.draw" href="#boids.Wander.draw">draw</a></code></li>
<li><code><a title="boids.Wander.radius" href="#boids.Wander.radius">radius</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>